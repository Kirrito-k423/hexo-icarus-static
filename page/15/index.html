<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SHAOJIE&#039;S BOOK</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SHAOJIE&#039;S BOOK"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SHAOJIE&#039;S BOOK"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="SHAOJIE&#039;S BOOK"><meta property="og:url" content="http://icarus.shaojiemike.top/"><meta property="og:site_name" content="SHAOJIE&#039;S BOOK"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://icarus.shaojiemike.top/img/og_image.png"><meta property="article:author" content="Shaojie Tan"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://icarus.shaojiemike.top/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://icarus.shaojiemike.top"},"headline":"SHAOJIE'S BOOK","image":["http://icarus.shaojiemike.top/img/og_image.png"],"author":{"@type":"Person","name":"Shaojie Tan"},"publisher":{"@type":"Organization","name":"SHAOJIE'S BOOK","logo":{"@type":"ImageObject","url":"http://icarus.shaojiemike.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-15T16:00:00.000Z" title="8/15/2023, 4:00:00 PM">2023-08-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.573Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">a minute read (About 164 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/15/Work/software/linux/cpu-time/">Cpu Time</a></p><div class="content"><h2 id="Situation"><a href="#Situation" class="headerlink" title="Situation"></a>Situation</h2><p>It is all started with two confusing situation.</p>
<ul>
<li>I found out using <code>ps aux | grep -v process_name</code>, the process is in <code>Sl+</code> state. But the cpu usage is not zero.</li>
<li><code>watch &quot;ps aux |grep 3496617&quot;</code> always show the same cpu usage percentage, which is very confusing beacause <code>htop</code> always show up-down value. and <code>pidstat -p 3516617</code> show cpu% less than 100%.</li>
</ul>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><ol>
<li>figure out how <code>htop</code> calculate the cpu usage percentage of a process.</li>
<li>why <code>ps</code> and <code>pidstat</code> choose different calculate ways.</li>
</ol>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/141586/what-does-utilization-mean-in-htop-if-only-1-process-can-execute-at-a-time">https://unix.stackexchange.com/questions/141586/what-does-utilization-mean-in-htop-if-only-1-process-can-execute-at-a-time</a></p>
<h2 id="Result-Explanation"><a href="#Result-Explanation" class="headerlink" title="Result &amp; Explanation"></a>Result &amp; Explanation</h2><h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>上面回答部分<strong>来自ChatGPT-3.5</strong>，没有进行正确性的交叉校验。</p>
<div id='refer-anchor'></div>

<p>无</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-08T16:00:00.000Z" title="8/8/2023, 4:00:00 PM">2023-08-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.573Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/tips/">tips</a></span><span class="level-item">13 minutes read (About 1938 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/08/Work/software/manager/git/gitStandardization/">Git Standardization</a></p><div class="content"><h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><h2 id="内容模板"><a href="#内容模板" class="headerlink" title="内容模板"></a>内容模板</h2><p>隐藏文件夹 .github , 里面放两个文件：</p>
<p>ISSUE_TEMPLATE.md</p>
<p>PULL_REQUEST_TEMPLATE.md</p>
<h2 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h2><h3 id="Git-Flow-分支模型"><a href="#Git-Flow-分支模型" class="headerlink" title="Git Flow 分支模型"></a>Git Flow 分支模型</h3><p>仓库有两个基础分支：</p>
<pre><code>dev（默认分支）
master（用于发布）
</code></pre>
<p>通过pull request来合并新的代码：</p>
<pre><code>协作者的代码通过pr合并到dev
dev通过pr合并到master
</code></pre>
<p>注意点：</p>
<pre><code>merge 到 dev，使用squash merge
merge 到 master，使用普通的merge
永远不向master直接commit代码
</code></pre>
<p><img src="https://pic.shaojiemike.top/img/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0RSUHJpbmNlc3MvQmxvZ0ltYWdlcy9tYXN0ZXIvcWluaXUvZjJhOGUyYmU3YjQ1MTU2NjUxMzdjYzI5NWQ2MzQ3YTUucG5n.png"></p>
<h3 id="GitHub-Flow-分支模型"><a href="#GitHub-Flow-分支模型" class="headerlink" title="GitHub Flow 分支模型"></a>GitHub Flow 分支模型</h3><p>只有一个长期分支 master ,而且 master 分支上的代码，永远是可发布状态,</p>
<h2 id="CI-Continuous-Integration-集成"><a href="#CI-Continuous-Integration-集成" class="headerlink" title="CI(Continuous Integration)集成"></a>CI(Continuous Integration)集成</h2><h3 id="netlify"><a href="#netlify" class="headerlink" title="netlify"></a>netlify</h3><p>to do</p>
<h3 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h3><p>github自带的，貌似比Travis CI好用</p>
<p>ctest 怎么写</p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p>
<h3 id="travis-ci"><a href="#travis-ci" class="headerlink" title="travis ci"></a>travis ci</h3><p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p>
<p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p>
<ol>
<li><p>使用准备</p>
<ol>
<li>登录 <a target="_blank" rel="noopener" href="https://app.travis-ci.com/">https://app.travis-ci.com/</a> ,绑定github,选择监听仓库.</li>
<li>项目里面有可运行的代码,项目还包含构建或测试脚本</li>
</ol>
</li>
<li><p><code>.travis.yml</code></p>
<ol>
<li>在项目根目录下新建 .travis.yml 文件。参考官方文档编写 <a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/languages/cpp/">https://docs.travis-ci.com/user/languages/cpp/</a></li>
</ol>
</li>
<li><p>运行流程</p>
<ol>
<li>install 阶段：安装依赖</li>
<li>script 阶段：运行脚本</li>
</ol>
</li>
<li><p>可选部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before_install：install 阶段之前执行</span><br><span class="line">before_script：script 阶段之前执行</span><br><span class="line">after_failure：script 阶段失败时执行</span><br><span class="line">after_success：script 阶段成功时执行</span><br><span class="line">before_deploy：deploy 步骤之前执行</span><br><span class="line">after_deploy：deploy 步骤之后执行</span><br><span class="line">after_script：script 阶段之后执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">passed：运行成功，所有步骤的退出码都是0</span><br><span class="line">canceled：用户取消执行</span><br><span class="line">errored：before_install、install、before_script有非零退出码，运行会立即停止</span><br><span class="line">failed ：script有非零状态码 ，会继续运行</span><br></pre></td></tr></table></figure>
</li>
<li><p>可选加密环境变量</p>
</li>
</ol>
<h2 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h2><p>Angular规范</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<h3 id="type-必须"><a href="#type-必须" class="headerlink" title="type 必须"></a>type 必须</h3><table>
<thead>
<tr>
<th>name</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>feat：</td>
<td>新功能（feature）。</td>
</tr>
<tr>
<td>fix&#x2F;to：</td>
<td>修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。</td>
</tr>
<tr>
<td>fix：</td>
<td>产生diff并自动修复此问题。适合于一次提交直接修复问题</td>
</tr>
<tr>
<td>to：</td>
<td>只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</td>
</tr>
<tr>
<td>docs：</td>
<td>文档（documentation）。</td>
</tr>
<tr>
<td>style：</td>
<td>格式（不影响代码运行的变动）。</td>
</tr>
<tr>
<td>refactor：</td>
<td>重构（即不是新增功能，也不是修改bug的代码变动）。</td>
</tr>
<tr>
<td>perf：</td>
<td>优化相关，比如提升性能、体验。</td>
</tr>
<tr>
<td>test：</td>
<td>增加测试。</td>
</tr>
<tr>
<td>chore：</td>
<td>构建过程或辅助工具的变动。</td>
</tr>
<tr>
<td>revert：</td>
<td>回滚到上一个版本。</td>
</tr>
<tr>
<td>merge：</td>
<td>代码合并。</td>
</tr>
<tr>
<td>sync：</td>
<td>同步主线或分支的Bug。</td>
</tr>
</tbody></table>
<h3 id="规范化commit-message"><a href="#规范化commit-message" class="headerlink" title="规范化commit message"></a>规范化commit message</h3><p>格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于Revert：<br>If the commit reverts a previous commit, it should begin with <code>revert:</code>, followed by the header of the reverted commit. In the body it should say: <code>This reverts commit &lt;hash&gt;.</code>, where the hash is <strong>the SHA of the commit being reverted</strong>.</li>
<li><strong>type</strong>的类型有：</li>
</ol>
<ul>
<li>feat: A new feature</li>
<li>fix: A bug fix</li>
<li>docs: Documentation only changes</li>
<li>style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)空白、格式、缺少分号等</li>
<li>refactor:(重构) A code change that neither fixes a bug nor adds a feature</li>
<li>perf: A code change that improves performance</li>
<li>test: Adding missing or correcting existing tests</li>
<li>chore: (琐事)Changes to the build process or auxiliary tools（辅助工具） and libraries such as documentation generation</li>
</ul>
<ol start="3">
<li><strong>scope</strong>:<br>commit 改变的位置，如果是多处写<code>*</code></li>
<li><strong>subject</strong>:<br>简明的描述：<ol>
<li>使用祈使句，现在时态</li>
<li>不要<code>.</code>结尾</li>
<li>第一个字母不要大写</li>
</ol>
</li>
<li><strong>body</strong>:<br>包括改变的动机，并将其与以前的行为进行对比。</li>
<li><strong>footer</strong>:<br>Breaking Changes或者reference GitHub issues that this commit closes.<br>Breaking Changes should start with the word<code>BREAKING CHANGE:</code> with a space or two newlines. The rest of the commit message is then used for this.</li>
</ol>
<h2 id="自动生成Release-Notes"><a href="#自动生成Release-Notes" class="headerlink" title="自动生成Release Notes"></a>自动生成Release Notes</h2><h3 id="规范化commit"><a href="#规范化commit" class="headerlink" title="规范化commit"></a>规范化commit</h3><p>插件 vscode插件git-commit-plugin</p>
<p>命令行 husky + commitlint</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol>
<li><p>Standard Version</p>
<ol>
<li>实现自动化版本控制,自动创建changelog, 创建 git tags</li>
<li>安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force #npm指令清除npm缓存</span><br><span class="line"># 删除node_module包</span><br><span class="line">npm install -g npm # npm 更新到最新</span><br><span class="line">npm install -g n</span><br><span class="line">n latest # node 更新</span><br><span class="line">   Note: the node command changed location and the old location may be remembered in your current shell.</span><br><span class="line">            old : /usr/bin/node</span><br><span class="line">            new : /usr/local/bin/node</span><br><span class="line">   To reset the command location hash either start a new shell, or execute PATH=$PATH&quot;</span><br><span class="line">PATH=/usr/local/bin/:$PATH</span><br><span class="line">npm install -D standard-version</span><br></pre></td></tr></table></figure>

<ol>
<li>编写package.json</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;release&quot;: &quot;standard-version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>CHANGELOG.md 记录内容的配置</p>
<ol>
<li>创建.versionrc</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;types&quot;: [</span><br><span class="line">   &#123;&quot;type&quot;: &quot;chore&quot;, &quot;section&quot;:&quot;Others&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;revert&quot;, &quot;section&quot;:&quot;Reverts&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;feat&quot;, &quot;section&quot;: &quot;Features&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;fix&quot;, &quot;section&quot;: &quot;Bug Fixes&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;improvement&quot;, &quot;section&quot;: &quot;Feature Improvements&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;docs&quot;, &quot;section&quot;:&quot;Docs&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;style&quot;, &quot;section&quot;:&quot;Styling&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;refactor&quot;, &quot;section&quot;:&quot;Code Refactoring&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;perf&quot;, &quot;section&quot;:&quot;Performance Improvements&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;test&quot;, &quot;section&quot;:&quot;Tests&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;build&quot;, &quot;section&quot;:&quot;Build System&quot;, &quot;hidden&quot;: false&#125;,</span><br><span class="line">   &#123;&quot;type&quot;: &quot;ci&quot;, &quot;section&quot;:&quot;CI&quot;, &quot;hidden&quot;:false&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Standard Version</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 初次发布版本</span><br><span class="line">npm run release --first-release</span><br><span class="line">npm run release #(自动更新版本号，自动更新 CHANGELOG.md, 自动创建 git tag)</span><br><span class="line">git push --follow-tags origin master</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><img src="https://pic.shaojiemike.top/img/20210906205719.png" alt="寄"></li>
</ol>
</li>
<li><p>Commitizen for contributors</p>
<ol>
<li>Linux下commit规范辅助，用来选择(没vscode的时候用)</li>
<li>用 git-cz 来提交文件</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/acfdd4ca0104">https://www.jianshu.com/p/acfdd4ca0104</a></li>
</ol>
</li>
<li><p>Visual Studio Code Commitizen Support<br>vscode的插件</p>
</li>
<li><p>conventional-changelog&#x2F;commitlint<br>阻止不规范的提交</p>
</li>
</ol>
<h3 id="github-release-notes"><a href="#github-release-notes" class="headerlink" title="github-release-notes"></a>github-release-notes</h3><p>github-release-notes，以下简称 gren ，是用来一键向 github 发布 release notes 的工具。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99499246">https://zhuanlan.zhihu.com/p/99499246</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39586683/article/details/110643111">https://blog.csdn.net/weixin_39586683/article/details/110643111</a></p>
<h2 id="release-语义化版本-semver"><a href="#release-语义化版本-semver" class="headerlink" title="release 语义化版本 semver"></a>release 语义化版本 semver</h2><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>
<p>主版本号：当你做了不兼容的 API 修改，<br>次版本号：当你做了向下兼容的功能性新增，<br>修订号：当你做了向下兼容的问题修正。<br>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>
<h2 id="Git-auto-release-requirements"><a href="#Git-auto-release-requirements" class="headerlink" title="Git auto-release requirements"></a>Git auto-release requirements</h2><ol>
<li>github Actions &#x2F; travis-ci<ol>
<li>自动化测试</li>
</ol>
</li>
<li>Commitizen &#x2F; Visual Studio Code Commitizen Support<ol>
<li>规范commit message</li>
</ol>
</li>
<li>standard-version<ol>
<li>更新 package 版本并打 tag</li>
</ol>
</li>
<li>github-release-notes<ol>
<li>生成 release-log</li>
</ol>
</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>写个github模板</p>
<ol>
<li>明确文件结构<ol>
<li>src&#x2F;include&#x2F;build&#x2F;Doc&#x2F;Debug&#x2F;test&#x2F;example</li>
</ol>
</li>
<li>清晰的README<ol>
<li>Intro&#x2F;Install&amp;Run&#x2F;Features&#x2F;Bugs&#x2F;Acknowledge</li>
<li>图片和标签<ol>
<li><a target="_blank" rel="noopener" href="https://shields.io/category/build">https://shields.io/category/build</a></li>
</ol>
</li>
</ol>
</li>
<li>Release的自动发布<ol>
<li>规范commit</li>
</ol>
</li>
<li>其他自动化的轮子持续整合 (Continuous Integration, CI)<ol>
<li>travis ci</li>
<li>github action<ol>
<li>ctest 怎么写？</li>
</ol>
</li>
<li>cmake.yml</li>
<li>.github&#x2F;workflow<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/iBug/AWS-Lambda-webhook-py/tree/master/.github/workflows">https://github.com/iBug/AWS-Lambda-webhook-py/tree/master/.github/workflows</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kirrito-k423/github-stats">https://github.com/Kirrito-k423/github-stats</a></li>
</ol>
</li>
<li>文档生成<ol>
<li>doxygen</li>
<li>Doxygen主要解决说明书问题，可以在我们写代码的时候讲注释转化为说明书，Graphviz主要是用于图形展示</li>
<li>有项目，文件，函数三部分的书写要求 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/silencehuan/p/11169084.html">https://www.cnblogs.com/silencehuan/p/11169084.html</a></li>
</ol>
</li>
<li>Codecov<ol>
<li>代码覆盖率，执行部分占比。因为未执行部分可能是错的</li>
</ol>
</li>
</ol>
</li>
<li>projects&#x2F; bug fixs</li>
<li>设置为 template repository</li>
<li>查看 <a target="_blank" rel="noopener" href="https://app.travis-ci.com/github/Kirrito-k423/githubTemplate">https://app.travis-ci.com/github/Kirrito-k423/githubTemplate</a></li>
</ol>
<h2 id="plus"><a href="#plus" class="headerlink" title="plus"></a>plus</h2><h3 id="将网站变成带名字的md格式参考文献的插件"><a href="#将网站变成带名字的md格式参考文献的插件" class="headerlink" title="将网站变成带名字的md格式参考文献的插件"></a>将网站变成带名字的md格式参考文献的插件</h3><h3 id="Boost-设置"><a href="#Boost-设置" class="headerlink" title="Boost 设置"></a>Boost 设置</h3><p>set(Boost_USE_STATIC_LIBS ON)</p>
<p>set(Boost_DEBUG ON)</p>
<p>Boost_INCLUDE_DIR: 含有boost头文件的目录<br>Boost_LIBRARYDIR: 偏好的含有boost库的库目录</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3897839/how-to-link-c-program-with-boost-using-cmake">https://stackoverflow.com/questions/3897839/how-to-link-c-program-with-boost-using-cmake</a></p>
<h3 id="Boost-Install"><a href="#Boost-Install" class="headerlink" title="Boost Install"></a>Boost Install</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7772.html">http://c.biancheng.net/view/7772.html</a> cache?</p>
<p>cmake boost install path</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/107360">https://cloud.tencent.com/developer/ask/107360</a></p>
<p>设置boost-root 查看安装位置</p>
<h3 id="Travis-CI-Install"><a href="#Travis-CI-Install" class="headerlink" title="Travis-CI Install"></a>Travis-CI Install</h3><p>Travis-CI 依赖软件包每次都要重新安装吗</p>
<h3 id="apt-get-install-in-a-GitHub-Actions-workflow"><a href="#apt-get-install-in-a-GitHub-Actions-workflow" class="headerlink" title="apt-get install in a GitHub Actions workflow"></a>apt-get install in a GitHub Actions workflow</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57982945/how-to-apt-get-install-in-a-github-actions-workflow">https://stackoverflow.com/questions/57982945/how-to-apt-get-install-in-a-github-actions-workflow</a></p>
<p>Actions may have no Boost, where</p>
<h3 id="ctest"><a href="#ctest" class="headerlink" title="ctest"></a>ctest</h3><p>Ctest add build&#x2F;bin to test</p>
<p>Ctest <a target="_blank" rel="noopener" href="https://www.cnblogs.com/hustcpp/p/12922998.html">https://www.cnblogs.com/hustcpp/p/12922998.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zcteo/article/details/117527823?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-15.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-15.no_search_link">https://blog.csdn.net/zcteo/article/details/117527823?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-15.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-15.no_search_link</a></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><p>还是ipcc的github组织的太烂了，需要学习一下</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67620599">https://zhuanlan.zhihu.com/p/67620599</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html">http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/levy9527/blog/issues/1">https://github.com/levy9527/blog/issues/1</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-07T16:00:00.000Z" title="8/7/2023, 4:00:00 PM">2023-08-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.557Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/operating-system/">operating system</a></span><span class="level-item">9 minutes read (About 1391 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/07/Work/Operating%20system/Executablefilerunningprocess/">Linux Executable file: Structure &amp; Running 2</a></p><div class="content"><h2 id="可执行文件的运行"><a href="#可执行文件的运行" class="headerlink" title="可执行文件的运行"></a>可执行文件的运行</h2><p>要运行可执行目标文件 prog，我们可以在 Linux shell 的命令行中输入它的名字：<br><code>linux&gt; ./prog</code><br>因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件。</p>
<h3 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h3><ul>
<li>Linux进程的启动是通过父进程复制一个子进程，子进程<a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/part2/ch08-exceptional-control-flow/8.4-process-control#8.4.5-jia-zai-bing-yun-hang-cheng-xu">通过execve系统调用启动加载器。</a><ul>
<li>加载器（loader）删除子进程已有的虚拟存储段，</li>
<li>通过将虚拟地址空间中的页映射到可执行文件的页大小组块，</li>
<li>并创建一组新的代码、数据、堆、栈段，</li>
<li>同时新的堆和栈被初始化为零。</li>
<li>新的代码和数据段被初始化为可执行文件的内容，</li>
<li>最后将CUP指令寄存器设置成可执行文件入口，启动运行。</li>
</ul>
</li>
</ul>
<p>执行完上述操作后，其实可执行文件的真正指令和数据都没有别装入内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚拟内存之间的映射关系而已。</p>
<p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8pquOBkqRu_B1qWTy%2F-MI8q_Q9zCjP43SJa6VX%2F07-15%20Linux%20x86-64%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F.png?alt=media&token=9d8f7d7e-ccda-48d1-814a-8a38ccb2ff8a" alt="memory map"></p>
<p>除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</p>
<p>比如，现在程序的入口地址为 <code>0x08048000</code> ，刚好是代码段的起始地址。当CPU打算执行这个地址的指令时，发现页面 <code>0x8048000</code> ~ <code>0x08049000</code> (一个页面一般是4K)是个空页面，于是它就认为是个页错误。此时操作系统根据虚拟地址空间与可执行文件间的映射关系找到页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，并在虚拟地址页面与物理页面间建立映射，最后把EXE文件中页面拷贝到内存的物理页面，进程重新开始执行。该过程如下图所示：</p>
<p><img src="https://pic.shaojiemike.top/img/Inked20150612143758289_LI.jpg"></p>
<p>接下来，加载器跳转到程序的入口点，也就是 <code>_start</code>函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 <code>__libc_start_main</code>，该函数定义在 <code>libc.so</code> 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。</p>
<h3 id="fork-和-execve-函数的差异"><a href="#fork-和-execve-函数的差异" class="headerlink" title="fork 和 execve 函数的差异"></a>fork 和 execve 函数的差异</h3><ul>
<li>fork 函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。</li>
<li>execve 函数在当前进程的上下文中加载并运行一个新的程序。<ul>
<li>它会覆盖当前进程的地址空间，但并没有创建一个新进程。</li>
<li>新的程序仍然有相同的 PID，并且继承了调用 execve 函数时已打开的所有文件描述符。</li>
</ul>
</li>
</ul>
<h3 id="程序运行途中修改exe程序"><a href="#程序运行途中修改exe程序" class="headerlink" title="程序运行途中修改exe程序"></a>程序运行途中修改exe程序</h3><ul>
<li>由于操作系统使用页表和虚拟内存机制来实现按需加载。按需加载意味着只有在程序执行到需要访问某个代码段时，才会将该代码段从可执行文件加载到内存中。</li>
<li>那么如果我在程序运行的途中重新编译程序，修改了代码段，那么程序会怎么样呢？<ul>
<li>Chatgpt：运行中的程序尝试执行新的代码时，会发生未定义的行为，因为操作系统不会自动将新的代码加载到正在运行的进程的内存中。</li>
<li>一个页表4KB，一个程序的代码段可能有如下100KB甚至几十MB，不可能全部加载。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shaojiemike @ snode6 in ~/github/sniper_PIMProf/PIMProf/gapbs on git:dev o [15:15:29]</span></span><br><span class="line">$ size /usr/lib/llvm-10/bin/llvm-mca</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line"> 144530    6056    8089  158675   26bd3 /usr/lib/llvm-10/bin/llvm-mca</span><br><span class="line"></span><br><span class="line"><span class="comment"># shaojiemike @ snode6 in ~/github/sniper_PIMProf/PIMProf/gapbs on git:dev o [15:18:14]</span></span><br><span class="line">$ l /usr/lib/llvm-10/bin/llvm-mca</span><br><span class="line">-rwxr-xr-x 1 root root 153K Apr 20  2020 /usr/lib/llvm-10/bin/llvm-mca</span><br></pre></td></tr></table></figure>

<h3 id="程序运行途中修改python代码"><a href="#程序运行途中修改python代码" class="headerlink" title="程序运行途中修改python代码"></a>程序运行途中修改python代码</h3><ul>
<li>虽然修改python代码类似修改C代码，按理来说不会影响程序进行。但是python是逐行解释执行的，很难让人不思考会不会影响正在运行中的程序。</li>
<li>答案是不会，原因有二：<ul>
<li>python代码在运行时，会被编译成字节码，然后再执行字节码。修改python代码后，其对应的字节码会在下一次运行程序时，Python解释器对比文件时间戳时更新。</li>
<li>Python解释器在运行时，会将所需的文件提前加载到内存里</li>
</ul>
</li>
</ul>
<h3 id="GDB调试修改"><a href="#GDB调试修改" class="headerlink" title="GDB调试修改"></a>GDB调试修改</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-07T16:00:00.000Z" title="8/7/2023, 4:00:00 PM">2023-08-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.557Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/operating-system/">operating system</a></span><span class="level-item">11 minutes read (About 1680 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/07/Work/Operating%20system/memalloc/">Memalloc</a></p><div class="content"><p><a href="#refer-anchor"><sup>2</sup></a></p>
<h2 id="Buddy-内存分配"><a href="#Buddy-内存分配" class="headerlink" title="Buddy 内存分配"></a>Buddy 内存分配</h2><p>是一种用于管理计算机内存的算法，旨在有效地分配和释放内存块，以防止碎片化并提高内存的使用效率。这种算法通常用于操作系统中，以管理系统内核和进程的内存分配。</p>
<p>Buddy 内存分配算法的基本思想是将物理内存划分为大小相等的块，每个块大小都是 2 的幂次方。每个块可以分配给一个正在运行的进程或内核。当内存被分配出去后，它可以被分割成更小的块，或者合并成更大的块，以适应不同大小的内存需求。</p>
<p>算法的名称 “Buddy” 来自于分配的块之间的关系，其中一个块被称为 “buddy”，它是另一个块的大小相等的邻居。这种关系使得在释放内存时，可以尝试将相邻的空闲块合并成更大的块，从而减少内存碎片。</p>
<p>Buddy 内存分配算法的工作流程大致如下：</p>
<ol>
<li><p>初始时，整个可用内存被视为一个大块，大小是 2 的幂次方。</p>
</li>
<li><p>当一个进程请求内存分配时，算法会搜索可用的块，找到大小合适的块来满足请求。如果找到的块比所需的稍大，它可以被分割成两个相等大小的 “buddy” 块，其中一个分配给请求的进程。</p>
</li>
<li><p>当一个进程释放内存时，该块会与其 “buddy” 块合并，形成一个更大的块。然后，这个更大的块可以与其它相邻的块继续合并，直到达到较大的块。</p>
</li>
</ol>
<p>Buddy 内存分配算法在一些操作系统中用于管理内核和进程的物理内存，尤其在嵌入式系统和实时操作系统中，以提高内存使用效率和避免碎片化问题。</p>
<h3 id="ucore（Micro-kernel-Operating-System-for-Education）"><a href="#ucore（Micro-kernel-Operating-System-for-Education）" class="headerlink" title="ucore（Micro-kernel Operating System for Education）"></a>ucore（Micro-kernel Operating System for Education）</h3><p>是一个用于教育目的的微内核操作系统</p>
<h2 id="linux遇到问题"><a href="#linux遇到问题" class="headerlink" title="linux遇到问题"></a>linux遇到问题</h2><p>我们可window写程序占满16G内存</p>
<p>但是linux,用了3GB就会seg fault</p>
<p>猜想是不是有单进程内存限制 <a target="_blank" rel="noopener" href="https://www.imooc.com/wenda/detail/570992">https://www.imooc.com/wenda/detail/570992</a></p>
<p><img src="https://pic.shaojiemike.top/img/20150603163431433.png"></p>
<p>而且malloc alloc的空间在堆区，我们可以明显的发现这个空间是被栈区包住的，有限的。windows是如何解决这个问题的呢？</p>
<ol>
<li>首先这个包住是虚拟地址，通过页表映射到的物理地址是分开的</li>
<li>根据第一点，可以实现高地址动态向上移动</li>
</ol>
<p>动态数据区一般就是“堆栈”。“栈 (stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然 代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数 据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。</p>
<p> 当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。</p>
<h2 id="Linux-单进程内存限制"><a href="#Linux-单进程内存限制" class="headerlink" title="Linux 单进程内存限制"></a>Linux 单进程内存限制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br><span class="line"></span><br><span class="line"># shaojiemike @ node5 in ~ [6:35:51]</span><br><span class="line">$ ulimit -a</span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-m: resident set size (kbytes)      unlimited</span><br><span class="line">-u: processes                       513967</span><br><span class="line">-n: file descriptors                1024</span><br><span class="line">-l: locked-in-memory size (kbytes)  65536</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 513967</span><br><span class="line">-q: bytes in POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br><span class="line"></span><br><span class="line">ulimit -HSn 4096 # H指定了硬性大小，S指定了软性大小，n表示设定单个进程最大的打开文件句柄数量。硬限制是实际的限制，而软限制，是warnning限制，只会做出warning</span><br><span class="line"></span><br><span class="line">lsof</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文件描述符</p>
<p>文件句柄数</p>
<p>这些限制一般不会限制内存。</p>
<h2 id="超算登录节点任务限制的实现"><a href="#超算登录节点任务限制的实现" class="headerlink" title="超算登录节点任务限制的实现"></a>超算登录节点任务限制的实现</h2><h2 id="GNU-malloc"><a href="#GNU-malloc" class="headerlink" title="GNU malloc()"></a>GNU malloc()</h2><p>调用malloc(size_t size)函数分配内存成功，总会<strong>分配size字节VM（再次强调不是RAM）</strong>，并返回一个指向刚才所分配内存区域的开端地址。分配的内存会为进程一直保留着，直到你显示地调用free()释放它（当然，整个进程结束，静态和动态分配的内存都会被系统回收）。</p>
<p>GNU libc库提供了二个内存分配函数,分别是malloc()和calloc()。glibc函数malloc()总是通过brk()或mmap()系统调用来满足内存分配需求。函数malloc()，根据<strong>不同大小内存</strong>要求来选择brk()，还是mmap()，阈值 MMAP_THRESHOLD&#x3D;128Kbytes是临界值。小块内存(&lt;&#x3D;128kbytes)，会调用brk()，它将<strong>数据段的最高地址往更高处推（堆从底部向上增长）</strong>。大块内存，则使用mmap()进行匿名映射(设置标志MAP_ANONYMOUS)来分配内存，<strong>与堆无关，在堆之外。</strong></p>
<p>malloc不是直接分配内存的，是第一次访问的时候才分配的？</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20836462">https://www.zhihu.com/question/20836462</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>堆区和栈区是进程唯一的吗？<ol>
<li>是的，而且栈主要是为一个线程配备，小可以保证基本在cache里</li>
</ol>
</li>
<li>两个操作系统的malloc的是物理内存还是虚拟内存</li>
<li>Linux采用的是copy-on-write机制</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><p><img src="https://pic.shaojiemike.top/img/20210821151824.png"><br><img src="https://pic.shaojiemike.top/img/20210821151852.png"><br>每次都是6008这里，40000*6008*3&#x2F;1024&#x2F;1024&#x3D;687MB<br><img src="https://pic.shaojiemike.top/img/20210821152053.png"><br>733448&#x2F;1024&#x3D;716MB<br><img src="https://pic.shaojiemike.top/img/20210821154550.png"><br>问了大师兄，问题竟然是malloc的传入参数错误的类型是int,导致存不下3*40*1024*40*1024。应该用size_t类型。（size_t是跨平台的非负整数安全类型）</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shenzi/article/details/3972437?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base">https://blog.csdn.net/shenzi/article/details/3972437?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justdoithai/article/details/51174457">程序（进程）内存空间分布深入理解</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-07T16:00:00.000Z" title="8/7/2023, 4:00:00 PM">2023-08-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.569Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Network/">Network</a></span><span class="level-item">16 minutes read (About 2454 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/07/Work/network/0-basic/firewall/">Firewall</a></p><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>防火墙是一种网络安全设备，主要是通过硬件和软件的作用于内部和外部网络的环境间产生一种保护的屏障，从而实现对计算机不安全网络因素的阻断。</p>
<ul>
<li>所有流入流出的所有网络通信均要经过此防火墙。</li>
<li>功能<ul>
<li>访问控制、隔离保护</li>
</ul>
</li>
<li>组成<ul>
<li>服务访问政策、验证工具、包过滤和应用网关</li>
</ul>
</li>
</ul>
<h3 id="功能作用"><a href="#功能作用" class="headerlink" title="功能作用"></a>功能作用</h3><ul>
<li>入侵检测功能<ul>
<li>主要有反端口扫描、检测拒绝服务工具、检测CGI&#x2F;IIS服务器入侵、检测木马或者网络蠕虫攻击、检测缓冲区溢出攻击等功能，</li>
<li>可以极大程度上减少网络威胁因素的入侵，有效阻挡大多数网络安全攻击。</li>
</ul>
</li>
<li>网络地址转换功能(NAT)<ul>
<li>分为源地址转换和目的地址转换，即SNAT和DNAT。可以由服务的发起者是谁来区分两者。</li>
<li>SNAT: 内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有ip<ul>
<li>修改源ip地址的目的一般都是为了让这个包能再回到自己这里，所以在iptables中，SNAT是在出口，也即<code>POSTROUTING</code>链发挥作用。</li>
<li>SNAT主要用于隐藏内部网络结构，避免受到来自外部网络的非法访问和恶意攻击，有效缓解地址空间的短缺问题，</li>
</ul>
</li>
<li>DNAT：当内部需要对外提供服务时，外部发起主动连接公有ip的网关，路由器或着防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有ip的网关代替内部服务来接收外部的连接，然后在内部做地址转换。<ul>
<li>修改目的ip地址的原因一般就是为了改变包发送的目的地，让包走出去，而不是留下来，所以在iptables中，DNAT是在入口，也即<code>PREROUTING</code>链中发挥作用，以便让包进入FORWARD表。</li>
<li>DNAT主要用于外网主机访问内网主机，以此避免内部网络被攻击。</li>
<li>DNAT与端口转发的区别在哪里？</li>
</ul>
</li>
</ul>
</li>
<li>网络操作的审计监控功能<ul>
<li>对系统管理的所有操作以及安全信息进行记录，提供有关网络使用情况的统计数据，方便计算机网络管理以进行信息追踪。</li>
</ul>
</li>
<li>强化网络安全服务(类似GFW)<ul>
<li>集中化的安全管理，将安全系统装配在防火墙上，在信息访问的途径中就可以实现对网络信息安全的监管。</li>
</ul>
</li>
</ul>
<h2 id="Linux实现原理"><a href="#Linux实现原理" class="headerlink" title="Linux实现原理"></a>Linux实现原理</h2><p><img src="https://pic.shaojiemike.top/img/20230409182640.png"></p>
<ul>
<li>Linux系统内核中的安全框架Netfilter，为其他内核模块提供数据包过滤、网络地址转换（NAT）和负载均衡的功能。</li>
<li>常用的iptables和firewalld服务都依赖于Netfilter来过滤数据包，两者自身并不具备防火墙的功能，只是创建并维护规则。<ul>
<li>不同之处在于iptables基于“过滤规则链”，firewalld基于zone区域。</li>
<li>iptables无守护进程，不能算作真正的服务，firewalld存在守护进程</li>
</ul>
</li>
</ul>
<h3 id="三表五链-三表-应用规则"><a href="#三表五链-三表-应用规则" class="headerlink" title="三表五链 - 三表(应用规则)"></a>三表五链 - 三表(应用规则)</h3><ul>
<li>filter 	用于过滤，防火墙，过滤数据包</li>
<li>nat 	 用于网络地址转换、端口转发</li>
<li>mangle 	用于拆解报文，作出修改，封装报文</li>
<li>raw表， 关闭nat表上启用的连接追踪机制，以提高性能。<ul>
<li>表规则应用优先级：raw&gt;mangle&gt;nat&gt;filter</li>
<li>每个表中能存在的链如下<br><img src="https://pic.shaojiemike.top/img/20230409183027.png"></li>
</ul>
</li>
</ul>
<h3 id="三表五链-五链-数据包状态-过滤规则链"><a href="#三表五链-五链-数据包状态-过滤规则链" class="headerlink" title="三表五链 - 五链(数据包状态&#x2F; 过滤规则链)"></a>三表五链 - 五链(数据包状态&#x2F; 过滤规则链)</h3><ul>
<li>PREROUTING 	进入路由之前的数据包</li>
<li>INPUT 	目的地址为本机的输入数据包</li>
<li>FORWARD 	目的地址不为本机的包，可以实现转发(需要开启)</li>
<li>OUTPUT 	源地址为本机的输出数据包</li>
<li>POSTROUTING  发送到网卡之前的数据包 	<br><img src="https://pic.shaojiemike.top/img/20230409212933.png"></li>
</ul>
<h2 id="Nftables"><a href="#Nftables" class="headerlink" title="Nftables"></a>Nftables</h2><ul>
<li>Allows configuration of tables, chains and rules provided by the Linux kernel firewall.</li>
<li><strong>Nftables replaces iptables.</strong><ul>
<li>解决的iptables的不足<ul>
<li>不同协议实现的代码重复</li>
<li>Nftables通过增强的通用集和映射基础结构，可以<strong>更快</strong>地进行数据包分类。</li>
<li>解决语法不一致的问题，并提供更好，更紧凑的语法。</li>
</ul>
</li>
</ul>
</li>
<li>OpenWRT和ubuntu都使用Nftables</li>
</ul>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>与iptables表的对应关系</p>
<table>
<thead>
<tr>
<th>nftables簇</th>
<th>iptables实用程序</th>
</tr>
</thead>
<tbody><tr>
<td>ip</td>
<td>iptables</td>
</tr>
<tr>
<td>ip6</td>
<td>ip6tables</td>
</tr>
<tr>
<td>inet</td>
<td>iptables和ip6tables</td>
</tr>
<tr>
<td>arp</td>
<td>arptables</td>
</tr>
<tr>
<td>bridge</td>
<td>ebtables</td>
</tr>
</tbody></table>
<ul>
<li><code>ip</code>（即IPv4）是默认簇，如果未指定簇，则使用该簇。</li>
<li>创建同时适用于IPv4和IPv6的规则，请使用<code>inet</code>。inet允许统一ip和ip6簇，以便更容易地定义规则。</li>
</ul>
<h3 id="输出解释"><a href="#输出解释" class="headerlink" title="输出解释"></a>输出解释</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">table inet warp <span class="punctuation">&#123;</span></span><br><span class="line">        chain warp-in <span class="punctuation">&#123;</span></span><br><span class="line">                type filter hook input priority mangle; policy accept;</span><br><span class="line">                ip6 saddr <span class="number">2606</span><span class="punctuation">:</span><span class="number">4700</span><span class="punctuation">:</span>d0<span class="punctuation">:</span><span class="punctuation">:</span>a29f<span class="punctuation">:</span>c001 udp sport <span class="number">1701</span> @th<span class="punctuation">,</span><span class="number">72</span><span class="punctuation">,</span><span class="number">24</span> set <span class="number">0x0</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">        chain warp-out <span class="punctuation">&#123;</span></span><br><span class="line">                type filter hook output priority mangle; policy accept;</span><br><span class="line">                ip6 daddr <span class="number">2606</span><span class="punctuation">:</span><span class="number">4700</span><span class="punctuation">:</span>d0<span class="punctuation">:</span><span class="punctuation">:</span>a29f<span class="punctuation">:</span>c001 udp dport <span class="number">1701</span> @th<span class="punctuation">,</span><span class="number">72</span><span class="punctuation">,</span><span class="number">24</span> set <span class="number">0x46c997</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>type</code> 可以是<code>filter</code>、<code>route</code>或者<code>nat</code>。</li>
<li><code>hook</code> 在IPv4&#x2F;IPv6&#x2F;Inet地址簇中，可以是<code>prerouting</code>、<code>input</code>、<code>forward</code>、<code>output</code>或者<code>postrouting</code>。其他地址簇中的钩子列表请参见nft(8)。</li>
</ul>
<h2 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h2><h3 id="查看默认表filter的规则"><a href="#查看默认表filter的规则" class="headerlink" title="查看默认表filter的规则"></a>查看默认表filter的规则</h3><p>对于每条链，内核会按照顺序依次检查 iptables 防火墙规则，如果发现有匹配的规则目录，则立刻执行相关动作，停止继续向下查找规则目录；如果所有的防火墙规则都未能匹配成功，则按照默认策略处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -vnL </span><br><span class="line">Chain INPUT (policy ACCEPT 2211K packets, 855M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 ACCEPT     all  --  tun0   *       0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<ul>
<li>命令<ul>
<li>默认 <code>-t filter</code> </li>
<li><code>-v</code> 显示详细信息，<code>-n</code>显示具体ip和端口数值</li>
</ul>
</li>
<li>输出<ul>
<li><code>policy ACCEPT</code> 当前链的默认策略 <code>ACCEPT</code></li>
<li><code>pkts</code>：对应规则匹配到的报文的个数。</li>
<li>bytes：对应匹配到的报文包的大小总和。</li>
<li>target：规则对应的target，往往表示规则对应的”动作”，即规则匹配成功后需要采取的措施。</li>
<li>prot：表示规则对应的协议，是否只针对某些协议应用此规则。</li>
<li>opt：表示规则对应的选项。</li>
<li>in：表示数据包由哪个接口(网卡)流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li>out：表示数据包由哪个接口(网卡)流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li>source：表示规则对应的源头地址，可以是一个IP，也可以是一个网段。</li>
<li>destination：表示规则对应的目标地址。可以是一个IP，也可以是一个网段。</li>
</ul>
</li>
</ul>
<h3 id="添加的动作"><a href="#添加的动作" class="headerlink" title="添加的动作"></a>添加的动作</h3><p>命令部分：<code>-j</code> + 如下动作</p>
<ul>
<li>ACCEPT：允许数据包通过。</li>
<li>DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</li>
<li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</li>
<li>SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</li>
<li><code>MASQUERADE</code>：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</li>
<li>DNAT：目标地址转换。</li>
<li>REDIRECT：在本机做端口映射。</li>
<li>LOG：在&#x2F;var&#x2F;log&#x2F;messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</li>
</ul>
<h3 id="iptables管理命令"><a href="#iptables管理命令" class="headerlink" title="iptables管理命令"></a>iptables管理命令</h3><ul>
<li>选择表<ul>
<li>-t指定表</li>
</ul>
</li>
<li>添加新规则<ul>
<li>-A在链的最后追加一条规则 </li>
<li>-I在链的开头或指定序号插入一条规则 </li>
<li>-x显示精确值，不做单位换算</li>
</ul>
</li>
<li>替换规则<ul>
<li>-R替换一条指定的规则</li>
</ul>
</li>
<li>查看规则<ul>
<li>-L列出所有规则 </li>
<li>-n以数据形式显示地址与端口信息 </li>
<li>-v以更加详细的方式显示 </li>
<li>–line-numbers查看规则时，显示规则序号</li>
</ul>
</li>
<li>删除或清空规则<ul>
<li>-D删除指定序号的一条规则 </li>
<li>-F清空指定表中的所有规则</li>
</ul>
</li>
<li>设置默认策略<ul>
<li>-P为指定的链设置默认规则</li>
</ul>
</li>
<li>新建规则链<ul>
<li>-N新建自定义链</li>
</ul>
</li>
<li>重命名链<ul>
<li>-E重命名自定义链</li>
</ul>
</li>
<li>删除链<ul>
<li>-X删除自定义空链 </li>
<li>-Z计数器清零</li>
</ul>
</li>
</ul>
<h3 id="常见实例"><a href="#常见实例" class="headerlink" title="常见实例"></a>常见实例</h3><p>Add a NAT rule to translate all traffic from the <code>192.168.0.0/24</code> subnet to the host’s public IP:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">$ sudo iptables -t nat -vnL --line-numbers</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 19 packets, 1551 bytes)</span><br><span class="line">num   pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">6        0     0 MASQUERADE  all  --  *      *       192.168.0.0/24       0.0.0.0/0</span><br><span class="line"></span><br><span class="line">$ sudo iptables -t nat -D POSTROUTING 6 <span class="comment">#delete</span></span><br></pre></td></tr></table></figure>
<h3 id="有待学习"><a href="#有待学习" class="headerlink" title="有待学习"></a>有待学习</h3><ul>
<li>docker相关的iptables的输出</li>
<li>OpenWRT上iptables完全是空的，是显示错误还是防火墙用了firewalld</li>
<li>node5上的warp的mangle在哪里？</li>
</ul>
<h2 id="Ubuntu配置"><a href="#Ubuntu配置" class="headerlink" title="Ubuntu配置"></a>Ubuntu配置</h2><h2 id="Windows配置"><a href="#Windows配置" class="headerlink" title="Windows配置"></a>Windows配置</h2><ul>
<li>入站规则</li>
<li>出站规则</li>
<li></li>
</ul>
<h2 id="OpenWRT配置"><a href="#OpenWRT配置" class="headerlink" title="OpenWRT配置"></a>OpenWRT配置</h2><p>to finished</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45649763/article/details/103338747">https://blog.csdn.net/weixin_45649763/article/details/103338747</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7108726951304495135">https://juejin.cn/post/7108726951304495135</a></p>
<p><a target="_blank" rel="noopener" href="https://icloudnative.io/posts/using-nftables/">https://icloudnative.io/posts/using-nftables/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-05T16:00:00.000Z" title="8/5/2023, 4:00:00 PM">2023-08-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.561Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/toLearn/">toLearn</a></span><span class="level-item">8 minutes read (About 1219 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/05/Work/Programming/2-languageGrammar/jupyter-ai/">Jupyter AI</a></p><div class="content"><h2 id="Jupyter-简介"><a href="#Jupyter-简介" class="headerlink" title="Jupyter 简介"></a>Jupyter 简介</h2><p>Jupyter是一个开源的、交互式的计算环境，可以让用户创建和共享包含实时代码、可视化和文本的文档。</p>
<ul>
<li>它的名字来源于三个主要的编程语言：Julia、Python和R，这三种语言的开头字母构成了“Jupyter”。</li>
<li>Jupyter最初是IPython项目的一部分，旨在提供Python的交互式计算环境。随着时间的推移，它不仅支持Python，还扩展到其他编程语言，包括R、Julia、Scala等。Jupyter的灵感来自于IPython的交互式shell，但在其基础上增加了更多功能和可扩展性。</li>
</ul>
<p>Jupyter最显著的特点：用户可以<strong>通过Web浏览器</strong>打开Jupyter笔记本，然后在其中编写代码、运行代码并直接查看代码的输出结果。笔记本中的代码和文本可以交叉编排，使得写作、数据分析和可视化变得非常直观和便捷。</p>
<p>主要的Jupyter组件包括：</p>
<ol>
<li>Jupyter Notebook：这是最常见的Jupyter界面，以.ipynb后缀的文件保存。它支持多种编程语言的代码运行，交互式地执行和编辑代码块，并支持在代码块中插入Markdown格式的文本以及图像、链接等内容。</li>
<li>Jupyter Lab：这是Jupyter Notebook的下一代界面，提供了更加现代化和灵活的界面。Jupyter Lab将各种组件整合到一个集成的界面中，使得多个笔记本、终端和文件浏览器可以在一个窗口中同时运行。</li>
<li>Jupyter Kernel：Jupyter支持多种编程语言的内核，通过内核，Jupyter可以与特定编程语言进行交互。例如，使用Python内核可以在笔记本中运行和编写Python代码，同样，使用R内核可以运行和编写R代码。</li>
</ol>
<p>Jupyter在教育、数据科学、机器学习、数据分析等领域得到广泛应用。它提供了一个方便、实用的平台，帮助用户探索数据、实验算法、展示结果，并通过共享笔记本方便地与其他人交流和合作。</p>
<h3 id="Jupyter-vs-python"><a href="#Jupyter-vs-python" class="headerlink" title="Jupyter vs python"></a>Jupyter vs python</h3><p>Jupyter 的<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37490497">核心</a>在于 数据分析的 计算-分析-可视化 的快速迭代。</p>
<p>如果不是数据科学，就不太需要Jupyter</p>
<h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><p>Anaconda和Miniconda都是针对数据科学和机器学习领域的Python发行版本，它们包含了许多常用的数据科学包和工具，使得安装和管理这些包变得更加简单。</p>
<p>解决了几个痛点：</p>
<ol>
<li>不同python环境的切换(类似VirtualEnv)</li>
<li>高效的包管理工具(类似pip,特别是在Windows上好用)</li>
</ol>
<p>Anaconda是一个全功能的Python发行版本，由Anaconda, Inc.（前称Continuum Analytics）提供。</p>
<ul>
<li>它包含了Python解释器以及大量常用的数据科学、机器学习和科学计算的第三方库和工具，如NumPy、Pandas、Matplotlib、SciPy等。</li>
<li>Anaconda还包含一个名为Conda的包管理器，用于安装、更新和管理这些库及其依赖项。</li>
<li>Anaconda发行版通常较大(500MB)，因为它预装了许多常用的包，适用于不希望从头开始搭建环境的用户。</li>
</ul>
<p>Miniconda是Anaconda的轻量级版本(50MB)，它也由Anaconda, Inc.提供。</p>
<ul>
<li>与Anaconda不同，Miniconda只包含了Python解释器和Conda包管理器，没有预装任何其他包。这意味着用户可以根据自己的需求手动选择要安装的包，从而实现一个精简而高度定制化的Python环境。</li>
<li>对于希望从零开始构建数据科学环境或需要更细粒度控制的用户，Miniconda是一个很好的选择。</li>
</ul>
<h2 id="Installation-in-Linux"><a href="#Installation-in-Linux" class="headerlink" title="Installation in Linux"></a>Installation in Linux</h2><p>安装<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166425946">Jupyter Lab</a></p>
<h2 id="web-forward-to-local-machine"><a href="#web-forward-to-local-machine" class="headerlink" title="web-forward to local machine"></a>web-forward to local machine</h2><p>远程访问服务器</p>
<h2 id="Jupyter-AI"><a href="#Jupyter-AI" class="headerlink" title="Jupyter-AI"></a>Jupyter-AI</h2><ol>
<li>Installation</li>
<li>test</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><ol>
<li>python 一大特点就是容易可视化，既然这样，我为什么不用jupyter呢？</li>
<li>chatgpt 类的工具都是基于付费API，有两大问题<ol>
<li>国内难以付费</li>
<li>国内ip一旦访问是很容易封号的。</li>
</ol>
</li>
<li>一种解决办法是使用有免费API的工具，并且在全流量走cloudflare的wg的服务器上配置服务。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>上面回答部分<strong>来自ChatGPT-3.5</strong>，没有进行正确性的交叉校验。</p>
<p><a target="_blank" rel="noopener" href="https://jupyter-ai.readthedocs.io/en/latest/users/index.html#installation">https://jupyter-ai.readthedocs.io/en/latest/users/index.html#installation</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-02T16:00:00.000Z" title="8/2/2023, 4:00:00 PM">2023-08-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.545Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/toLearn/">toLearn</a></span><span class="level-item">3 minutes read (About 464 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/02/Work/Algorithms/parallel_sort/">Parallel_sort</a></p><div class="content"><h2 id="并行排序算法"><a href="#并行排序算法" class="headerlink" title="并行排序算法"></a>并行排序算法</h2><p>to learn</p>
<h2 id="PSRS算法"><a href="#PSRS算法" class="headerlink" title="PSRS算法"></a>PSRS算法</h2><p>并行正则采样排序算法</p>
<p><img src="https://pic2.zhimg.com/80/v2-28a103ab8e3911ae13feaa3f9f663d51_1440w.webp" alt="PSRS"></p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>简单地讨论一下 PSRS 算法的复杂度。</p>
<ul>
<li>在第一部分的快速排序中，时间复杂度为O(klogk)，k&#x3D;n&#x2F;p</li>
<li>然后，各处理器选择 p-1 个代表元素，代价为O(p)</li>
<li>再由 Proc#0 对所有送来的代表元素进行排序，然后选出主元，这里若使用快速排序，代价为O(p^2 logp^2)<ul>
<li>而若使用归并排序，则所需代价为O(p^2)</li>
</ul>
</li>
<li>每个处理器接收到主元后，再对有序数组进行划分，代价为O(k+p)</li>
<li>最后，各个处理器全局交换，并行归并排序，<ul>
<li>每个处理器是串行的<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009723817">多路归并问题</a>，时间复杂度为<code>O(k*logp)</code></li>
</ul>
</li>
</ul>
<p>考虑到实际应用中，需要排序的数据长度 n 一定远远多于现有的处理器 p，此时可以视 p 为一个小常数，那么 PSRS 排序算法的时间复杂度，就可以简化为 <code>O(klogk+k*logp)~O(klogk)</code></p>
<p>从消息复杂度的角度看，</p>
<ul>
<li>播送主元的复杂度为 O(p^2+p)</li>
<li>分区合并（全局交换）部分的消息复杂度与具体算法实现相关，但其最大值不会超过 O(n)</li>
</ul>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><!-- 字节的面试官抓着这点问，我确实没仔细研究比较过。 -->

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>上面回答部分<strong>来自ChatGPT-3.5</strong>，没有进行正确性的交叉校验。</p>
<p><a target="_blank" rel="noopener" href="https://dingfen.github.io/mpi&openmp/2021/01/23/psrs_sort.html">https://dingfen.github.io/mpi&amp;openmp/2021/01/23/psrs_sort.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-02T16:00:00.000Z" title="8/2/2023, 4:00:00 PM">2023-08-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.553Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Databases/">Databases</a></span><span class="level-item">25 minutes read (About 3681 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/02/Work/Database/Databasebasics/">Database basics</a></p><div class="content"><p>!!! abstract “导言”</p>
<pre><code>数据库相关的常用名词和相关概念基础，商业化公司了解
</code></pre></div><a class="article-more button is-small is-size-7" href="/2023/08/02/Work/Database/Databasebasics/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-02T16:00:00.000Z" title="8/2/2023, 4:00:00 PM">2023-08-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.553Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">17 minutes read (About 2609 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/02/Work/HPC/0-overview/parallelIntroduction/">ParallelIntroduction</a></p><div class="content"><h2 id="并行算法设计"><a href="#并行算法设计" class="headerlink" title="并行算法设计"></a>并行算法设计</h2><p>详细见陈国良教材</p>
<h3 id="战略层"><a href="#战略层" class="headerlink" title="战略层"></a>战略层</h3><h4 id="PCAM"><a href="#PCAM" class="headerlink" title="PCAM"></a>PCAM</h4><p>设计并发程序的四个阶段（PCAM设计方法学）：</p>
<ol>
<li>划分（Partitioning）:分解成小的任务，开拓并发性</li>
<li>通讯（Communication）：确定诸任务间的数据交换，监测划分的合理性；</li>
<li>组合（Agglomeration）：依据任务的局部性，组合成更大的任务；</li>
<li>映射（Mapping）：将每个任务分配到处理器上，提高算法的性能。</li>
</ol>
<h4 id="三种基本方法"><a href="#三种基本方法" class="headerlink" title="三种基本方法"></a>三种基本方法</h4><ol>
<li>串改并：现有串行算法改成并行</li>
<li>从问题开始全新设计并行算法<ol>
<li>前缀和改成线性方程组的问题来并行</li>
<li>有向环的k-着色并行算法<ol>
<li>将coreId作为颜色，进行二进制处理来颜色压缩。压缩到0-5之后再单独消除颜色</li>
</ol>
</li>
</ol>
</li>
<li>借用法：借用已有算法<ol>
<li>最短路径动态规划转换成矩阵乘法</li>
</ol>
</li>
<li>其他基础方法<ol>
<li>平衡树<ol>
<li>求n个最大值，先串行求部分最大，再用树，成本（处理器个数*时间）最低</li>
<li>访问存储次数&#x2F;成本也不是最低的</li>
</ol>
</li>
<li>倍增技术，指针跳跃</li>
<li>分治策略</li>
<li>划分原理（以两个有序数列到归并排序为例）<ol>
<li>均匀划分</li>
<li>对数划分</li>
<li>方根划分</li>
<li>功能划分：基于硬件的Batcher实现，奇偶归并排序，双调序列的实现可以简化网络</li>
</ol>
</li>
<li>流水线技术<ol>
<li>脉动阵列</li>
</ol>
</li>
<li>加速级联策略<ol>
<li>先采用最快的方法将问题规模先减小到一个阈值，然后用其余最优的算法求出原问题的解。</li>
<li>思想其实类似机器学习里的变学习率。例子有平衡树的</li>
</ol>
</li>
<li>破对称技术<ol>
<li>打破数据的对称，便于分类</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="计算机体系结构-量化研究方法分类"><a href="#计算机体系结构-量化研究方法分类" class="headerlink" title="计算机体系结构 - 量化研究方法分类"></a>计算机体系结构 - 量化研究方法分类</h2><p>根据第5 版的分类</p>
<h3 id="指令级并行-ILP"><a href="#指令级并行-ILP" class="headerlink" title="指令级并行 ILP"></a>指令级并行 ILP</h3><p>编译器和硬件级别的，一般不会引起程序员的注意。</p>
<ul>
<li>挑战<ul>
<li>数据相关<ul>
<li>真数据相关</li>
<li>名称相关：两条指令使用了相同的寄存器或者存储器位置，但实际并没有数据流动。寄存器重命名处理</li>
<li>控制相关：主要指指令的执行与分支指令存在先后关系。</li>
</ul>
</li>
</ul>
</li>
<li>解决方案<ul>
<li>流水线与循环展开</li>
<li>分支预测器</li>
<li>动态调度&#x2F;乱序执行(out-of-order execution)<ul>
<li>有多个功能单元和流水化单元。使得流水线能同时执行多个指令</li>
<li>乱序执行, 循序提交： 记分板 -&gt; Tomasulo算法</li>
</ul>
</li>
<li>推测：基于重排缓存区ROB的数据流执行</li>
<li>多发射，超标量</li>
</ul>
</li>
<li>实例(超标量处理器能在一个时钟周期内同时发射和执行多条指令来实现指令级并行性。)<ul>
<li>ARM Cortex-A8 Core 双发射、静态调度(In-order)超标量处理器 <img src="https://pic.shaojiemike.top/img/20230606182819.png"></li>
<li>Intel Core i7 四发射、动态调度(out-of-order execution)超标量处理器<ul>
<li>微指令融合。性能更强，但是能耗比显著降低。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据级并行-DLP"><a href="#数据级并行-DLP" class="headerlink" title="数据级并行 DLP"></a>数据级并行 DLP</h3><ul>
<li>向量张量、SIMD、以及GPU的结构<ul>
<li>区别和MLP 概念的不同：MLP（访存并行）是一种通过同时处理多个内存访问来实现并行性的概念。MLP的目标是提高对存储器系统的效率，减少内存访问的延迟时间。它可以通过预取、缓存和内存操作的重叠等技术来实现。</li>
</ul>
</li>
</ul>
<h3 id="线程级并行-TLP"><a href="#线程级并行-TLP" class="headerlink" title="线程级并行 TLP"></a>线程级并行 TLP</h3><ul>
<li>单机多核系统<ul>
<li>运行一组紧密耦合的线程，协同完成任务</li>
</ul>
</li>
<li>缓存一致性协议</li>
</ul>
<h3 id="超算或者仓库级计算机-WSC-Warehouse-Scale-Computers-请求级并行-RLP"><a href="#超算或者仓库级计算机-WSC-Warehouse-Scale-Computers-请求级并行-RLP" class="headerlink" title="超算或者仓库级计算机(WSC Warehouse-Scale Computers) 请求级并行 RLP"></a>超算或者仓库级计算机(WSC Warehouse-Scale Computers) 请求级并行 RLP</h3><ul>
<li>请求级并行：由一个或者多个用户发起的多个相对独立的进程</li>
<li>环境： 云计算。</li>
<li>关注成本与收益</li>
</ul>
<h2 id="并行分类"><a href="#并行分类" class="headerlink" title="并行分类"></a>并行分类</h2><!-- ![](https://pic.shaojiemike.top/PicGo20210714225801.png) -->
<p><img src="https://pic.shaojiemike.top/img/PicGo20210714225801.png"></p>
<h3 id="微处理器器中的并行"><a href="#微处理器器中的并行" class="headerlink" title="微处理器器中的并行"></a>微处理器器中的并行</h3><p>ILP 指令级并行</p>
<p>TLP 线程级并行</p>
<p>SMT 同步多线程（Simultaneous Multi-Threading，SMT）是一种在一个CPU 的时钟周期内能够执行来自多个线程的指令的硬件多线程技术。</p>
<p>CMP 单芯片多处理器（Chip multiprocessors）</p>
<h3 id="常用的四种并行模式-这样分感觉不是很对"><a href="#常用的四种并行模式-这样分感觉不是很对" class="headerlink" title="常用的四种并行模式(这样分感觉不是很对)"></a>常用的四种并行模式(这样分感觉不是很对)</h3><ol>
<li>共享内存模式（The shared memory model）</li>
<li>多线程模式（The multithread model）</li>
<li>分布式内存&#x2F;消息传递模式（The distributed memory&#x2F;message passing model）</li>
<li>数据并行模式（The data parallel model）</li>
</ol>
<h2 id="实际的经验"><a href="#实际的经验" class="headerlink" title="实际的经验"></a>实际的经验</h2><ol>
<li>IPCC Preliminary SLIC Optimization 4: EnforceLabelConnectivity</li>
</ol>
<h2 id="并行常见名词"><a href="#并行常见名词" class="headerlink" title="并行常见名词"></a>并行常见名词</h2><p>SM : shared Memory</p>
<p>LM : Local Memory</p>
<p>DM ：distribute memory</p>
<h2 id="并行计算模型"><a href="#并行计算模型" class="headerlink" title="并行计算模型"></a>并行计算模型</h2><p><img src="https://pic.shaojiemike.top/img/20220317105950.png"></p>
<h3 id="并行计算访存模型（强调时间）"><a href="#并行计算访存模型（强调时间）" class="headerlink" title="并行计算访存模型（强调时间）"></a>并行计算访存模型（强调时间）</h3><p>均匀访存模型（UMA）、非均匀访存模型（NUMA）、全高速缓存访存模型（COMA）、一致性高速缓存非均匀存储访问模型（CC-NUMA）和非远程存储访问模型（NORMA）。</p>
<p>UMA（Uniform Memory Access）均匀存储訪问：物理存储器被全部处理器均匀共享，全部处理器对全部SM訪存时间相同，每台处理器可带有快速私有缓存，外围设备共享。</p>
<p>NUMA非均匀存储訪问：共享的SM是由物理分布式的LM逻辑构成，处理器訪存时间不一样，訪问LM或CSM（群内共享存储器）内存储器比訪问GSM（群间共享存储器）快</p>
<p>COMA（Cache-Only MA）全快速缓存存储訪问：NUMA的特例、全快速缓存实现</p>
<p>CC-NUMA（Coherent-Cache NUMA）快速缓存一致性NUMA：NUMA＋快速缓存一致性协议。实际是分布共享的DSM机器</p>
<p>NORMA（No-Remote MA）非远程存储訪问：无SM，全部LM私有。通过消息传递通信</p>
<h3 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h3><p>NUMA : NUMA (non-uniform memory access) is a method of configuring a cluster of microprocessor in a <strong>multiprocessing</strong> system so that they can <strong>share memory locally</strong>, improving performance and the ability of the system to be expanded. NUMA is used in a <strong>symmetric multiprocessing</strong> ( SMP ) system.</p>
<p>在NUMA下，處理器存取它自己的本地記憶體的速度比非本地記憶體快一些。 非統一記憶體存取架構的特點是：被共享的記憶體物理上是分散式的，所有這些記憶體的集合就是全域位址空間。</p>
<h3 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h3><p>Remote Direct Memory Access (<strong>RDMA</strong>) is an extension of the Direct Memory Access (<strong>DMA</strong>) technology, which is the ability to access host memory directly without CPU intervention. RDMA allows for accessing memory data from one host to another.</p>
<p>远程直接内存访问（英语：Remote Direct Memory Access，RDMA）是一种从一台计算机的内存到另一台计算机的内存的直接内存访问，而不涉及任何一台计算机的操作系统。这允许高吞吐量、低延迟联网，这在大规模并行计算机集群中特别有用。</p>
<p>重点是zero-copy， 不再需要机器缓存，然后拷贝传递信息。 RDMA的实现还是需要专门的RDMA-based network adapters</p>
<h3 id="relationship-between-RDMA-and-NUMA"><a href="#relationship-between-RDMA-and-NUMA" class="headerlink" title="relationship between RDMA and NUMA"></a>relationship between RDMA and NUMA</h3><p>Most high performance computing clusters are nowadays composed of large multicore machines that expose Non-Uniform Memory Access (NUMA), and they are interconnected using modern communication paradigms, such as Remote Direct Memory Access (RDMA).</p>
<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p><img src="https://pic.shaojiemike.top/img/20220308103947.png"></p>
<li>SISD：单指令流单数据流计算机（冯诺依曼机）</li>
<li>SIMD：单指令流多数据流计算机</li>
<li>MISD：多指令流单数据流计算机， 实际不存在</li>
<li>MIMD：多指令流多数据流计算机</li>

<h3 id="SIMD-SM"><a href="#SIMD-SM" class="headerlink" title="SIMD-SM"></a>SIMD-SM</h3><p>PRAM（Parallel Random Access Machine）模型是单指令流多数据流（SIMD）并行机中的一种具有共享存储的模型。</p>
<p>它假设有对其容量大小没有限制的一个共享存储器，并且有多个功能相同的处理器，在任意时刻处理器可以访问共享存储单元。根据是否可以同时读写，它又分为以下三类：<strong>PRAM-EREW，PRAM-CREW，PRAM-CRCW</strong>（其中C代表Concurrent，意为允许并发操作，E-代表Exclusive，意味排斥并发操作）。在PRAM中有一个同步时钟，所有的操作都是同步进行的。</p>
<p>具有局部存储器的PRAM模型称作<strong>LPRAM</strong>模型，具有异步时钟的PRAM模型称作<strong>APRAM</strong>模型。</p>
<p>在《并行算法的设计和分析》的第二十章-并行计算理论有额外的定义：</p>
<ul>
<li>允许任意处理器自由读写的 SIMD-SM。简记为 APRAM-CRCW</li>
<li>只允许所有处理器并发写同一数的SIMD-SM。简记为CPRAM-CRCW</li>
<li>只允许最小号码处理器优先写的SIMD-SM。称作优先PRAM-CRCW。简记为PPRAM-CRCW</li>
<li>一个具有p个处理器的优先PRAM-CRCW模型。称作p-处理器的PPRAM-CRCW。</li>
</ul>
<h3 id="几种MIMD"><a href="#几种MIMD" class="headerlink" title="几种MIMD"></a>几种MIMD</h3><li>PVP并行向量处理机：多VP（向量处理器）通过交叉开关和多个SM（共享内存）相连</li>
<li>SMP对称多处理机：多P/C（商品微处理器）通过交叉开关/总线和多个SM（共享内存）相连</li>
<li>MPP大规模并行处理机：处理节点有商品微处理器+LM（分布式本地内存）。节点间通过高带宽低延迟定制网络互联，异步MIMD，多个进程有自己的地址空间，通过消息传递机制通信</li>
<li>COW工作站机群：节点是完整操作系统的工作站，且有磁盘</li>
<li>DSM分布共享存储处理机：快速缓存文件夹DIR确保缓存一致性。将物理分布式LM组成逻辑共享SM从而提供统一地址的编程空间</li>

<p><img src="https://pic.shaojiemike.top/img/20220312155427.png"><br><img src="https://pic.shaojiemike.top/img/20220312150632.png"><br><img src="https://pic.shaojiemike.top/img/20220312150725.png"><br><img src="https://pic.shaojiemike.top/img/20220312150745.png"><br><img src="https://pic.shaojiemike.top/img/20220312150801.png"><br><img src="https://pic.shaojiemike.top/img/20220312150916.png"></p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>无</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-08-02T16:00:00.000Z" title="8/2/2023, 4:00:00 PM">2023-08-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-12-15T00:00:02.569Z" title="12/15/2023, 12:00:02 AM">2023-12-15</time></span><span class="level-item"><a class="link-muted" href="/categories/network/">network</a></span><span class="level-item">an hour read (About 7531 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/02/Work/network/0-basic/networkServices/">Network Services</a></p><div class="content"><h2 id="计算机网络基本概念"><a href="#计算机网络基本概念" class="headerlink" title="计算机网络基本概念"></a>计算机网络基本概念</h2><p>20世纪50年代末，正值美苏冷战时期的美国军方设计了军用网络”阿帕网ARPANET”, 当时的还只支持同构设备间的连接，TCP&#x2F;IP的提出标志着万物互联的到来。</p>
<h3 id="多层网络模型"><a href="#多层网络模型" class="headerlink" title="多层网络模型"></a>多层网络模型</h3><p>计算机网络体系结构分为3种：OSI体系结构（七层），TCP&#x2F;IP体系结构（四层），五层体系结构。</p>
<ul>
<li><strong>OSI模型</strong>(开放式系统互联模型Open System Interconnection Model)<ul>
<li>也称开放系统互连参考模型，简称OSI&#x2F;RM(Open System Internetwork Reference Model)</li>
<li>概念清楚，理论也比较完整，但是它既<strong>复杂又不实用</strong>。</li>
<li>由国际标准化组织(ISO)于1985年提出，并试图成为计算机在世界范围内互连为网络的标准框架，它具有七层网络结构。</li>
</ul>
</li>
<li><strong>TCP&#x2F;IP模型</strong><ul>
<li>互联网协议套件（Internet Protocol Suite，IPS）是多个网络传输协议的集合，它为网际网络的基础通信提供架构支撑。</li>
<li>由于该协议族中最核心的两个协议分别为 TCP（传输控制协议）和 IP（网际协议），因此它也被称为 TCP&#x2F;IP 协议族（TCP&#x2F;IP Protocol Suite 或 TCP&#x2F;IP Protocols），简称 TCP&#x2F;IP。</li>
<li>1974年，卡恩和瑟夫(Internet 之父)发表的《关于分组交换的网络通信协议》的论文正式提出TCP&#x2F;IP。</li>
</ul>
</li>
<li><strong>五层体系结构</strong>:为了方便学习，折中OSI体系结构和TCP&#x2F;IP体系结构，综合二者的优点，这样既简洁，又能将概念讲清楚。</li>
</ul>
<p><img src="https://pic.shaojiemike.top/img/20230326063613.png"><br><img src="https://pic.shaojiemike.top/img/20230326101923.png"></p>
<p>五层网络模型各层功能：</p>
<ul>
<li><strong>应用层</strong>：应用层是网络协议的最高层，主要任务通过进程间的交互完成特定网络应用。应用层协议定义的是应用程序（进程）间通信和交互的规则。<ul>
<li>对于不同的网络应用需要有不同的应用层协议，在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，等等。</li>
<li>应用层交互的数据单元称为<code>报文</code>。</li>
</ul>
</li>
<li><strong>运输层</strong>：有时也译为传输层，它负责为两台主机中的进程提供通信服务，通过<code>端口号</code>进行区分。该层主要有以下两种协议：<ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，<ul>
<li>为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制</li>
<li>数据传输的基本单位是<code>报文段（segment）</code>；</li>
</ul>
</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，<ul>
<li>数据传输的基本单位是<code>用户数据报</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络层</strong>：网络层负责为分组网络中的不同主机提供通信服务，并通过<strong>选择合适的路由</strong>将数据传递到目标主机。<ul>
<li>把运输层产生的报文段或用户数据封装成<code>分组</code>或<code>包</code>进行传送。</li>
<li>网络层IP提供的是一种不可靠的服务。只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。</li>
<li>IP层有一个数据报要传，而且数据的长度比链路层的<code>最大传输单元MTU</code>还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。<ul>
<li>减小MTU会降低通讯延迟(通讯一次的数据变少)，但是每帧里的有效数据占比会变少。</li>
</ul>
</li>
<li>在TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组也叫<strong>IP数据报</strong>。</li>
</ul>
</li>
<li><strong>数据链路层</strong>：数据链路层通常简称为链路层。数据链路层在两个相邻节点传输数据时，<ul>
<li>将网络层交下来的IP数据报组装成<code>帧</code>，在两个相邻节点之间的链路上传送帧。<ul>
<li>以太网<code>数据帧</code>的物理特性是其长度必须在46～1500字节之间</li>
</ul>
</li>
<li>数据链路层将待发送的数据分为多组，并采用<strong>循环冗余校验</strong>（CRC，Cyclic Redundancy Check）技术为每组数据生成冗余校验码，之后将每组数据和其校验码共同构成一帧后再发送出去。</li>
<li>数据链路层分为上层LLC（逻辑链路控制），和下层的MAC（介质访问控制）</li>
</ul>
</li>
<li><strong>物理层</strong>：保数据可以在各种物理媒介(缆线，微波)上进行传输，为数据的传输提供可靠的环境。<ul>
<li>考虑信号传输(物理线材，线材接口，电压，频率)以及信道复用，和全双工信道实现等问题。</li>
<li>物理层设备：网卡、光纤、CAT-5网线、RJ-45网线水晶接头、串口、并口</li>
</ul>
</li>
</ul>
<h3 id="网络报文构建并传输-实例分析"><a href="#网络报文构建并传输-实例分析" class="headerlink" title="网络报文构建并传输 实例分析"></a>网络报文构建并传输 实例分析</h3><p>一个HTTP网络请求，如何被多层协议包装，变成网络链路上的二进制，然后又被解析。</p>
<p><img src="https://pic.shaojiemike.top/img/20230328102947.png"></p>
<ul>
<li>交换机解析链路层的MAC地址(局域网通过MAC地址通讯)，查看插在交换机端口上的线路的MAC地址并转发</li>
<li>路由器由于需要根据IP来路由，所以会解析到网络层</li>
<li>GFW(长城防火墙)不仅会查看网络层的ip是否在黑名单，还会对未加密的应用层内容判断(是不是对黑名单网址的DNS或者http请求)，对加密的内容还会对目标ip进行重放攻击来判断是不是VPN服务器。只有伪装成443端口的https请求才能逃过检测(翻墙)。但是此伪装会降低性能。</li>
</ul>
<p><img src="https://pic.shaojiemike.top/img/20230328103942.png"></p>
<p>在Linux系统中，网络请求除了DNS解析、NAT和匹配路由规则之外，还会经过其他处理。例如，当一个网络请求到达时，它会被传递给网络协议栈，然后经过以下处理：</p>
<ul>
<li>网络请求到达物理网络适配器，触发中断并通过DMA传送到位于Linux内核内存中的rx_ring。</li>
<li>网卡发出中断，通知CPU有个网络请求需要处理。</li>
<li>网络请求被传递给网络协议栈，经过各个层的处理（链路层、网络层、传输层和应用层）。</li>
<li>网络请求被传递给应用程序进行处理。</li>
</ul>
<h3 id="网络请求实例"><a href="#网络请求实例" class="headerlink" title="网络请求实例"></a>网络请求实例</h3><p>网络请求通常会经过多个部件，包括浏览器、DNS服务器、代理服务器、负载均衡器、Web服务器等等。下面是一些可能的步骤：</p>
<ul>
<li>浏览器解析URL，获取主机名和端口号。</li>
<li>浏览器向DNS服务器发送请求，获取主机名对应的IP地址。</li>
<li>浏览器向Web服务器发送TCP连接请求，进行三次握手。</li>
<li>Web服务器接受TCP连接请求，进行三次握手。</li>
<li>浏览器向Web服务器发送HTTP请求报文。</li>
<li>Web服务器接受HTTP请求报文，处理请求并返回HTTP响应报文。</li>
<li>浏览器接受HTTP响应报文，解析响应并显示页面。</li>
</ul>
<h3 id="网络套接字"><a href="#网络套接字" class="headerlink" title="网络套接字"></a>网络套接字</h3><p>Internet socket &#x2F; Network socket</p>
<p>套接字地址是传输协议、IP地址和端口号的三元组。</p>
<h2 id="各种各层协议关系"><a href="#各种各层协议关系" class="headerlink" title="各种各层协议关系"></a>各种各层协议关系</h2><h3 id="TCP-IP网络通讯协议关系图"><a href="#TCP-IP网络通讯协议关系图" class="headerlink" title="TCP&#x2F;IP网络通讯协议关系图"></a>TCP&#x2F;IP网络通讯协议关系图</h3><ul>
<li>TCP&#x2F;IP 实际包括几十个 Internet 协议，但只有少数是核心协议，其中有两个通常被认为是最重要的，就是我们上面提到的 TCP 和 IP。</li>
<li>IP 属于 OSI 网络层（第三层），在互联网网络中提供寻址、数据报路由等功能；</li>
<li>TCP 属于 OSI 传输层（第四层），负责设备上软件进程之间的连接建立和管理以及可靠的数据传输。</li>
<li>IP协议为每一台联网的设备分配一个地址，TCP则负责传输问题。</li>
</ul>
<p><img src="https://pic.shaojiemike.top/img/20230326055813.png"></p>
<h3 id="网络通讯协议关系图"><a href="#网络通讯协议关系图" class="headerlink" title="网络通讯协议关系图"></a>网络通讯协议关系图</h3><p><img src="https://pic.shaojiemike.top/img/20230326060601.png"></p>
<ul>
<li>中英文对照：<ul>
<li>每一个协议缩写用英文，全称用中文，这样非常容易理解。简洁明了，如TCP协议，协议图上标注的是TCP 传输控制协议。</li>
</ul>
</li>
<li>同时遵循OSI和TCP&#x2F;IP：<ul>
<li>左边是TCP&#x2F;IP标准，右边是OSI标准，便于使用者理解协议在两种层次标准中的承载关系。</li>
</ul>
</li>
<li>内容全面：<ul>
<li>包括八个协议簇（TCP&#x2F;IP、ISO、MICROSOFT、AppleTalk、VOIP、Novell、IBM、SUN&#x2F;HP&#x2F;UNIX）和三个大的协议分类（LAN、MAN、WAN）。</li>
</ul>
</li>
<li>合理的协议分组：<ul>
<li>每个协议簇都是按照应用类型进行了分组调整，让读者更容易理解</li>
</ul>
</li>
<li>清晰的协议关系：<ul>
<li>每个协议都可以通过流程线找到其上层协议或下层协议，非常便于了解协议之间的关系情况。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cisco.com/web/offer/emea/7193/docs/Agilent_Netzwerk.pdf">英文版矢量图</a></li>
</ul>
<h2 id="物理层-问题"><a href="#物理层-问题" class="headerlink" title="物理层 问题"></a>物理层 问题</h2><ul>
<li>IEEE802.11 WLAN协议是物理层协议吗？<ul>
<li>IEEE802.11 WLAN协议是无线局域网（WLAN）的介质访问控制协议及物理层技术规范1。因此，IEEE802.11 WLAN协议<strong>不仅是物理层协议</strong>，还是介质访问控制协议。</li>
</ul>
</li>
<li>以太网(Ethernet)也是OSI模型第一二层<ul>
<li>在物理层上，以太网采用 RJ45 接口和双铰线，光纤，电磁波等方式来传递信号。</li>
<li>在数据链路层上，每个通信节点（主机的网络接口）都有 48 位(bit)全局唯一的 MAC 地址。通信数据流被切分并打包成帧(Frame)来发送，每帧都包含来源节点和目的节点的 MAC 地址。</li>
<li>链路层以太网封装，后续的IEEE 802.3需要兼容老版本RFC894<img src="https://pic.shaojiemike.top/img/20230326091358.png"></li>
<li><strong>最大传输单元MTU</strong>：以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU ,最大传输单元。不同类型的网络大 多数都有一个上限。</li>
<li>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。</li>
</ul>
</li>
</ul>
<h2 id="交换机局域网"><a href="#交换机局域网" class="headerlink" title="交换机局域网"></a>交换机局域网</h2><ul>
<li>由于交换机使用链路层地址（MAC地址）来转发数据，因此交换机只能工作在局域网中，不能跨越路由器转发数据。</li>
<li>自然会想到为什么需要链路层地址，只有网络层地址来标识设备不行吗？</li>
<li>目的mac地址如何获得？google的mac地址？</li>
</ul>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul>
<li>每个网络适配器(物理网卡，网络接口)有链路层地址(手机也有)。与IP地址不同，这个地址是IEEE分配的全球唯一的(除非软件层次修改)。</li>
<li>交换机却不需要MAC地址，因为交换机不需要发送数据，只需要转发数据，转发数据的时候，只需要知道目的地址就可以了。</li>
<li>信包的目的MAC地址可以填写广播MAC地址，来让局域网设备都接受到。</li>
</ul>
<h3 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h3><ul>
<li>向目的IP(局域网或者外网)发送信包，其对应的目的MAC地址如何获得？</li>
<li>每台机器在自己的内存里维护 ARP 表，存储了 IP 地址和 MAC 地址的对应关系(寿命值TTL)。<ul>
<li>当需要发送数据时，先查看 ARP 表，如果有对应的 MAC 地址，就直接发送数据，</li>
<li>否则就先发送 ARP 请求，将它广播到局域网，然后等待目的机器的 ARP 响应，最后再发送数据。</li>
</ul>
</li>
</ul>
<h2 id="数据链路层-协议"><a href="#数据链路层-协议" class="headerlink" title="数据链路层 协议"></a>数据链路层 协议</h2><h3 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h3><p>点到点协议（PPP，Point to Point Protocol）是目前使用最为广泛的数据链路层协议，主要用于建立点对点的连接来传输数据单元。 </p>
<p>注意与BitTorrent协议使用的用户群对用户群（peer-to-peer, 或简写为 P2P) 传输协议不同，后者基于HTTP协议，属于TCP&#x2F;IP应用层。</p>
<h3 id="地址解析协议-ARP-Address-Resolution-Protocol"><a href="#地址解析协议-ARP-Address-Resolution-Protocol" class="headerlink" title="地址解析协议(ARP, Address Resolution Protocol)"></a>地址解析协议(ARP, Address Resolution Protocol)</h3><p>ARP 用于在网络层地址（IPv4 地址）和链路层地址（以太网中就是 MAC 地址）间进行翻译。它工作在二层和三层之间，如果一定要安排到七层之中的话，ARP 只能算二层协议。</p>
<ul>
<li>以太网中两个节点通信需要知道对方的 MAC 地址。为使用 IP 协议，每个节点会缓存一个 ARP 表，记录已知的 MAC 地址和 IP 地址的对应关系。</li>
<li>与内网IP通信时，如果缓存表中无法找到对应的 MAC 地址，节点就会发出一条 ARP 请求，广播到网络中所有的节点。该 IP 对应的节点会进行回复，原节点根据回复提供的 MAC 地址继续通信，同时将信息记入缓存表。</li>
<li>除了这样的请求应答方式以外，每个节点也可以主动发送广播，声明自己的 IP 和 MAC 地址，以更新其它节点的缓存表。</li>
</ul>
<p>ARP 不对各个节点进行身份验证，因此可能产生 ARP 欺骗问题，即某节点假装自己是其它节点，进行信息窃取或欺骗；或实施拒绝服务攻击。对应的解决方案可以是静态配置 MAC&#x2F;IP 对应关系，或者缩小网络的范围（如划分成子网）等。</p>
<p>IPv6 中，邻居发现协议（NDP, Neighbor Discovery Protocol)取代了 ARP。NDP 中区分了路由器和普通节点。它不仅能在 IP 地址和链路层地址间进行翻译，还可以为节点配置网络参数如IP地址，网络ID，DNS 等(SLAAC, Stateless address autoconfiguration)。</p>
<h2 id="其余层协议"><a href="#其余层协议" class="headerlink" title="其余层协议"></a>其余层协议</h2><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45110873">https://zhuanlan.zhihu.com/p/45110873</a></p>
<h3 id="SOCKS协议"><a href="#SOCKS协议" class="headerlink" title="SOCKS协议"></a>SOCKS协议</h3><p>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是”<code>SOCKet Secure</code>“的缩写。</p>
<p>当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。</p>
<p>最新协议是SOCKS5，与前一版本相比，增加支持<strong>UDP</strong>、验证，以及IPv6。</p>
<p>根据OSI模型，SOCKS是<strong>会话层</strong>的协议，位于<strong>表示层与传输层</strong>之间。</p>
<p>SOCKS协议不提供加密</p>
<h2 id="各种端口"><a href="#各种端口" class="headerlink" title="各种端口"></a>各种端口</h2><ol>
<li>HTTP协议<ol>
<li>代理服务器常用端口号：80&#x2F;8080&#x2F;3128&#x2F;8081&#x2F;9080</li>
</ol>
</li>
<li>HTTPS（securely transferring web pages）服务器，<ol>
<li>默认的端口号为443&#x2F;tcp 443&#x2F;udp；</li>
</ol>
</li>
<li>SOCKS代理协议<ol>
<li>服务器常用端口号：1080</li>
</ol>
</li>
<li>FTP（文件传输）协议代理服务器常用端口号：21</li>
<li>Telnet（远程登录）协议代理服务器常用端口：23</li>
<li>TFTP（Trivial File Transfer Protocol），默认的端口号为69&#x2F;udp；</li>
<li>SSH（安全登录）、SCP（文件传输）、端口重定向，默认的端口号为22&#x2F;tcp；</li>
</ol>
<h2 id="各种概念"><a href="#各种概念" class="headerlink" title="各种概念"></a>各种概念</h2><h3 id="局域网（Local-Area-Network）"><a href="#局域网（Local-Area-Network）" class="headerlink" title="局域网（Local Area Network）"></a>局域网（Local Area Network）</h3><p>局域网（LAN）的结构主要有三种类型：</p>
<ul>
<li>以太网（Ethernet）、<ul>
<li><strong>目前最广泛的局域网技术</strong>，家用局域网使用。</li>
<li>一种基于总线的网络，采用CSMA&#x2F;CD访问控制协议。</li>
<li>以太网的运行速率有10Mbps,100Mbps,1Gbps,10Gbps</li>
</ul>
</li>
<li>令牌环（Token Ring）、<ul>
<li>IBM公司在20世纪70年代提出的一种局域网技术，它采用令牌传递的方式来控制网络中的数据传输。</li>
</ul>
</li>
<li>令牌总线(Token Bus)<ul>
<li>一种基于总线的局域网技术，它采用令牌传递的方式来控制网络中的数据传输。</li>
</ul>
</li>
<li>以及作为这三种网的骨干网的<em>光纤分布数据接口（FDDI）</em>。<ul>
<li>光纤的局域网技术，它采用双环结构，支持高速数据传输。</li>
</ul>
</li>
</ul>
<p>它们所遵循的都是IEEE（美国电子电气工程师协会）制定的以802开头的标准,目前共有11个与<strong>局域网有关</strong>的标准,它们分别是：</p>
<ul>
<li>IEEE 802.1── 通用网络概念及网桥等</li>
<li>IEEE 802.2── 逻辑链路控制等（LLC，约束了后三者）</li>
<li>IEEE 802.3──CSMA&#x2F;CD访问方法及物理层规定(以太网开始基础)</li>
<li>IEEE 802.4──ARCnet总线结构及访问方法,物理层规定(针对令牌总线网络)</li>
<li>IEEE 802.5──Token Ring访问方法及物理层规定等（针对令牌环网络）</li>
<li>IEEE 802.6── 城域网的访问方法及物理层规定</li>
<li>IEEE 802.7── 宽带局域网</li>
<li>IEEE 802.8── 光纤局域网(FDDI)</li>
<li>IEEE 802.9── ISDN局域网</li>
<li>IEEE 802.10── 网络的安全</li>
<li>IEEE 802.11── 无线局域网WLAN</li>
</ul>
<h3 id="广域网-Wide-Area-Network"><a href="#广域网-Wide-Area-Network" class="headerlink" title="广域网(Wide Area Network)"></a>广域网(Wide Area Network)</h3><p>可以看成是很多个局域网通过路由器等相互连接起来。</p>
<h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><p>internet这个词第一个字母是否大写决定了它具有不同的含义。</p>
<ul>
<li>internet意思是用一个共同的协议族把多个网络连接在一起。</li>
<li>而Internet指的是世界范围内通过TCP&#x2F;IP互相通信的所有主机集合（超过100万台）。</li>
<li>Internet是一个internet，但internet不等于Internet。</li>
<li>由两个网络组成的互联网internet——一个以太网和一个令牌环网</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h3 id="SSL检测"><a href="#SSL检测" class="headerlink" title="SSL检测"></a>SSL检测</h3><h3 id="服务器重定向"><a href="#服务器重定向" class="headerlink" title="服务器重定向"></a>服务器重定向</h3><h2 id="apt-get-install-proxy"><a href="#apt-get-install-proxy" class="headerlink" title="apt-get install proxy"></a>apt-get install proxy</h2><p>check the file <code>/etc/apt/apt.conf</code></p>
<p>The contents were,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::proxy &quot;http://&lt;proxy&gt;:&lt;port&gt;/&quot;;</span><br><span class="line">Acquire::ftp::proxy &quot;ftp://&lt;proxy&gt;:&lt;port&gt;/&quot;;</span><br><span class="line">Acquire::https::proxy &quot;https://&lt;proxy&gt;:&lt;port&gt;/&quot;;</span><br><span class="line"></span><br><span class="line">Acquire::http::proxy &quot;http://127.0.0.1:7233/&quot;;</span><br><span class="line">Acquire::ftp::proxy &quot;ftp://127.0.0.1:7233/&quot;;</span><br><span class="line">Acquire::https::proxy &quot;https://127.0.0.1:7233/&quot;;</span><br></pre></td></tr></table></figure>

<p>This was the reason why you could reach proxy but couldn’t get past it, since there is no username password information. So just put that info into it..</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::proxy &quot;http://&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt;/&quot;;</span><br><span class="line">Acquire::ftp::proxy &quot;ftp://&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt;/&quot;;</span><br><span class="line">Acquire::https::proxy &quot;https://&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt;/&quot;;</span><br></pre></td></tr></table></figure>

<p>save the file and you are done…</p>
<p>BROTIP: More better add these lines in another file, <code>/etc/apt/apt.conf.d/80proxy</code>. This will ensure that after a version upgrade changes won’t be lost.</p>
<p>如果出现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Err:3 https://swupdate.openvpn.net/community/openvpn3/repos focal Release</span><br><span class="line">  Could not handshake: The TLS connection was non-properly terminated. [IP: 127.0.0.1 7233]</span><br></pre></td></tr></table></figure>
<p>直接将<code>Acquire::https::proxy &quot;https://&lt;proxy&gt;:&lt;port&gt;/&quot;;</code>改成<code>Acquire::https::proxy &quot;http://&lt;proxy&gt;:&lt;port&gt;/&quot;;</code></p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="局域网共享科学上网"><a href="#局域网共享科学上网" class="headerlink" title="局域网共享科学上网"></a>局域网共享科学上网</h3><ul>
<li>代理共享模式：clash允许局域网连接，其他设备的代理软件设置其ip端口即可</li>
<li>网关共享模式：将clash机器设置为局域网网关</li>
<li>路由共享模式：在clash机器上又开辟一个局域网B，B下的网络都会被代理。</li>
</ul>
<p>想法：手机同时只能开启一个VPN，在开启wg时，通过将网关设置为有clash的网关即可实现上网。（一个网络有两个网关）。不行，wg相当于流量从wg server出，所以没有网关的说法</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li>系统代理：将数据交给本地http&#x2F;socks服务</li>
<li>TUN&#x2F;TAP：使用虚拟网卡接管全局流量，从网络层接管所有数据包<ul>
<li>无法封装网络层数据包，无法代理ping, fake-ip还会返回假ip</li>
<li>TUN与TAP是操作系统内核中的虚拟网络设备：<ul>
<li>TAP等同于一个以太网设备，它操作第二层数据包如以太网数据帧。</li>
<li>TUN模拟了网络层设备，操作第三层数据包比如IP数据包。</li>
</ul>
</li>
</ul>
</li>
<li>真VPN：封装网络层数据包<ul>
<li>可以代理网络层，可以代理ping</li>
</ul>
</li>
</ul>
<h3 id="DNS分流"><a href="#DNS分流" class="headerlink" title="DNS分流"></a>DNS分流</h3><h3 id="UDP穿透"><a href="#UDP穿透" class="headerlink" title="UDP穿透"></a>UDP穿透</h3><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>GNU Wget（常简称为Wget）是一个在网络上进行下载的简单而强大的自由软件，其本身也是GNU计划的一部分。它的名字是“World Wide Web”和“Get”的结合，同时也隐含了软件的主要功能。目前它支持通过 <code>HTTP、HTTPS，</code>以及 <code>FTP</code>这三个最常见的TCP&#x2F;IP协议协议下载。</p>
<h3 id="缺陷与改进wget2"><a href="#缺陷与改进wget2" class="headerlink" title="缺陷与改进wget2"></a>缺陷与改进wget2</h3><p>wget相对于curl垃圾太多。</p>
<p>支持的协议较少，特别是cURL相比。流行的流媒体协议mms和rtsp没有得到支持，还有广泛使用各种的P2P协议也没有涉及。</p>
<p>支持协议过老。目前HTTP还是使用1.0版本，而HTML中通过JavaScript和CSS引用的文件不能下载。</p>
<p>灵活性不强，扩展性不高。</p>
<p>GNU Wget2通过多线程、正确支持HTTP2连接、处理HTTP压缩特性、处理并行连接、考虑到If-Modified-Since HTTP标头和其他特性，提供了更快的性能。Wget2的下载速度比Wget1.x快得多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wget2</span><br></pre></td></tr></table></figure>

<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p>
<h3 id="支持的网络协议"><a href="#支持的网络协议" class="headerlink" title="支持的网络协议"></a>支持的网络协议</h3><p><img src="https://pic.shaojiemike.top/img/20220302152918.png"></p>
<h3 id="常见功能"><a href="#常见功能" class="headerlink" title="常见功能"></a>常见功能</h3><p>通过httpAPI&#x2F;cookie登陆网站</p>
<p>下载，上传。很明显是通过http实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 # -x 指定代理主机和端口</span><br><span class="line">2 curl -v -x https://10.20.80.158:22 http://192.168.26.219/a.php</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gufenchen/article/details/103983440?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164620543916780357252807%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164620543916780357252807&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-103983440.pc_search_result_cache&utm_term=curl&spm=1018.2226.3001.4187">https://blog.csdn.net/gufenchen/article/details/103983440?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164620543916780357252807%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164620543916780357252807&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-103983440.pc_search_result_cache&amp;utm_term=curl&amp;spm=1018.2226.3001.4187</a></p>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>ping用来检查网络是否通畅或者网络连接速度的命令 ，是TCP&#x2F;IP协议的一部分。</p>
<p><img src="https://pic.shaojiemike.top/img/20220302155451.png"></p>
<p>很多人可能想当然的认为Ping命令使用的ICMP协议应该是基于传输层的TCP或UDP协议的吧。</p>
<p>正如上图所示，ICMP协议既不是基于TCP，也不是基于UDP，而是直接基于网络层的IP协议，在整个网络协议栈中属于相当底层的协议了。这也从侧面证明了它的重要性，因为根据ICMP的RFC手册规定：ICMP协议是任何支持IP协议的系统必须实现的，没有余地。而IP协议是整个互联网的基石，ICMP协议虽简单，但重要性不言而喻。</p>
<p>ping命令本身处于应用层，相当于一个应用程序，它直接使用网络层的<strong>ICMP协议</strong>。**Ping(Packet Internet Groper)**，因特网包探索器。</p>
<p>原理：利用网络上机器IP地址的唯一性，给目标IP地址发送一个ICMP数据包，再要求对方返回一个同样大小的ICMP数据包来确定两台网络机器是否连接相通，时延是多少。</p>
<p>ping指的是端对端连通，通常用来作为可用性的检查，但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。</p>
<h3 id="ping选项详解"><a href="#ping选项详解" class="headerlink" title="ping选项详解"></a>ping选项详解</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yXMKZv-VdMyyeQLDiQfSAQ">https://mp.weixin.qq.com/s/yXMKZv-VdMyyeQLDiQfSAQ</a></p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>Ping程序使用的是ICMP协议，ICMP不像http，FTP应用层有传输层的端口号，（它们使用TCP的端口号80和20&#x2F;21）。</p>
<p>ICMP使用IP协议的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。</p>
<h3 id="不能代理ping"><a href="#不能代理ping" class="headerlink" title="不能代理ping"></a>不能代理ping</h3><p>In general you can’t. ping needs a direct network connection on the IP level to do its work. A proxy works on a higher layer of the TCP&#x2F;IP network model, where there is no direct access to the IP protocol.</p>
<p>You would need to somehow circumvent the proxy (change firewall settings, use a VPN, …). Whether this is possible (and allowed) depends on your network configuration, but it’s probably not possible.</p>
<p>As a workaround, there are many web-based ping services available (search for “web-based ping”). These will work.</p>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>telnet是用来探测指定ip是否开放指定端口。</p>
<p>telnet协议是TCP&#x2F;IP协议族的其中之一，是Internet远端登录服务的标准协议和主要方式，常用于网页服务器的远端控制，可供使用者在本地主机执行远端主机上的工作。使用者首先在电脑执行telnet程序，连线至目的地服务器，然后输入帐号和密码以验证身份。使用者可以在本地主机输入命令，然后让已连接的远端主机执行，就像直接在对方的控制台上输入一样。传统telnet会话所传输的资料并未加密，帐号和密码等敏感资料容易会被窃听，因此很多服务器都会封锁telnet服务，改用更安全的ssh。</p>
<p>一般的telnet指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet www.baidu.com 80</span><br></pre></td></tr></table></figure>

<p>简单的说，ping命令是用来检测网络是否畅通的，而telnet命令则用来远程登陆。 但telnet不通并不一定代表网络不通。ping是基于ICMP协议的命令，就是你发出去一个数据包，对方收到后返给你一个！就好比声纳。这个协议是可以禁止的！禁止后，如果你ping对方，对方收到后就不回馈给你，这样你就显示无法ping通，但实际你们还是连着的！telnet是登陆服务器的！服务没禁止就能登陆。</p>
<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境[1]。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。</p>
<p>SSH以非对称加密实现身份验证</p>
<h3 id="端口-1"><a href="#端口-1" class="headerlink" title="端口"></a>端口</h3><p>服务器：默认情况下，ssh服务器，会在 TCP 端口 22 进行监听；</p>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>是建立在应用层<br>SSH协议框架中最主要的部分是三个协议：</p>
<ol>
<li>传输层协议（The Transport Layer Protocol）：传输层协议提供服务器认证，数据机密性，信息完整性等的支持。</li>
<li>用户认证协议（The User Authentication Protocol）：用户认证协议为服务器提供客户端的身份鉴别。</li>
<li>连接协议（The Connection Protocol）：连接协议将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用。<br>同时还有为许多高层的网络安全应用协议提供扩展的支持。</li>
</ol>
<h3 id="ssh-子程序"><a href="#ssh-子程序" class="headerlink" title="ssh 子程序"></a>ssh 子程序</h3><p>ssh分为两部分：服务器端和客户端</p>
<p>服务器端是一个守护进程，用于处理客户端的连接请求，一般为 <code>sshd</code></p>
<p>客户端包括ssh程序以及 <code>scp，slogin，sftp</code>等其他应用程序</p>
<p>他们之间最大的不同是ssh对传输加密，安全性高，telnet使用明文传输，较为不安全。</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p><a target="_blank" rel="noopener" href="https://toutyrater.github.io/app/reverse.html">https://toutyrater.github.io/app/reverse.html</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.neargle.com/SecNewsBak/drops/%E7%BF%BB%E5%A2%99%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%20.html">http://blog.neargle.com/SecNewsBak/drops/%E7%BF%BB%E5%A2%99%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%20.html</a></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><p>最近被服务器没网搞得很烦，所以准备研究一下</p>
<ol>
<li><p>网络服务模型</p>
<ol>
<li>用户或者客户端通过发送各种请求到服务器对应的IP或者域名来获取服务功能，包括html的网站，下载服务，服务器的访问</li>
</ol>
</li>
<li><p>请求有哪些？</p>
<ol>
<li>curl，ping wget ssh sockes5 ，git clone， apt-get的区别和走代理的关系</li>
</ol>
</li>
<li><p>常见协议有哪些？有什么作用</p>
</li>
<li><p>网站服务如何实现的</p>
</li>
<li><p>下载服务怎么实现的，比如git</p>
</li>
<li><p>如何在一台机器上连上网络</p>
</li>
<li><p>如何知道当前网络供应商是谁？可以知道账号密码吗？</p>
</li>
<li><p>本地转发代理与局域网内机器转发代理怎么实现？树莓派转发怎么样？袁福焱，docker代理</p>
<ol>
<li>树莓派买哪一个</li>
</ol>
</li>
<li><p>寝室要不要路由器，能用来转发吗？</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyhmz/article/details/81586632">https://blog.csdn.net/zyhmz/article/details/81586632</a></p>
<p>网络协议图来自：<a target="_blank" rel="noopener" href="http://www.52im.net/thread-180-1-1.html">http://www.52im.net/thread-180-1-1.html</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「hei bai ying」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37809146/article/details/104017921">https://blog.csdn.net/m0_37809146/article/details/104017921</a></p>
<p><a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html">http://www.52im.net/topic-tcpipvol1.html</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/14/">Previous</a></div><div class="pagination-next"><a href="/page/16/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/14/">14</a></li><li><a class="pagination-link is-current" href="/page/15/">15</a></li><li><a class="pagination-link" href="/page/16/">16</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/37/">37</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="Shaojie Tan"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shaojie Tan</p><p class="is-size-6 is-block">𝘊𝘰𝘮𝘱𝘶𝘵𝘦𝘳 𝘈𝘳𝘤𝘩𝘪𝘵𝘦𝘤𝘵𝘶𝘳𝘦 &amp; 𝘏𝘗𝘊</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Anhui, Hefei, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">361</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">29</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">481</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Kirrito-k423" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Kirrito-k423"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithms/"><span class="level-start"><span class="level-item">Algorithms</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/Architecture/"><span class="level-start"><span class="level-item">Architecture</span></span><span class="level-end"><span class="level-item tag">36</span></span></a></li><li><a class="level is-mobile" href="/categories/Artificial-Intelligence/"><span class="level-start"><span class="level-item">Artificial Intelligence</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Databases/"><span class="level-start"><span class="level-item">Databases</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/HPC/"><span class="level-start"><span class="level-item">HPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/OOW/"><span class="level-start"><span class="level-item">OOW</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Operating-system/"><span class="level-start"><span class="level-item">Operating system</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Overview/"><span class="level-start"><span class="level-item">Overview</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Software/"><span class="level-start"><span class="level-item">Software</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tips/"><span class="level-start"><span class="level-item">Tips</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Treasure/"><span class="level-start"><span class="level-item">Treasure</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tutorials/"><span class="level-start"><span class="level-item">Tutorials</span></span><span class="level-end"><span class="level-item tag">118</span></span></a></li><li><a class="level is-mobile" href="/categories/Values/"><span class="level-start"><span class="level-item">Values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/architecture/"><span class="level-start"><span class="level-item">architecture</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/diary/"><span class="level-start"><span class="level-item">diary</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/english/"><span class="level-start"><span class="level-item">english</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/hardware/"><span class="level-start"><span class="level-item">hardware</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/math/"><span class="level-start"><span class="level-item">math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/operating-system/"><span class="level-start"><span class="level-item">operating system</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/security/"><span class="level-start"><span class="level-item">security</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/software/"><span class="level-start"><span class="level-item">software</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/thinking/"><span class="level-start"><span class="level-item">thinking</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/thinking/OOW/"><span class="level-start"><span class="level-item">OOW</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/toLearn/"><span class="level-start"><span class="level-item">toLearn</span></span><span class="level-end"><span class="level-item tag">51</span></span></a></li><li><a class="level is-mobile" href="/categories/values/"><span class="level-start"><span class="level-item">values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://ibug.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ibugs</span></span><span class="level-right"><span class="level-item tag">ibug.io</span></span></a></li><li><a class="level is-mobile" href="https://jia.je/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">jiegec</span></span><span class="level-right"><span class="level-item tag">jia.je</span></span></a></li><li><a class="level is-mobile" href="https://leimao.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">leimao</span></span><span class="level-right"><span class="level-item tag">leimao.github.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-08T13:13:26.000Z">2023-12-08</time></p><p class="title"><a href="/2023/12/08/OutOfWork/5-VideoEntertainment/CalibreAndItsPuginsForEhentaiBooks/">Calibre and its Pugins for e-hentai Books</a></p><p class="categories"><a href="/categories/OOW/">OOW</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-07T12:34:56.000Z">2023-12-07</time></p><p class="title"><a href="/2023/12/07/OutOfWork/3-homepage/blogWebsiteBuilderOrSSG/dokuwiki/">Dokuwiki</a></p><p class="categories"><a href="/categories/OOW/">OOW</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-06T08:10:02.000Z">2023-12-06</time></p><p class="title"><a href="/2023/12/06/OutOfWork/4-devices/nas/UgreenNas/">Ugreen Nas</a></p><p class="categories"><a href="/categories/OOW/">OOW</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-03T09:31:21.000Z">2023-12-03</time></p><p class="title"><a href="/2023/12/03/OutOfWork/3-homepage/deployment/webDesign4customizeMarkdownGrammarInSSG/">Web Design 4 : Customize Markdown Grammar In SSG</a></p><p class="categories"><a href="/categories/OOW/">OOW</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-30T21:48:21.000Z">2023-11-30</time></p><p class="title"><a href="/2023/11/30/OutOfWork/3-homepage/deployment/webDesign3FutureFeatures/">Web Design 3 : Future Features</a></p><p class="categories"><a href="/categories/OOW/">OOW</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">222</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">67</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">72</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/5G/"><span class="tag">5G</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/64bits-vs-32bits/"><span class="tag">64bits vs 32bits</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMAT/"><span class="tag">AMAT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMD/"><span class="tag">AMD</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ASPLOS/"><span class="tag">ASPLOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ATI/"><span class="tag">ATI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AVX/"><span class="tag">AVX</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Alpha/"><span class="tag">Alpha</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Analysis/"><span class="tag">Analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Apt/"><span class="tag">Apt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BFS/"><span class="tag">BFS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BHive/"><span class="tag">BHive</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BT/"><span class="tag">BT</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BTL/"><span class="tag">BTL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Baka-Mitai/"><span class="tag">Baka Mitai</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Big-Endian/"><span class="tag">Big-Endian</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a><p class="is-size-7"><span>&copy; 2023 Shaojie Tan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>