<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SHAOJIE&#039;S BOOK</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SHAOJIE&#039;S BOOK"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SHAOJIE&#039;S BOOK"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="SHAOJIE&#039;S BOOK"><meta property="og:url" content="http://icarus.shaojiemike.top/"><meta property="og:site_name" content="SHAOJIE&#039;S BOOK"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://icarus.shaojiemike.top/img/og_image.png"><meta property="article:author" content="Shaojie Tan"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://icarus.shaojiemike.top/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://icarus.shaojiemike.top"},"headline":"SHAOJIE'S BOOK","image":["http://icarus.shaojiemike.top/img/og_image.png"],"author":{"@type":"Person","name":"Shaojie Tan"},"publisher":{"@type":"Organization","name":"SHAOJIE'S BOOK","logo":{"@type":"ImageObject","url":"http://icarus.shaojiemike.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-15T16:00:00.000Z" title="7/15/2023, 4:00:00 PM">2023-07-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.607Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Operating-system/">Operating system</a></span><span class="level-item">an hour read (About 6793 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/15/Work/Operating%20system/filesystem/">File System</a></p><div class="content"><h2 id="文件系统简介"><a href="#文件系统简介" class="headerlink" title="文件系统简介"></a>文件系统简介</h2><p>计算机文件系统是操作系统的一个重要组成部分,它管理计算机存储设备上的文件,负责文件存储、读取和组织等功能。文件系统的主要作用包括:</p>
<ul>
<li>文件存储与寻址:文件系统负责在存储设备上对文件进行存取,需要找到文件在存储设备上的位置。常见的寻址机制有:<ul>
<li>FAT表:使用文件分配表记录每个文件所占用簇的位置。</li>
<li>inode:为每个文件分配一个inode,记录文件存储位置、大小、访问时间等元信息。</li>
</ul>
</li>
<li>文件组织与优化:文件系统负责组织硬盘空间,常见的组织结构包括:<ul>
<li>目录结构:将文件组织成目录&#x2F;子目录的树形层次结构。</li>
<li>碎片整理:通过碎片整理优化空间利用率。</li>
<li>块大小:通过调整块大小来改善IO性能。</li>
</ul>
</li>
<li>访问控制:管理文件访问权限、用户组等信息,确保访问安全。<ul>
<li>高级功能:一些文件系统实现了高级功能,如快照、数据压缩、加密等。</li>
<li>系统完整性:提供一致性检验、崩溃恢复机制来保证文件系统完整可靠。</li>
</ul>
</li>
</ul>
<p>常见的文件系统包括Windows上的FAT、NTFS,Unix&#x2F;Linux上的ext、XFS、Btrfs等。</p>
<p>文件系统的设计对操作系统的性能、安全性有很大影响。一个优秀的文件系统应提供高效的IO访问、良好的安全控制和数据完整性保障。选择正确的文件系统对不同场景也很重要。</p>
<h3 id="评估文件系统"><a href="#评估文件系统" class="headerlink" title="评估文件系统"></a>评估文件系统</h3><ul>
<li>性能:读写速度、响应时间、并发支持如何,可以测试IO性能。</li>
<li>可靠性:数据完整性保证、Crash可恢复性如何,测试崩溃恢复。</li>
<li>安全性:访问控制、防篡改机制如何,测重写、破坏后的数据恢复。</li>
<li>容量:最大文件大小、卷大小、目录容量如何,测试边界极限。</li>
<li>扩展性:可线性扩展还是需要重构,测试大容量情况下的性能。</li>
<li>元数据:元信息组织结构,是否支持快速查找、高级索引。</li>
<li>分配机制:如何分配和回收空间,是否会产生碎片。</li>
<li>一致性:是否保证读写顺序一致性,如何支持缓存与本地IO。</li>
<li>插件机制:是否可以通过插件扩展功能,如压缩、加密等。</li>
<li>兼容性:是否兼容主流平台和老系统,测试迁移和交互兼容性。</li>
</ul>
<h2 id="基本概念：数据分块存储"><a href="#基本概念：数据分块存储" class="headerlink" title="基本概念：数据分块存储"></a>基本概念：数据分块存储</h2><p>文件储存在硬盘上，硬盘的<strong>最小存储单位</strong>叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>
<p>但是就像内存读取也不会只读一个字节， 硬盘的存储和读取都是按照Block进行的(比如,4KB即连续八个 sector组成一个 block。)</p>
<h2 id="早期：FAT文件系统"><a href="#早期：FAT文件系统" class="headerlink" title="早期：FAT文件系统"></a>早期：FAT文件系统</h2><p>早期文件分配表（File Allocate Table，FAT）<br><img src="https://pic.shaojiemike.top/img/20221119155509.png"><br>链表结构解决了文件和物理块映射的问题。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>常见的FAT12、FAT16、FAT32格式,用于早期Windows系统。</li>
<li>优点：简单易用,支持跨平台</li>
<li>缺点：非常占用内存, 效率和安全性不高。<ul>
<li>比如 1T 的硬盘，如果块的大小是 1K，那么就需要 1G 个 FAT 条目。</li>
<li>通常每个 FAT 条目还会存一些其他信息，需要 2~3 个字节， FAT条目总共占用 2-3G 的内存空间，才能用来管理 1T 的硬盘空间。</li>
</ul>
</li>
</ul>
<h2 id="常见：基于inode的文件系统"><a href="#常见：基于inode的文件系统" class="headerlink" title="常见：基于inode的文件系统"></a>常见：基于inode的文件系统</h2><p>基于 inode(index node的数据结构) 的传统文件系统。文件数据被存储不同块里面，文件的元数据信息就会被存储在inode里面。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>在Unix&#x2F;Linux中广泛使用的文件系统,如Ext、XFS等。</li>
<li>每个文件都有一个对应的inode,记录文件元信息和数据块位置。</li>
<li>操作系统通过inode找到文件内容,支持权限控制等高级功能。</li>
<li>效率高,安全可靠,但inode会占用一定存储空间。</li>
</ul>
<h3 id="文件操作流程"><a href="#文件操作流程" class="headerlink" title="文件操作流程"></a>文件操作流程</h3><p>由于inode号码与文件名分离</p>
<ul>
<li>删除流程<ul>
<li>删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</li>
<li>直接删除inode，能够起到删除(包含特殊字符)文件的作用<code>find ./* -inum 节点号 -delete</code></li>
</ul>
</li>
<li>移动文件或重命名文件<ul>
<li>只是改变文件名，不影响inode号码；</li>
</ul>
</li>
</ul>
<h3 id="inode存储Block信息"><a href="#inode存储Block信息" class="headerlink" title="inode存储Block信息"></a>inode存储Block信息</h3><p>为了解决数据变化问题，它引入了<strong>3个存储指针设计</strong>。</p>
<p><img src="https://pic.shaojiemike.top/img/20221119163909.png"></p>
<ul>
<li>直接指针可以直接指向数据块本身，数据块就是保存数据的块</li>
<li>间接指针是在前面的指针指针不够的时候才会启用，间接指针可以看成链表那样，间接指针会指向一个个索引块，这块本身又是一个数据块的指针也是只是指向存储数据块。</li>
<li>第3类指针，指向一个二级索引块，二级索引块的指针还可以指向新的索引块</li>
</ul>
<h3 id="大小占用"><a href="#大小占用" class="headerlink" title="大小占用"></a>大小占用</h3><ul>
<li>每个inode节点的大小固定，一般是128字节或256字节。</li>
<li>inode节点的总数，在格式化时就给定，<del>一般是每1KB或每2KB就设置一个inode</del>。</li>
<li>每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</li>
<li>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -hi .</span><br><span class="line">Filesystem     Inodes IUsed IFree IUse% Mounted on</span><br><span class="line">/dev/sda2         56M  5.1M   51M   10% /</span><br><span class="line">或者</span><br><span class="line">/dev/sda2      58605568 5321132 53284436   10% /</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个inode节点的大小，一般是128字节或256字节。</span></span><br><span class="line">$ sudo dumpe2fs -h /dev/sda2 | grep <span class="string">&quot;Inode size&quot;</span></span><br><span class="line">dumpe2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Inode size:               256</span><br></pre></td></tr></table></figure>

<p>58605568&#x2F;256 &#x3D; 222928 个 inode节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line">Disk /dev/sda: 894.26 GiB, 960197124096 bytes, 1875385008 sectors</span><br><span class="line">Disk model: INTEL SSDSC2KB96</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: gpt</span><br><span class="line">Disk identifier: 86F8050E-C9E7-4BDB-8B0C-89E20B013FF6</span><br><span class="line"></span><br><span class="line">Device     Start        End    Sectors   Size Type</span><br><span class="line">/dev/sda1   2048       4095       2048     1M BIOS boot</span><br><span class="line">/dev/sda2   4096 1875382271 1875378176 894.3G Linux filesystem</span><br><span class="line"></span><br><span class="line">$ sudo fdisk -l /dev/sda2</span><br><span class="line">Disk /dev/sda2: 894.26 GiB, 960193626112 bytes, 1875378176 sectors (512 bytes per sector)</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br></pre></td></tr></table></figure>

<p>1875378176&#x2F;228928 &#x3D; 8192(8K) 个 sector 对应一个inode节点</p>
<p>一个inode节点对应 4MB的空间？</p>
<h3 id="目录、软链接、硬链接"><a href="#目录、软链接、硬链接" class="headerlink" title="目录、软链接、硬链接"></a>目录、软链接、硬链接</h3><ul>
<li><strong>目录</strong>：目录是一种特殊的文件，它的inode节点中存储的是文件名和inode号码的对应关系。</li>
<li><strong>软链接</strong>：软链接拥有自己的inode，但是文件内容就是一个快捷方式。<ul>
<li>命令 <code>ln -s /etc/nginx/config link_config</code></li>
<li>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</li>
<li>文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</li>
</ul>
</li>
<li><strong>硬链接</strong>：多个文件名指向同一个inode号码。<ul>
<li>命令 <code>ln main.c link_main.c</code></li>
</ul>
</li>
</ul>
<h3 id="软链接、硬链接区别与使用场景"><a href="#软链接、硬链接区别与使用场景" class="headerlink" title="软链接、硬链接区别与使用场景"></a>软链接、硬链接区别与使用场景</h3><p>在大部分常见场景下,硬链接是更优的选择：</p>
<ol>
<li>硬链接是一个真实文件,不会无效,更可靠。软链接指向的文件移动或删除后会失效。</li>
<li>硬链接与原文件性能一致,软链接需要在查询时重新解析路径。</li>
</ol>
<p>硬链接也有一些限制：</p>
<ol>
<li>不能跨文件系统,软链接可以实现跨文件系统的链接。</li>
<li>目录无法创建硬链接,只能软链接。</li>
</ol>
<h2 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h2><ul>
<li>NTFS 和 Ext3 是日志文件系统，它们和 FAT 最大的区别在于写入到磁盘中的是日志，而不是数据。</li>
<li>日志文件系统会先把日志写入到内存中一个<strong>高速缓冲区</strong>，定期写入到磁盘。</li>
<li>日志写入是追加式的，不用考虑数据的覆盖。</li>
<li>一段时间内的日志内容，会形成还原点。这种设计大大提高了性能，当然也会有一定的数据冗余。</li>
</ul>
<h3 id="日志文件系统-与-inode-文件系统的关系"><a href="#日志文件系统-与-inode-文件系统的关系" class="headerlink" title="日志文件系统 与 inode 文件系统的关系"></a>日志文件系统 与 inode 文件系统的关系</h3><ol>
<li>日志文件系统是一种技术,可以建立在多种文件系统之上,包括inode文件系统。</li>
<li>inode文件系统是一种文件系统架构,每个文件都有一个inode保存元信息。ext、xfs等都是这种架构。</li>
<li>但两者不是必然关联的,日志文件系统技术也可以用在非inode型文件系统上。</li>
</ol>
<h2 id="常见名词及文件系统：MBR、GPT和FAT、EXT2"><a href="#常见名词及文件系统：MBR、GPT和FAT、EXT2" class="headerlink" title="常见名词及文件系统：MBR、GPT和FAT、EXT2"></a>常见名词及文件系统：MBR、GPT和FAT、EXT2</h2><p>前两者是磁盘分区格式，后两者是文件系统格式。</p>
<p>MBR、GPT是两种比较常见的磁盘分区格式，而且对于磁盘分区而言，目前也主要是这两种格式。一个分区是一个存储设备上的一块独立区域，用户可以针对这块区域进行单独管理。</p>
<ul>
<li>NFS:网络文件系统,允许通过网络访问文件,可应用在分布式系统。</li>
<li>ZFS:引入了pooled storage和checksum等特性的128位文件系统。</li>
<li>HFS:Mac OS使用的层次化文件系统,使用B*树对元数据进行组织。</li>
</ul>
<h3 id="实践：fdisk的结果"><a href="#实践：fdisk的结果" class="headerlink" title="实践：fdisk的结果"></a>实践：fdisk的结果</h3><ul>
<li>“Disk label type”表示当前磁盘的分区形式，</li>
<li>dos表示磁盘分区形式为MBR，</li>
<li>gpt表示磁盘分区形式为GPT</li>
</ul>
<h2 id="Windows-NTFS文件系统"><a href="#Windows-NTFS文件系统" class="headerlink" title="Windows NTFS文件系统"></a>Windows NTFS文件系统</h2><p>New Technology File System (NTFS):Windows NT引入的文件系统,使用主文件表(MFT)来管理文件,支持高级功能如权限控制等。</p>
<ul>
<li>NTFS卷上的任何事物都是文件(为了与平时使用的文件相区别，以下用FILE特指)，</li>
<li>FILE通过主文件表(master file table, MFT)来确定其在卷上的位置，</li>
<li>每个FILE有固定大小，一般为1KB。</li>
<li>FILE记录了文件的所有数据，每个数据以一个属性来表示，如文件名、文件长度、文件的时间等都是属性，文件的内容也是一个属性，每个属性有一个特征码。</li>
<li>属性数据较小时能够存放在FILE记录中，称为驻留的属性，反之为非驻留的属性，通过Data Runs来保存其存储索引表。<ul>
<li>这一点与FAT文件系统不同，FAT文件系统只在目录区保存了文件的首簇号，还要通过FAT表链接关系才能确定文件的全部存放位置。</li>
<li>Data Runs在一个FILE记录存放不下时还可以用扩展属性，增加FILE记录来保存，即一个文件可以有多个FILE记录。</li>
</ul>
</li>
</ul>
<p>NTFS的同层目录采用B+树结构，按文件(夹)名保持有序，通过文件号指向文件夹内的文件。文件夹的目录项较少时可以直接存储在文件夹的FILE记录中，目录项较多时占用数据簇，建立INDX记录，存放各目录项的属性。</p>
<p>NTFS文件系统一共由16个“元文件”构成</p>
<h2 id="Linux常见-EXT文件系统的发展简介"><a href="#Linux常见-EXT文件系统的发展简介" class="headerlink" title="Linux常见 EXT文件系统的发展简介"></a>Linux常见 EXT文件系统的发展简介</h2><h3 id="ext1"><a href="#ext1" class="headerlink" title="ext1"></a>ext1</h3><ul>
<li>优点：1992 年的 ext 使用在 Linux 内核中的新虚拟文件系统（VFS）抽象层。<ul>
<li>与之前的 MINIX 文件系统不同的是，ext 可以处理高达 2 GB 存储空间并处理 255 个字符的文件名。</li>
</ul>
</li>
<li>缺点：原始的时间戳（每个文件仅有一个时间戳，而不是今天我们所熟悉的有 inode、最近文件访问时间和最新文件修改时间的时间戳。）</li>
</ul>
<h3 id="ext2"><a href="#ext2" class="headerlink" title="ext2"></a>ext2</h3><ul>
<li>优点：提供了 GB 级别的最大文件大小和 TB 级别的文件系统大小。</li>
<li>缺点：<ul>
<li>将数据写入到磁盘的时候，系统发生崩溃或断电，则容易发生灾难性的数据损坏。</li>
<li>随着时间的推移，由于<strong>碎片</strong>（单个文件存储在多个位置，物理上其分散在旋转的磁盘上），它们也遭受了严重的性能损失。</li>
</ul>
</li>
</ul>
<h3 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h3><ul>
<li>2001 年 11 月在 2.4.15 内核版本中被采用到 Linux 内核主线中。</li>
<li>优点：使用<strong>日志</strong>来解决断电数据不一致问题，和 20 世纪 90 年代后期的其它文件系统一样，如微软的 NTFS。</li>
</ul>
<h3 id="ext4"><a href="#ext4" class="headerlink" title="ext4"></a>ext4</h3><ul>
<li>2008年在 2.6.28 内核版本中被加入到了 Linux 主线。</li>
<li>优点：<ul>
<li>支持大文件系统，<ul>
<li>ext3 文件系统使用 32 位寻址，这限制它仅支持 2 TiB 文件大小和 16 TiB 文件系统系统大小</li>
<li>ext4 使用 48 位的内部寻址，理论上可以在文件系统上分配高达 16 TiB 大小的文件，其中文件系统大小最高可达 1000000 TiB（1 EiB）</li>
</ul>
</li>
<li>分配方式改进，显著提高读写性能<ul>
<li>区段(extent)<ul>
<li>是一系列连续的物理块 (最多达 128 MiB，假设块大小为 4 KiB），可以一次性保留和寻址。使用区段而不是 block可以减少给定文件所需的 inode 数量，并显著减少碎片并提高写入大文件时的性能。</li>
</ul>
</li>
<li>多块分配(multiple block allocation)<ul>
<li>ext3 为每一个新分配的块调用一次块分配器。当多个写入同时打开分配器时，很容易导致严重的碎片。</li>
<li>多块分配(multiple block allocation)允许一次性分配大量的连续文件块，以降低碎片并且有利于 RAID 设备的并行写入</li>
</ul>
</li>
<li>延迟分配（delayed block allocation）<ul>
<li>ext4 使用<strong>延迟分配（delayed block allocation）</strong>，这允许它合并写入并更好地决定如何为尚未提交的写入分配块。</li>
<li><strong>延迟分配</strong>允许 ext4 等待分配将写入数据的实际块，直到它准备好将数据提交到磁盘。（相比之下，即使数据仍然在往写入缓存中写入，ext3 也会立即分配块。）</li>
<li>当缓存中的数据累积时，延迟分配块允许文件系统对如何分配块做出更好的选择，<strong>降低碎片</strong>（写入，以及稍后的读）并显著提升性能。</li>
</ul>
</li>
<li>持久的<strong>预分配</strong>( allocation without initialization)<ul>
<li>在为文件预分配磁盘空间时，大部分文件系统必须在创建时将零写入该文件的块中。</li>
<li>ext4 允许替代使用 fallocate()，它保证了空间的可用性（并试图为它找到连续的空间），而<strong>不需要先写入它</strong>。这显著提高了写入和将来读取流和数据库应用程序的写入数据的性能。</li>
</ul>
</li>
</ul>
</li>
<li>提高了对碎片的抵抗力<ul>
<li>ext2 和 ext3 都不直接支持在线碎片整理 —— 即在挂载时会对文件系统进行碎片整理。</li>
<li>ext4 通过 e4defrag 解决了这个问题，且是一个在线、内核模式、文件系统感知、块和区段级别的碎片整理实用程序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Nas 防止碎片，开启预分配</p>
<p><img src="https://pic.shaojiemike.top/img/20221120200924.png"></p>
<h3 id="实践问题：-Nas-的-ext4-挂载被识别成NTFS"><a href="#实践问题：-Nas-的-ext4-挂载被识别成NTFS" class="headerlink" title="实践问题： Nas 的 ext4 挂载被识别成NTFS"></a>实践问题： Nas 的 ext4 挂载被识别成NTFS</h3><p>估计是有一层转换，类似的软件有  UFS Explorer</p>
<h2 id="磁盘读写原理"><a href="#磁盘读写原理" class="headerlink" title="磁盘读写原理"></a>磁盘读写原理</h2><h3 id="读写操作分层"><a href="#读写操作分层" class="headerlink" title="读写操作分层"></a>读写操作分层</h3><p><img src="https://pic.shaojiemike.top/img/20221119174036.png"></p>
<p>对于磁盘的一次读请求，</p>
<ul>
<li>首先经过虚拟文件系统层（VFS Layer），</li>
<li>其次是具体的文件系统层（例如Ext2），</li>
<li>接下来是Cache层（Page Cache Layer）、</li>
<li>通用块层（Generic Block Layer）、</li>
<li>I&#x2F;O调度层（I&#x2F;O Scheduler Layer）、</li>
<li>块设备驱动层（Block Device Driver Layer），</li>
<li>最后是物理块设备层（Block Device Layer）。</li>
</ul>
<h4 id="Page-Cache层"><a href="#Page-Cache层" class="headerlink" title="Page Cache层"></a>Page Cache层</h4><p><img src="https://pic.shaojiemike.top/img/20221119174739.png"></p>
<ul>
<li>为了提高Linux操作系统对磁盘访问的性能。Cache层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在Cache中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。</li>
<li>文件Cache分为两个层面，<ul>
<li>一是Page Cache，另一个Buffer Cache，每一个Page Cache包含若干Buffer Cache。</li>
<li>Page Cache主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有read&#x2F;write操作的时候。</li>
<li>Buffer Cache则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。</li>
</ul>
</li>
<li>磁盘Cache有两大功能：预读和回写。<ul>
<li>预读其实就是利用了局部性原理，具体过程是：<ul>
<li>对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面（通常是三个页面），这时的预读称为同步预读。</li>
<li>对于第二次读请求，<ul>
<li>如果所读页面不在Cache中，即不在前次预读的页中，则表明文件访问不是顺序访问，系统继续采用同步预读；</li>
<li>如果所读页面在Cache中，则表明前次预读命中，操作系统把预读页的大小扩大一倍，此时预读过程是异步的，应用程序可以不等预读完成即可返回，只要后台慢慢读页面即可，这时的预读称为异步预读。</li>
</ul>
</li>
<li>任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读的页面中，这时继续进行异步预读；第二种情况是所请求的页面处于预读页面之外，这时系统就要进行同步预读。</li>
</ul>
</li>
<li>回写是通过暂时将数据存在Cache里，然后统一异步写到磁盘中。<ul>
<li>通过这种异步的数据I&#x2F;O模式解决了程序中的计算速度和数据存储速度不匹配的鸿沟，减少了访问底层存储介质的次数，使存储系统的性能大大提高。Linux</li>
<li>2.6.32内核之前，采用pdflush机制来将脏页真正写到磁盘中，什么时候开始回写呢？下面两种情况下，脏页会被写回到磁盘：<ul>
<li>在空闲内存低于一个特定的阈值时，内核必须将脏页写回磁盘，以便释放内存。</li>
<li>当脏页在内存中驻留超过一定的阈值时，内核必须将超时的脏页写会磁盘，以确保脏页不会无限期地驻留在内存中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O调度层"><a href="#I-O调度层" class="headerlink" title="I&#x2F;O调度层"></a>I&#x2F;O调度层</h3><ul>
<li>I&#x2F;O调度层的功能是管理块设备的请求队列。<ul>
<li>即接收通用块层发出的I&#x2F;O请求，缓存请求并试图合并相邻的请求。</li>
<li>并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的I&#x2F;O请求。</li>
</ul>
</li>
<li>如果简单地以内核产生请求的次序直接将请求发给块设备的话，那么块设备性能肯定让人难以接受，因为磁盘寻址是整个计算机中最慢的操作之一。</li>
<li>为了优化寻址操作，内核不会一旦接收到I&#x2F;O请求后，就按照请求的次序发起块I&#x2F;O请求。</li>
<li>为此Linux实现了几种I&#x2F;O调度算法，算法基本思想就是通过合并和排序I&#x2F;O请求队列中的请求，以此大大降低所需的磁盘寻道时间，从而提高整体I&#x2F;O性能。</li>
</ul>
<p>常见的I&#x2F;O调度算法包括</p>
<ol>
<li>Noop调度算法（No Operation）、</li>
<li>CFQ（完全公正排队I&#x2F;O调度算法）、</li>
<li>DeadLine（截止时间调度算法）、</li>
<li>AS预测调度算法等。</li>
</ol>
<h2 id="磁盘快速I-O常见机制"><a href="#磁盘快速I-O常见机制" class="headerlink" title="磁盘快速I&#x2F;O常见机制"></a>磁盘快速I&#x2F;O常见机制</h2><p>Linux系统中请求到达磁盘的一次完整过程，期间Linux一般会通过Cache以及排序合并I&#x2F;O请求来提高系统的性能。</p>
<p>其本质就是由于磁盘随机读写慢、顺序读写快的磁盘I&#x2F;O特性。</p>
<h3 id="采用追加写"><a href="#采用追加写" class="headerlink" title="采用追加写"></a>采用追加写</h3><p>在进行系统设计时，良好的读性能和写性能往往不可兼得。在许多常见的开源系统中都是优先在保证写性能的前提下来优化读性能。那么如何设计能让一个系统拥有良好的写性能呢？</p>
<ul>
<li>一个好的办法就是采用追加写，每次将数据添加到文件。</li>
<li>由于完全是顺序的，所以可以具有非常好的写操作性能。</li>
<li>但是这种方式也存在一些缺点：从文件中读一些数据时将会需要更多的时间：<ul>
<li>需要倒序扫描，直到找到所需要的内容。</li>
<li>当然在一些简单的场景下也能够保证读操作的性能：<ul>
<li>数据是被整体访问，比如HDFS</li>
<li>知道文件明确的偏移量，比如Kafka</li>
</ul>
</li>
<li>在面对更复杂的读场景（比如按key）时，如何来保证读操作的性能呢？<ul>
<li>简单的方式是像Kafka那样，将文件数据有序保存，使用二分查找来优化效率；</li>
<li>或者通过建索引的方式来进行优化；</li>
<li>也可以采用hash的方式将数据分割为不同的桶。</li>
</ul>
</li>
<li>以上的方法都能增加读操作的性能，但是由于在数据上强加了数据结构，又会降低写操作的性能。<ul>
<li>比如如果采用索引的方式来优化读操作，那么在更新索引时就需要更新B-tree中的特定部分，这时候的写操作就是随机写。</li>
</ul>
</li>
<li>那么有没有一种办法在保证写性能不损失的同时也提供较好的读性能呢？</li>
<li>一个好的选择就是使用LSM-tree。<ul>
<li>LSM-tree与B-tree相比，LSM-tree牺牲了部分读操作，以此大幅提高写性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件合并和元数据优化"><a href="#文件合并和元数据优化" class="headerlink" title="文件合并和元数据优化"></a>文件合并和元数据优化</h3><p>目前的大多数文件系统，如XFS&#x2F;Ext4、GFS、HDFS，在元数据管理、缓存管理等实现策略上都侧重大文件。</p>
<h2 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h2><h3 id="不同文件系统的比较"><a href="#不同文件系统的比较" class="headerlink" title="不同文件系统的比较"></a>不同文件系统的比较</h3><p>像 FAT 和 FAT32 这类文件系统中，文件紧挨着写入到磁盘中。文件之间没有空间来用于增长或者更新：</p>
<p>NTFS 中在文件之间保留了一些空间，因此有空间进行增长。但因块之间的空间是有限的，碎片也会随着时间出现。</p>
<p>Linux 的日志型文件系统采用了一个不同的方案。与文件相互挨着不同，每个文件分布在磁盘的各处，每个文件之间留下了大量的剩余空间。这就给文件更新和增长留下了很大的空间，碎片很少会发生。</p>
<p>此外，碎片一旦出现了，大多数 Linux 文件系统会尝试将文件和块重新连续起来。</p>
<h3 id="检测命令"><a href="#检测命令" class="headerlink" title="检测命令"></a>检测命令</h3><p>在已经挂载的分区中运行 fsck 将会<strong>严重危害</strong>到你的数据和磁盘。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount /path</span><br><span class="line">fsck -fn /path</span><br></pre></td></tr></table></figure>

<p>大于20%需要整理。<a target="_blank" rel="noopener" href="https://www.aikaiyuan.com/5679.html">批评fsck不准的文章：大文件碎片少才是最重要的</a></p>
<p>NEC 的 Akira Fujita 和 Takashi Sato 在十年前就为 ext4 写了在线整理碎片的工具，因此我们直接拿来用就好了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e4defrag -v /path</span><br></pre></td></tr></table></figure>

<h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/197465">方法一</a>：整个磁盘文件备份，格式化，重新搬运。(Liunx 会自动将文件进行连续分布排列。)</p>
<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不要中断，很危险</span></span><br><span class="line">sudo e4defrag /</span><br></pre></td></tr></table></figure>

<h2 id="常见实践问题"><a href="#常见实践问题" class="headerlink" title="常见实践问题"></a>常见实践问题</h2><h3 id="为什么出现坏道之后，硬盘会飞速损耗"><a href="#为什么出现坏道之后，硬盘会飞速损耗" class="headerlink" title="为什么出现坏道之后，硬盘会飞速损耗"></a>为什么出现坏道之后，硬盘会飞速损耗</h3><p>坏道分为逻辑坏道，和物理坏道。如果是物理坏道，由于异物或者碰撞导致磁头，盘面受损，会导致物理损坏扩散，应该今早备份数据。</p>
<h3 id="并行下载多个两个文件，存储是交叉的吗？读数据会变慢吗？"><a href="#并行下载多个两个文件，存储是交叉的吗？读数据会变慢吗？" class="headerlink" title="并行下载多个两个文件，存储是交叉的吗？读数据会变慢吗？"></a>并行下载多个两个文件，存储是交叉的吗？读数据会变慢吗？</h3><p>场景问题：</p>
<p>1.同时向机械硬盘拷贝多个文件夹，每个文件夹里都有多个小文件。<br>2.同时解压多个压缩包，每个压缩包有大量的小文件。<br>3.同时安装多个游戏安装包。<br>会不会导致交叉存储？会不会导致碎片增加？会不会导致游玩游戏时读取速度变慢？</p>
<p>一般不用担心，有些文件系统会做碎片整理。然后操作系统的缓存写和预读策略也会优化。</p>
<h3 id="硬盘的寿命"><a href="#硬盘的寿命" class="headerlink" title="硬盘的寿命"></a>硬盘的寿命</h3><p>对于机械硬盘来讲，反复读写、多线程读写等情况对磁盘使用寿命的影响很低，<br>但“高温”、“低温”、“尘土”、“外力冲击（跌落）”等情况，会对磁盘的寿命造成较大的影响。</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/30%20%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9AFAT%E3%80%81NTFS%20%E5%92%8C%20Ext3%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/30%20%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9AFAT%E3%80%81NTFS%20%E5%92%8C%20Ext3%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2011/12/inode.html">https://www.ruanyifeng.com/blog/2011/12/inode.html</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/05/19/about-desk-io.html">https://tech.meituan.com/2017/05/19/about-desk-io.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44267768">https://zhuanlan.zhihu.com/p/44267768</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/197465">https://developer.aliyun.com/article/197465</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-14T16:00:00.000Z" title="7/14/2023, 4:00:00 PM">2023-07-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.603Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/toLearn/">toLearn</a></span><span class="level-item">4 minutes read (About 663 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/14/Work/HPC/IPCC/IPCC2022final/">IPCC2022final</a></p><div class="content"><p><img src="https://pic.shaojiemike.top/img/20221203200751.png"></p>
<h2 id="学到的一些亮点"><a href="#学到的一些亮点" class="headerlink" title="学到的一些亮点"></a>学到的一些亮点</h2><p><img src="https://pic.shaojiemike.top/img/20221202184317.png"></p>
<p><img src="https://pic.shaojiemike.top/img/20221202184521.png"></p>
<h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>由于决赛是黑盒制度，没有排行榜，也不知道最终算分的例子是多大。我们优化着眼于自己找的清华的大例子，并行的占比在这部分很小。忽略了小例子里，占比比较高的部分的优化。结果最终赛题例子很小。</p>
<p><img src="https://pic.shaojiemike.top/img/20221202185953.png"></p>
<p>如果提前知道元素个数，并行对同一个数组的末尾添加元素可以并行，添加到指定位置之后再统一排序就行。比如山东大学，就是这里快了大约10ms，加上第一次排序快5ms。</p>
<p><img src="https://pic.shaojiemike.top/img/20221203103311.png"></p>
<p>比如信息中心(应该是第一名)的排序，用的是归并的基数排序<img src="https://pic.shaojiemike.top/img/20221203195910.png"></p>
<p>比如青海大学的优化：<img src="https://pic.shaojiemike.top/img/20221202191111.png"></p>
<p>还有高效的排序，怎么实现。<a target="_blank" rel="noopener" href="https://github.com/cermi29/ParallelStableSort">类似</a></p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p><img src="https://pic.shaojiemike.top/img/20221202191656.png"></p>
<p>CSR (压缩稀疏行存储) 矩阵和邻接表在表示图数据结构时,计算和访问性能有些差异:</p>
<ul>
<li>CSR通过压缩行存储机制,可以大幅减少空间占用,节省内存。但索引算术运算负担重一些</li>
<li>邻接表使用链表指针连接相邻节点,追踪任意一条边的开销很低。但总体占用内存空间更大。</li>
<li>CSR访问任意一个元素通过索引计算直接可以定位,兼具稠密和稀疏矩阵的特点。</li>
<li>邻接表的边访问性能更好,通过指针直接遍历一个节点的所有相邻节点。</li>
<li>CSR的预处理时间较短,更易于向量化实现提高效率。</li>
<li>邻接表更灵活,可表示加权图或处理动态变化的图。</li>
<li>CSR矩阵更易进行压缩和剪枝来优化存储,节省内存带宽。</li>
</ul>
<p>所以简单来说,如果图更稠密,数据访问模式更随机,CSR可能会有些优势。如果需要频繁遍历边,图结构变化大,邻接表访问效率可能会更高一些。需要根据具体情况选择合适的表示。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><p>哎呀，你干嘛！ 今年又<del>西巴了</del>,惜败了，应该是第三名左右。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-14T16:00:00.000Z" title="7/14/2023, 4:00:00 PM">2023-07-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.619Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">5 minutes read (About 705 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/14/Work/software/perf/NUMAperf/">NUMA perf</a></p><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NUMA使用的目的是为了每个进程能使用local内存来实现高性能。但是假如某进程的local内存提前用完了，会导致无法使用其他进程的内存，反而需要SWAP的问题。(一般小例子遇不到)</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/quantfabric/2594323">https://blog.51cto.com/quantfabric/2594323</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/machangwei-8/p/10402644.html">https://www.cnblogs.com/machangwei-8/p/10402644.html</a></p>
<h2 id="NUMA的内存分配策略"><a href="#NUMA的内存分配策略" class="headerlink" title="NUMA的内存分配策略"></a>NUMA的内存分配策略</h2><ol>
<li>缺省(default)：总是在本地节点分配（分配在当前进程运行的节点上）；</li>
<li>绑定(bind)：强制分配到指定节点上；</li>
<li>交叉(interleave)：在所有节点或者指定的节点上交织分配；</li>
<li>优先(preferred)：在指定节点上分配，失败则在其他节点上分配。</li>
</ol>
<p>因为NUMA默认的内存分配策略是优先在进程所在CPU的本地内存中分配，会导致CPU节点之间内存分配不均衡，当某个CPU节点的内存不足时，会导致swap产生，而不是从远程节点分配内存。这就是所谓的swap insanity 现象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --hardware</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47</span><br><span class="line">node 0 size: 64076 MB</span><br><span class="line">node 0 free: 23497 MB</span><br><span class="line">node 1 cpus: 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63</span><br><span class="line">node 1 size: 64503 MB</span><br><span class="line">node 1 free: 37897 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  21</span><br><span class="line">  1:  21  10</span><br><span class="line"></span><br><span class="line"># shaojiemike @ node5 in ~/github/IPCC2022-preliminary/run on git:main o [10:41:54]</span><br><span class="line">$ numactl --show</span><br><span class="line">policy: default</span><br><span class="line">preferred node: current</span><br><span class="line">physcpubind: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63</span><br><span class="line">cpubind: 0 1</span><br><span class="line">nodebind: 0 1</span><br><span class="line">membind: 0 1</span><br></pre></td></tr></table></figure>

<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 遇到内存不够时</span><br><span class="line">numactl –interleave=all ./exe</span><br><span class="line"></span><br><span class="line"># 使用local内存（默认的）</span><br><span class="line">numactl --localalloc ./exe</span><br></pre></td></tr></table></figure>

<h2 id="查看程序的内存的-NUMA情况"><a href="#查看程序的内存的-NUMA情况" class="headerlink" title="查看程序的内存的 NUMA情况"></a>查看程序的内存的 NUMA情况</h2><p>在Linux系统上,可以通过以下常用方法来查看和分析程序的NUMA(非统一内存访问)情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">numastat:查看进程和每个NUMA节点的内存分配和访问统计。</span><br><span class="line">numactl: 查看进程NUMA policy和分配策略,可以手动设置策略。</span><br><span class="line">numa_maps:查看进程在每个NUMA节点上的内存映射情况。</span><br><span class="line">mpstat -P ALL:查看每个CPU核心的统计信息。</span><br><span class="line">pidstat -t:查看进程在每个CPU上的执行时间。</span><br><span class="line">perf stat:统计程序在不同CPU上周期数,检查是否均衡。</span><br><span class="line">likwid-perfctr: 细粒度检测程序在不同内存节点的带宽和延迟。</span><br><span class="line">VTune: Intel的性能分析工具,可以检测NUMA的影响。</span><br><span class="line">代码插桩:统计程序对不同节点内存的访问。</span><br><span class="line">numactl --hardware :查看系统NUMA拓扑结构。</span><br></pre></td></tr></table></figure>

<p>通过综合使用这些工具,可以全面分析程序的NUMA性能,例如内存分布不均,访问模式导致的不均衡等,然后进行针对优化。</p>
<h2 id="c-malloc时能手动设置-内存位置"><a href="#c-malloc时能手动设置-内存位置" class="headerlink" title="c++ malloc时能手动设置 内存位置"></a>c++ malloc时能手动设置 内存位置</h2><ol>
<li>libnuma: 直接调用libnuma提供的<code>numa_alloc_onnode()</code>和<code>numa_free()</code>等API,在指定节点上分配释放内存。</li>
<li>mmap</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-14T16:00:00.000Z" title="7/14/2023, 4:00:00 PM">2023-07-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.619Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">20 minutes read (About 3059 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/14/Work/software/perf/vtuneOptimize/">VtuneOptimize</a></p><div class="content"><h2 id="vtune的安装和profile"><a href="#vtune的安装和profile" class="headerlink" title="vtune的安装和profile"></a>vtune的安装和profile</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>由于snode0有sudo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /opt/intel/oneapi/setvars.sh</span><br><span class="line">sudo vtune-gui</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://home.ustc.edu.cn/~shaojiemike/posts/nvidiansight/#sudo-ncu-ui-%E4%B8%8D%E8%83%BD%E8%BF%9C%E7%A8%8B%E6%89%93%E5%BC%80">sudo后图形化界面 MobaXterm打不开的原因参考这个</a></p>
<h2 id="Step1-Performance-Snapshot-参数说明"><a href="#Step1-Performance-Snapshot-参数说明" class="headerlink" title="Step1 : Performance Snapshot 参数说明"></a>Step1 : Performance Snapshot 参数说明</h2><p>以IPCC2022 初赛 支撑点计算的baseline为例</p>
<h2 id="Logical-Core-Utilization"><a href="#Logical-Core-Utilization" class="headerlink" title="Logical Core Utilization"></a>Logical Core Utilization</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Effective Logical Core Utilization: 3.8% (2.436 out of 64)</span><br><span class="line">    Effective Physical Core Utilization: 6.4% (2.053 out of 32)</span><br></pre></td></tr></table></figure>

<p>CPU利用率主要是指计算有效占比。为100%意味着所有逻辑CPU都是由应用程序的计算占用。</p>
<h2 id="Microarchitecture-Usage"><a href="#Microarchitecture-Usage" class="headerlink" title="Microarchitecture Usage"></a>Microarchitecture Usage</h2><p>微架构使用指标是一个关键指标，可以帮助评估(以%为单位)你的代码在当前微架构上运行的效率。</p>
<p>微架构的使用可能会受到</p>
<ol>
<li>long-latency memory长延迟访存、</li>
<li>floating-point, or SIMD operations浮点或SIMD操作的影响;</li>
<li>non-retired instructions due to branch mispredictions;由于分支错误预测导致的未退役指令;</li>
<li>instruction starvation in the front-end.前端指令不足。</li>
</ol>
<h3 id="vtune的建议"><a href="#vtune的建议" class="headerlink" title="vtune的建议"></a>vtune的建议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Microarchitecture Usage: 37.7% of Pipeline Slots</span><br><span class="line">    Retiring: 37.7%</span><br><span class="line">    Front-End Bound: 16.9%</span><br><span class="line">    Back-End Bound: 23.8%</span><br><span class="line">    Memory Bound: 11.9%</span><br><span class="line">    Core Bound: 11.9%</span><br><span class="line">    Bad Speculation: 21.5%</span><br></pre></td></tr></table></figure>

<p>针对<code>Back-End Bound: 23.8%</code>的建议如下：</p>
<p>A significant portion of pipeline slots are remaining empty.<br>(??? 他是指有23.8% empty还是被使用了呢)</p>
<p>When operations take <strong>too long</strong> in the back-end, they introduce <strong>bubbles</strong> in the pipeline that ultimately cause fewer pipeline slots containing useful work to be retired per cycle than the machine is capable to support.</p>
<p>This opportunity cost results in slower execution.</p>
<ol>
<li><strong>Long-latency operation</strong>s like <strong>divides</strong> and <strong>memory operations</strong> can cause this,</li>
<li>as can <strong>too many operations</strong> being directed to a single execution port (for example, more <strong>multiply</strong> operations arriving in the back-end per cycle than the execution unit can support).</li>
</ol>
<p>针对<code>Bad Speculation: 21.5%</code>的建议如下：</p>
<p>A significant proportion of pipeline slots containing <strong>21.5% useful work are being cancelled</strong>.</p>
<p>This can be caused by <strong>mispredicting branches</strong> or by <strong>machine clears</strong>. Note that this metric value may be highlighted due to Branch Resteers issue.</p>
<h3 id="Retiring-metric"><a href="#Retiring-metric" class="headerlink" title="Retiring metric"></a>Retiring metric</h3><p>Retiring metric represents a Pipeline Slots fraction utilized by useful work, meaning the issued uOps that eventually get retired.<br>Retiring metric 表示<strong>有用工作</strong>所使用的Pipeline slot流水线管道的比例，所有发射的uOps最终都会retired。</p>
<p>Ideally, all Pipeline Slots would be attributed to the Retiring category.<br>理想情况下，所有的管道槽都应该归于退休类别。</p>
<p>Retiring of 100% would indicate the maximum possible number of uOps retired per cycle has been achieved. 100%的退役表明每个周期内退役的uop数量达到了可能的最大值。</p>
<p>Maximizing Retiring typically increases the Instruction-Per-Cycle metric.<br>最大化Retiring通常会增加IPC。</p>
<p>Note that a high Retiring value <strong>does not necessary mean no more room</strong> for performance improvement.<br>For example, <strong>Microcode assists</strong> are categorized under Retiring. They hurt performance and can often be avoided.</p>
<p>Microcode assists根据Intel的解释是</p>
<p>当遇到特殊的计算(比如处理非常小的浮点值(所谓的逆法线)时），浮点单元并没有被设置为本机执行这些操作。为此需要在指令流中插入可能有数百个指令长的小程序，对性能会造成很大的影响。</p>
<h3 id="Front-End-Bound"><a href="#Front-End-Bound" class="headerlink" title="Front-End Bound"></a>Front-End Bound</h3><p>Front-End Bound metric represents a slots fraction where the processor’s Front-End undersupplies its Back-End. 该指标表示前端产生的指令是否足以支持后端处理。</p>
<p>Front-End denotes the first part of the processor core responsible for fetching operations that are executed later on by the Back-End part. 前端将指令分解成uops供后端处理。</p>
<p>Within the Front-End, a branch predictor predicts the next address to fetch, cache-lines are fetched from the memory subsystem, parsed into instructions, and lastly decoded into micro-ops (uOps). 在前端中，分支预测器预测下一个要获取的地址，缓存行从内存子系统中获取，解析为指令，最后解码为微操作(uOps)。</p>
<p>Front-End Bound metric denotes unutilized <strong>issue-slots</strong> when there is <strong>no Back-End stall</strong> (bubbles where Front-End delivered no uOps while Back-End could have accepted them). For example, stalls due to <strong>instruction-cache misses</strong> would be categorized as Front-End Bound</p>
<p>Front-End Bound指标表示当后端没有停顿时未使用的<strong>发射槽</strong>(bubbles: 前端没有交付uOps，而发射给后端的)。例如，由于指令缓存未命中而导致的暂停将被归类为Front-End Bound</p>
<h3 id="Back-End-Bound"><a href="#Back-End-Bound" class="headerlink" title="Back-End Bound"></a>Back-End Bound</h3><p>metric represents a Pipeline Slots fraction where no uOps are being delivered due to a lack of required resources for accepting new uOps in the Back-End. 该指标表示后端uops是否出现了因为硬件资源紧张而无法处理的问题。</p>
<p>Back-End is the portion of the processor core where an out-of-order scheduler dispatches ready uOps into their respective execution units, and, once completed, these uOps get retired according to the program order. 后端的乱序执行，顺序Reire模型。</p>
<p>For example, stalls due to <strong>data-cache misses</strong> or stalls due to the <strong>divider unit(除法器？) being overloaded</strong> are both categorized as Back-End Bound. Back-End Bound is further divided into two main categories: Memory Bound and Core Bound.</p>
<h3 id="Memory-Bound"><a href="#Memory-Bound" class="headerlink" title="Memory Bound"></a>Memory Bound</h3><p>This metric shows how memory subsystem issues affect the performance. Memory Bound measures a fraction of slots where pipeline could be stalled due to demand load or store instructions. This accounts mainly for incomplete in-flight memory demand loads that coincide with execution starvation in addition to less common cases where stores could imply back-pressure on the pipeline.</p>
<h3 id="Core-Bound"><a href="#Core-Bound" class="headerlink" title="Core Bound"></a>Core Bound</h3><p>This metric represents how much Core non-memory issues were of a bottleneck. 表明核心的非内存原因成为了瓶颈</p>
<ol>
<li>Shortage in hardware compute resources, 硬件资源的短缺</li>
<li>or dependencies software’s instructions are both categorized under Core Bound. 指令间的依赖</li>
</ol>
<p>Hence it may indicate</p>
<ol>
<li>the machine ran out of an OOO resources,</li>
<li>certain execution units are overloaded</li>
<li>or dependencies in program’s data- or instruction- flow are limiting the performance (e.g. <strong>FP-chained long-latency arithmetic operations</strong>).</li>
</ol>
<h3 id="Bad-Speculation-分支预测错误"><a href="#Bad-Speculation-分支预测错误" class="headerlink" title="Bad Speculation(分支预测错误)"></a>Bad Speculation(分支预测错误)</h3><p>represents a Pipeline Slots fraction wasted due to incorrect speculations.</p>
<p>This includes slots used to issue uOps that do not eventually get retired and slots for which the issue-pipeline was blocked due to <strong>recovery</strong> from an earlier incorrect speculation.</p>
<p>For example, wasted work due to <strong>mispredicted branches</strong> is categorized as a Bad Speculation category. Incorrect data speculation followed by Memory Ordering Nukes is another example.</p>
<p>这里的Nukes, 猜测是数据预取预测错误，带来的访存影响像核爆一样大吧.</p>
<h2 id="Memory-Bound-1"><a href="#Memory-Bound-1" class="headerlink" title="Memory Bound"></a>Memory Bound</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Memory Bound: 11.9% of Pipeline Slots</span><br><span class="line">    L1 Bound: 7.9%</span><br><span class="line">    L2 Bound: 0.2%</span><br><span class="line">    L3 Bound: 2.5%</span><br><span class="line">    DRAM Bound: 2.0%</span><br><span class="line">    Store Bound: 0.3%</span><br><span class="line">    NUMA: % of Remote Accesses: 13.2%</span><br></pre></td></tr></table></figure>

<p>This metric shows how memory subsystem issues affect the performance. Memory Bound measures a fraction of slots where pipeline could be stalled due to demand load or store instructions. 该项表明了有多少流水线的slots因为load或者store指令的需求而被迫等待</p>
<p>This accounts mainly for <strong>incomplete in-flight memory demand loads</strong> that coincide with execution starvation<br>这是指不连续访存吗？</p>
<p>in addition to less common cases where stores could imply back-pressure on the pipeline.</p>
<h3 id="L1-Bound"><a href="#L1-Bound" class="headerlink" title="L1 Bound"></a>L1 Bound</h3><p>This metric shows how often machine was stalled without missing the L1 data cache.<br>在不发生L1 miss的情况下，指令stall的频率。(因为其他原因导致stall？)</p>
<p>The L1 cache typically has the shortest latency. However, in certain cases like loads blocked on older stores, a load might suffer a high latency even though it is being satisfied by the L1. 假设load了一个刚store的值，load指令也会遇到很大的延迟。</p>
<h3 id="L2-Bound"><a href="#L2-Bound" class="headerlink" title="L2 Bound"></a>L2 Bound</h3><p>This metric shows how often machine was stalled on L2 cache. Avoiding cache misses (L1 misses&#x2F;L2 hits) will improve the latency and increase performance.</p>
<h3 id="L3-Bound"><a href="#L3-Bound" class="headerlink" title="L3 Bound"></a>L3 Bound</h3><p>This metric shows how often CPU was stalled on L3 cache, or contended with a sibling Core(与兄弟姐妹核竞争). Avoiding cache misses (L2 misses&#x2F;L3 hits) improves the latency and increases performance.</p>
<h3 id="DRAM-Bound"><a href="#DRAM-Bound" class="headerlink" title="DRAM Bound"></a>DRAM Bound</h3><p>This metric shows how often CPU was stalled on the main memory (DRAM). Caching typically improves the latency and increases performance.</p>
<h3 id="DRAM-Bandwidth-Bound"><a href="#DRAM-Bandwidth-Bound" class="headerlink" title="DRAM Bandwidth Bound"></a>DRAM Bandwidth Bound</h3><p>This metric represents percentage of elapsed time the system spent with high DRAM bandwidth utilization. Since this metric relies on the accurate peak system DRAM bandwidth measurement, explore the Bandwidth Utilization Histogram and make sure the Low&#x2F;Medium&#x2F;High utilization thresholds are correct for your system. You can manually adjust them, if required.</p>
<h3 id="Store-Bound"><a href="#Store-Bound" class="headerlink" title="Store Bound"></a>Store Bound</h3><p>This metric shows how often CPU was stalled on store operations. Even though memory store accesses do not typically stall out-of-order CPUs; there are few cases where stores can lead to actual stalls.</p>
<h3 id="NUMA-of-Remote-Accesses"><a href="#NUMA-of-Remote-Accesses" class="headerlink" title="NUMA: % of Remote Accesses"></a>NUMA: % of Remote Accesses</h3><p>In NUMA (non-uniform memory architecture) machines, memory requests missing LLC may be serviced either by local or remote DRAM. Memory requests to remote DRAM incur much greater latencies than those to local DRAM. It is recommended to keep as much frequently accessed data local as possible. This metric shows <strong>percent of remote accesses, the lower the better.</strong></p>
<p>可以用之前的<br><img src="https://pic.shaojiemike.top/img/20220724194827.png"></p>
<h2 id="Vectorization"><a href="#Vectorization" class="headerlink" title="Vectorization"></a>Vectorization</h2><p>This metric represents the percentage of <strong>packed (vectorized) floating point operations</strong>. 0% means that the code is fully scalar. The metric does not take into account the actual vector length that was used by the code for vector instructions. So if the code is fully vectorized and uses a legacy instruction set that loaded only half a vector length, the Vectorization metric shows 100%.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vectorization: 23.7% of Packed FP Operations</span><br><span class="line">    Instruction Mix: </span><br><span class="line">    SP FLOPs: 0.9%</span><br><span class="line">    Packed: 99.9%</span><br><span class="line">    128-bit: 0.1%</span><br><span class="line">    256-bit: 99.8%</span><br><span class="line">    512-bit: 0.0%</span><br><span class="line">    Scalar: 0.1%</span><br><span class="line">    DP FLOPs: 2.9%</span><br><span class="line">    Packed: 0.0%</span><br><span class="line">    Scalar: 100.0%</span><br><span class="line">    x87 FLOPs: 0.0%</span><br><span class="line">    Non-FP: 96.2%</span><br><span class="line">    FP Arith/Mem Rd Instr. Ratio: 0.091</span><br><span class="line">    FP Arith/Mem Wr Instr. Ratio: 0.308</span><br></pre></td></tr></table></figure>

<p>针对<code>Vectorization: 23.7%</code>的建议</p>
<p>A significant fraction of floating point arithmetic instructions are scalar. Use <strong>Intel Advisor</strong> to see possible reasons why the code was not vectorized.</p>
<h3 id="SP-FLOPs"><a href="#SP-FLOPs" class="headerlink" title="SP FLOPs"></a>SP FLOPs</h3><p>The metric represents the percentage of single precision floating point operations from all operations executed by the applications. Use the metric for rough estimation of a SP FLOP fraction. If <strong>FMA vector instructions</strong> are used the metric may overcount.</p>
<h3 id="X87-FLOPs"><a href="#X87-FLOPs" class="headerlink" title="X87 FLOPs"></a>X87 FLOPs</h3><p>The metric represents the percentage of x87 floating point operations from all operations executed by the applications. Use the metric for rough estimation of an x87 fraction. If FMA vector instructions are used the metric may overcount.</p>
<p>X87是X86体系结构指令集的<strong>浮点相关子集</strong>。 它起源于8086指令的扩展，以可选的浮点协处理器的形式与相应的x86 cpus配合使用。 这些微芯片的名称在“ 87”中结尾。</p>
<h3 id="FP-Arith-Mem-Rd-Instr-Ratio"><a href="#FP-Arith-Mem-Rd-Instr-Ratio" class="headerlink" title="FP Arith&#x2F;Mem Rd Instr. Ratio"></a>FP Arith&#x2F;Mem Rd Instr. Ratio</h3><p>This metric represents the ratio between arithmetic floating point instructions and memory write instructions. A value less than 0.5 indicates unaligned data access for vector operations, which can negatively impact the performance of vector instruction execution.</p>
<p>小于0.5的值表示向量操作的未对齐数据访问，这可能会对矢量指令执行的性能产生负面影响。</p>
<h2 id="Step2-Hotspots"><a href="#Step2-Hotspots" class="headerlink" title="Step2 : Hotspots"></a>Step2 : Hotspots</h2><p>User-Mode Sampling只能采集单核的数据，来分析算法的优化。</p>
<p>Hardware Event-Based Sampling硬件时间采集能采集全部核心，但是要少于几秒钟？</p>
<p>这个硬件采集慢，而且到一半报错了，发生什么事了？<img src="https://pic.shaojiemike.top/img/20220724201411.png"></p>
<p><img src="https://pic.shaojiemike.top/img/20220726222036.png"></p>
<p>网上说是root权限的原因,但是我是用root运行的</p>
<p>反而用普通用户能正常跑Hardware Event-Based Sampling和微架构分析<br><img src="https://pic.shaojiemike.top/img/20220728204538.png"></p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p><img src="https://pic.shaojiemike.top/img/20220724202614.png"><br><img src="https://pic.shaojiemike.top/img/20220724204414.png"></p>
<p>手动向量化该区域。</p>
<p>核心时间是 $k*n^2$ 次绝对值和，取最大值</p>
<p>优化思路：</p>
<ol>
<li><p>手动向量化（假设一次处理p个）</p>
<p> 第一个n层取出 k个 <code>rebuilt[i*k+ki]</code> 重复读取到向量寄存器里，</p>
<p> 第二个n层取出k 个 连续的p个，到向量寄存器里。最后不足补0特殊处理，但是一般n都是4的倍数，可能可以不处理。8就要处理了。</p>
<p> 做向量fabs的结果缓存在k个向量寄存器里。</p>
<p> 再对这个k个向量寄存器做横向的向量最大值操作到一个向量寄存器。不足的补0(取最大值不影响)</p>
<p> 最后这一个向量寄存器做寄存器内求和，再加到 <code>chebyshevSum</code> 里.</p>
<p> 这样就实现了p个元素的向量操作。这样一趟共需要3*k个向量寄存器。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongzhiquan/p/3694858.html">手动数据预取</a></p>
<ol>
<li><code>__builtin_prefetch()</code></li>
</ol>
</li>
<li><p>手动循环展开形成计算访存流水</p>
<ol>
<li>怎么根据输入来规模来展开？</li>
</ol>
</li>
<li><p>分块</p>
</li>
</ol>
<h3 id="访存分析"><a href="#访存分析" class="headerlink" title="访存分析"></a>访存分析</h3><h2 id="github对应项目与赛题"><a href="#github对应项目与赛题" class="headerlink" title="github对应项目与赛题"></a>github对应项目与赛题</h2><h2 id="HPL-PL"><a href="#HPL-PL" class="headerlink" title="HPL-PL"></a>HPL-PL</h2><h3 id="复现机器"><a href="#复现机器" class="headerlink" title="复现机器"></a>复现机器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">Architecture:                    x86_64</span><br><span class="line">CPU op-mode(s):                  32-bit, 64-bit</span><br><span class="line">Byte Order:                      Little Endian</span><br><span class="line">Address sizes:                   46 bits physical, 48 bits virtual</span><br><span class="line">CPU(s):                          36</span><br><span class="line">On-line CPU(s) list:             0-35</span><br><span class="line">Thread(s) per core:              1</span><br><span class="line">Core(s) per socket:              18</span><br><span class="line">Socket(s):                       2</span><br><span class="line">NUMA node(s):                    2</span><br><span class="line">Vendor ID:                       GenuineIntel</span><br><span class="line">CPU family:                      6</span><br><span class="line">Model:                           79</span><br><span class="line">Model name:                      Intel(R) Xeon(R) CPU E5-2695 v4 @ 2.10GHz</span><br><span class="line">Stepping:                        1</span><br><span class="line">CPU MHz:                         1296.157</span><br><span class="line">CPU max MHz:                     3300.0000</span><br><span class="line">CPU min MHz:                     1200.0000</span><br><span class="line">BogoMIPS:                        4199.98</span><br><span class="line">Virtualization:                  VT-x</span><br><span class="line">L1d cache:                       1.1 MiB</span><br><span class="line">L1i cache:                       1.1 MiB</span><br><span class="line">L2 cache:                        9 MiB</span><br><span class="line">L3 cache:                        90 MiB</span><br></pre></td></tr></table></figure>

<h3 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc --version</span><br><span class="line">gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0</span><br><span class="line">$ gcc -std=c11 conway.c -o Conway</span><br><span class="line">$ ./Conway</span><br><span class="line">……</span><br><span class="line">Iter 997...</span><br><span class="line">Iter 998...</span><br><span class="line">Iter 999...</span><br><span class="line">136527.433000 ms</span><br></pre></td></tr></table></figure>

<h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><p>由于O3和并行会导致热点代码不可读</p>
<p>在可迭代优化的例子下，根据vtune最大化单核性能。</p>
<p>很明显不是计算密集的应用，怎么形成流水最大化带宽利用，划分<strong>重复利用元素</strong>提高Cache命中率是重点(向量化对计算加速明显)</p>
<p><img src="https://pic.shaojiemike.top/img/20221202184317.png"><br><img src="https://pic.shaojiemike.top/img/20221202184438.png"></p>
<ol>
<li>替换if <code>tmp[i][j] = (!(cnt^3))||((a[i][j]&amp;1)&amp;&amp;(!(cnt^4)));</code></li>
<li>去除中间不必要的拷贝</li>
<li>int 变 char</li>
<li><strong>OMP_PROC_BIND&#x3D;true</strong> 绑定线程到对应local处理器和对应local内存</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><ol>
<li>实验室同学黄业琦参加了HPC-PL全明星。想复现一下效果</li>
<li>之前Nvidia Nsight用得很爽， 想到vtune的访存优化部分和汇编对应的分析，使用的很少。想从提高计算流水和访存连续流水的角度结合vtune优化。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-03T16:00:00.000Z" title="7/3/2023, 4:00:00 PM">2023-07-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.595Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Network/">Network</a></span><span class="level-item">9 minutes read (About 1387 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/03/OutOfWork/4-devices/NAS/">NAS configuration</a></p><div class="content"><h2 id="购买的考虑点"><a href="#购买的考虑点" class="headerlink" title="购买的考虑点"></a>购买的考虑点</h2><p><a target="_blank" rel="noopener" href="https://post.smzdm.com/p/a5d23w98/">https://post.smzdm.com/p/a5d23w98/</a></p>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>建议至少是Intel的双核，ARM的还是不好使。单核性能太弱了。虚拟机，docker什么的就别想了。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>尽量8GB组双通道</p>
<h3 id="网口"><a href="#网口" class="headerlink" title="网口"></a>网口</h3><p>群晖的都是1Gb的老千兆(虽然我电脑，路由器网口也是)，但是威联通是2.5Gb的。</p>
<h3 id="M2-SSD加速"><a href="#M2-SSD加速" class="headerlink" title="M2.SSD加速"></a>M2.SSD加速</h3><p>是否支持SSD加速</p>
<h3 id="USB口是不是3-2Gen2"><a href="#USB口是不是3-2Gen2" class="headerlink" title="USB口是不是3.2Gen2"></a>USB口是不是3.2Gen2</h3><h2 id="群晖-DS220J-本体1200"><a href="#群晖-DS220J-本体1200" class="headerlink" title="群晖 DS220J (本体1200)"></a>群晖 DS220J (本体1200)</h2><p><img src="https://pic.shaojiemike.top/img/20220620103011.png"></p>
<p>PC公用路由器控制</p>
<p><a target="_blank" rel="noopener" href="http://find.synology.com/">http://find.synology.com</a></p>
<p>或者</p>
<p><a target="_blank" rel="noopener" href="http://synologynas:5000/">http://synologynas:5000</a></p>
<h3 id="QuickConnect"><a href="#QuickConnect" class="headerlink" title="QuickConnect"></a>QuickConnect</h3><p><a target="_blank" rel="noopener" href="https://quickconnect.to/shaojiemike">https://QuickConnect.to/shaojiemike</a></p>
<p><a target="_blank" rel="noopener" href="http://222.195.90.2/">http://222.195.90.2/</a> (能ping通，就能访问)</p>
<h3 id="电脑SMB直接访问"><a href="#电脑SMB直接访问" class="headerlink" title="电脑SMB直接访问"></a>电脑SMB直接访问</h3><p>\\192.168.31.247 (双斜杠，右键home有选项：映射网络驱动器)</p>
<p>\\tsjNas (需要在局域网下)</p>
<p>\\222.195.90.2&#x2F; (需要开启路由器的SMB（137-139，445）端口转发，否则能ping通，但是不能访问)</p>
<h2 id="网络配置脚本"><a href="#网络配置脚本" class="headerlink" title="网络配置脚本"></a>网络配置脚本</h2><p>使用开机wireguard脚本连接上网</p>
<ul>
<li>任意盘位置<code>/volume1/xxx</code>编辑脚本，赋予权限</li>
<li>群晖添加计划：点击任务计划。点击新增 -&gt; 触发的任务 -&gt; 用户定义的脚本(<strong>注意选择root用户权限</strong>)<ul>
<li>也可以选择写入启动文件中<code>vi /etc/rc</code></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置本地ssh eth0的222.195.90.2的高优先级，不至于开启wg断开ssh</span></span><br><span class="line">ip ro add default via 222.195.90.254 dev eth0 table eth0-table</span><br><span class="line"><span class="comment"># 为了使得除开本地ssh网络走wg，需要删除屏蔽default的wg的DHCP</span></span><br><span class="line">ip ro d default via 222.195.90.254 dev eth0  src 222.195.90.2 table main</span><br><span class="line"><span class="comment"># 防止服务端重启，Nas的wg客户端失联</span></span><br><span class="line">ip ro a 114.214.233.0/24 via 222.195.90.254 dev eth0  src 222.195.90.2 table main </span><br><span class="line"><span class="comment"># 启动wg</span></span><br><span class="line">wg-quick up wg1</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a target="_blank" rel="noopener" href="https://kb.synology.cn/zh-cn/DSM/help/DSM/StorageManager/disk?version=7#Drive">群晖文档</a></p>
<h3 id="删除失效网络硬盘"><a href="#删除失效网络硬盘" class="headerlink" title="删除失效网络硬盘"></a>删除失效网络硬盘</h3><p>无法直接取消，会报错”此连接不存在”，<a target="_blank" rel="noopener" href="https://pureinfotech.com/remove-network-drive-windows-10/">参考文章</a></p>
<p>需要删除两项<code>regedit</code>注册表<code>计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2\##10.0.0.12#homes</code> 和 <code>计算机\HKEY_CURRENT_USER\Network</code> 下对应的盘符即可。</p>
<h3 id="如果要利用空间"><a href="#如果要利用空间" class="headerlink" title="如果要利用空间"></a>如果要利用空间</h3><p>不要组RAID，通过添加<strong>存储池</strong>来使用每个盘。</p>
<p>RAID0也不要组，文件是打散的，虽然读和写块，但是是一个整体。坏一个就全坏了。</p>
<p>先配置存储池和存储空间</p>
<p><img src="https://pic.shaojiemike.top/img/20220714104716.png"></p>
<p>然后设置文件夹</p>
<p><img src="https://pic.shaojiemike.top/img/20220714104603.png"></p>
<p>再重新映射盘符即可</p>
<p><img src="https://pic.shaojiemike.top/img/20220714104912.png"></p>
<h3 id="停用与启用"><a href="#停用与启用" class="headerlink" title="停用与启用"></a>停用与启用</h3><p>若要激活硬盘：<br>已停用硬盘的分配状态会更改为未初始化，这表示此硬盘未安装 DSM，可以分配给存储池。请执行以下任何操作以激活硬盘：</p>
<ol>
<li>从硬盘插槽中移除硬盘，然后将其重新插入硬盘插槽。</li>
<li>重启系统。</li>
</ol>
<h3 id="图形化界面控制台很卡顿"><a href="#图形化界面控制台很卡顿" class="headerlink" title="图形化界面控制台很卡顿"></a>图形化界面控制台很卡顿</h3><p>原因内存和性能不行，建议升级DS220j+ 额外拓展内存</p>
<h3 id="电脑直接传输特别慢平均10M"><a href="#电脑直接传输特别慢平均10M" class="headerlink" title="电脑直接传输特别慢平均10M"></a>电脑直接传输特别慢平均10M</h3><p>群晖DS220j文件传输速度、外网访问速度、moment套件使用情况以及耗电情况。 最高写入速度为105MB&#x2F;S，最高读取速度为110MB&#x2F;S。</p>
<p>西数红盘 2T。 145MB&#x2F;s。</p>
<p>知乎评测: 局域网实际拷贝速度还不错，基本能达到千兆水平。下图是拷贝GB级文件（如电影）的截图，拷贝照片和音乐之类的小文件会慢不少，10MB大小的文件写入速度有60MB&#x2F;s左右，更小的文件就只有30MB&#x2F;s了。</p>
<p><img src="https://pic.shaojiemike.top/img/20220619223930.png"></p>
<p><img src="https://pic.shaojiemike.top/img/20220619221900.png"></p>
<h2 id="排查配置"><a href="#排查配置" class="headerlink" title="排查配置"></a>排查配置</h2><h3 id="网口-1"><a href="#网口-1" class="headerlink" title="网口"></a>网口</h3><p>路由器是Redmi AX3000wifi6 WAN口和LAN口都是千兆口 2000Mbit 3000Mbit</p>
<p>电脑的网口是B450 迫击炮的主板 千兆口</p>
<h3 id="网线"><a href="#网线" class="headerlink" title="网线"></a>网线</h3><p>电脑连路由器的的网线是cat.6A的</p>
<p>电脑连墙壁接口的是cat.5e的</p>
<p>网线，DS220J 送的是cat.5e</p>
<p><img src="https://pic.shaojiemike.top/img/20220619220956.png"></p>
<p>根据这篇<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136479005">知乎</a>，只要网线够短，cat.5e至少有5Gb&#x2F;s，一般都不是瓶颈。</p>
<h3 id="额外测试"><a href="#额外测试" class="headerlink" title="额外测试"></a>额外测试</h3><p>网线直连电脑和群晖的机器，用这根CAT.6A，速度也很慢。</p>
<p><img src="https://pic.shaojiemike.top/img/20220619232515.png"></p>
<p><img src="https://pic.shaojiemike.top/img/20220619232939.png"></p>
<p>(结果第二天就好多了，路由器平均50M，直连能跑满，感觉原因在于路由器缓存转发的问题，端口都是千兆的)<br><img src="https://pic.shaojiemike.top/img/20220620104536.png"><br><img src="https://pic.shaojiemike.top/img/20220620104452.png"></p>
<h2 id="其余测试"><a href="#其余测试" class="headerlink" title="其余测试"></a>其余测试</h2><h3 id="检测硬盘"><a href="#检测硬盘" class="headerlink" title="检测硬盘"></a>检测硬盘</h3><p>diskgenius</p>
<h3 id="命令行硬盘测速"><a href="#命令行硬盘测速" class="headerlink" title="命令行硬盘测速"></a>命令行硬盘测速</h3><p>控制面板 开启ssh</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2333 shaojiemike@192.168.233.242</span><br><span class="line">sudo -s</span><br><span class="line"></span><br><span class="line">sh-4.4# df -h</span><br><span class="line">Filesystem         Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/md0           2.3G  1.1G  1.2G  50% /</span><br><span class="line">devtmpfs           225M     0  225M   0% /dev</span><br><span class="line">tmpfs              243M   24K  243M   1% /dev/shm</span><br><span class="line">tmpfs              243M   15M  228M   7% /run</span><br><span class="line">tmpfs              243M     0  243M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs              243M  1.5M  241M   1% /tmp</span><br><span class="line">/dev/vg1/volume_1  1.8T  1.5T  289G  85% /volume1</span><br><span class="line">/dev/vg3/volume_3  4.0T  2.0G  4.0T   1% /volume3</span><br><span class="line">/dev/vg3/volume_4  4.0T   89M  4.0T   1% /volume4</span><br><span class="line"></span><br><span class="line"># 磁盘读性能</span><br><span class="line">sh-4.4# hdparm -Tt /dev/vg1/volume_1</span><br><span class="line"></span><br><span class="line">/dev/vg1/volume_1:</span><br><span class="line"> Timing cached reads:   1092 MB in  2.00 seconds = 545.67 MB/sec</span><br><span class="line"> Timing buffered disk reads: 456 MB in  3.03 seconds = 150.28 MB/sec</span><br><span class="line">sh-4.4# hdparm -Tt /dev/md4</span><br><span class="line"></span><br><span class="line">/dev/md4:</span><br><span class="line"> Timing cached reads:   1086 MB in  2.00 seconds = 542.89 MB/sec</span><br><span class="line"> Timing buffered disk reads: 838 MB in  3.00 seconds = 279.23 MB/sec</span><br><span class="line">sh-4.4# hdparm -Tt /dev/mapper/vg3-volume_4</span><br><span class="line"></span><br><span class="line">/dev/mapper/vg3-volume_4:</span><br><span class="line"> Timing cached reads:   1076 MB in  2.00 seconds = 537.13 MB/sec</span><br><span class="line"> Timing buffered disk reads: 592 MB in  3.01 seconds = 196.89 MB/sec</span><br><span class="line"></span><br><span class="line"> # 磁盘写性能</span><br><span class="line">sh-4.4# dd if=/dev/vg3/volume_3 bs=1024 count=1000000 of=/1Gb.file</span><br><span class="line">1000000+0 records in</span><br><span class="line">1000000+0 records out</span><br><span class="line">1024000000 bytes (1.0 GB, 977 MiB) copied, 13.0458 s, 78.5 MB/s</span><br><span class="line">sh-4.4# dd if=/dev/vg1/volume_1 bs=1024 count=1000000 of=/1Gb.file</span><br><span class="line">1000000+0 records in</span><br><span class="line">1000000+0 records out</span><br><span class="line">1024000000 bytes (1.0 GB, 977 MiB) copied, 18.837 s, 54.4 MB/s</span><br></pre></td></tr></table></figure>

<h3 id="群晖测网速"><a href="#群晖测网速" class="headerlink" title="群晖测网速"></a>群晖测网速</h3><p>群晖的docker里也有speedtest</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-07-03T16:00:00.000Z" title="7/3/2023, 4:00:00 PM">2023-07-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.619Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/network/">network</a></span><span class="level-item">19 minutes read (About 2782 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/03/Work/network/vpn/wireguard/">Wireguard</a></p><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>WireGuard 是由 Jason Donenfeld 等人用 C 语言编写的一个开源 VPN 协议，被视为下一代 VPN 协议，旨在解决许多困扰 IPSec&#x2F;IKEv2、OpenVPN 或 L2TP 等其他 VPN 协议的问题。它与 Tinc 和 MeshBird 等现代 VPN 产品有一些相似之处，即加密技术先进、配置简单。</li>
<li>从 2020 年 1 月开始，它已经并入了 Linux 内核的 5.6 版本，这意味着大多数 Linux 发行版的用户将拥有一个开箱即用的 WireGuard。</li>
<li>WireGuard 作为一个更先进、更现代的 VPN 协议，比起传统的 IPSec、OpenVPN 等实现，效率更高，配置更简单，并且已经合并入 Linux 内核，使用起来更加方便。</li>
</ul>
<h3 id="常见VPN方法比较"><a href="#常见VPN方法比较" class="headerlink" title="常见VPN方法比较"></a>常见VPN方法比较</h3><p><img src="https://pic.shaojiemike.top/img/20230411194711.png"></p>
<ul>
<li>wireguard 精簡、速度極快：<ul>
<li>只有 4000 行程式碼，是最精簡的 VPN 協議。对比下 OpenVPN，大约有 10 万行代码。</li>
</ul>
</li>
<li>WireGuard 利用内核空间处理来提升性能（更高吞吐和更低延迟），同时避免了不必要的内核和用户空间频繁上下文切换开销。</li>
</ul>
<h2 id="Wireguard客户端连接Debug"><a href="#Wireguard客户端连接Debug" class="headerlink" title="Wireguard客户端连接Debug"></a>Wireguard客户端连接Debug</h2><ul>
<li>首先，服务端的ip或者域名能ping通</li>
<li>其次端口确定开放<code>&gt; nc -z -v -u 4.shaojiemike.top 51822</code>,wg是udp</li>
<li>修改wg客户端配置文件，限制ip为wg设置的内网段，<code>AllowedIPs = 192.168.31.0/24，10.0.233.1/24</code>.然后<code>ping 192.168.31.1</code>测试</li>
<li>如果还不行，判断为wg的VPN包被中间网关识别并丢弃</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置详解<a target="_blank" rel="noopener" href="https://icloudnative.io/posts/wireguard-docs-practice/#2-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3">参考中文文档</a></p>
<h3 id="PersistentKeepalive"><a href="#PersistentKeepalive" class="headerlink" title="PersistentKeepalive"></a>PersistentKeepalive</h3><ul>
<li>一端位于 NAT 后面，另一端直接通过公网暴露</li>
<li>这种情况下，最简单的方案是：通过公网暴露的一端作为服务端，另一端指定服务端的公网地址和端口，然后通过 persistent-keepalive 选项维持长连接，让 NAT 记得对应的映射关系。<ul>
<li><code>[peer]</code>里设定字段 <code>PersistentKeepalive = 25</code>，表示每隔 25 秒发送一次 ping 来检查连接。</li>
</ul>
</li>
</ul>
<h3 id="AllowedIPs"><a href="#AllowedIPs" class="headerlink" title="AllowedIPs"></a>AllowedIPs</h3><p>虽然<code>AllowedIPs = 0.0.0.0/0</code>与<code>AllowedIPs = 0.0.0.0/1, 128.0.0.0/1</code>包含的都是全部的ip。</p>
<p>但是前者在iptable里为<code>default dev wg1</code>,后者为两条<code>0.0.0.0/1 dev wg1</code>和<code>128.0.0.0/1 dev wg1</code>。</p>
<p>由于路由的ip匹配遵循最长前缀匹配规则，如果路由表里原本有一条<code>efault dev eth0</code>。使用前者会导致混乱。但是使用后者，由于两条的优先级会更高，会屏蔽掉原本的default规则。</p>
<p>前者的iptable修改如下：（macbook上）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; ip route</span><br><span class="line">default via link#18 dev utun3</span><br><span class="line">default via 192.168.233.1 dev en0</span><br><span class="line">10.0.233.5/32 via 10.0.233.5 dev utun3</span><br><span class="line">224.0.0.0/4 dev utun3  scope link</span><br><span class="line">224.0.0.0/4 dev en0  scope link</span><br><span class="line">255.255.255.255/32 dev utun3  scope link</span><br><span class="line">255.255.255.255/32 dev en0  scope link</span><br></pre></td></tr></table></figure>

<p>后者的iptable修改如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ip route</span><br><span class="line">0.0.0.0/1 dev utun3  scope link</span><br><span class="line">default via 192.168.233.1 dev en0</span><br><span class="line">default via link#18 dev utun3</span><br><span class="line">10.0.233.5/32 via 10.0.233.5 dev utun3</span><br><span class="line">128.0.0.0/1 dev utun3  scope link</span><br><span class="line">224.0.0.0/4 dev en0  scope link</span><br><span class="line">224.0.0.0/4 dev utun3  scope link</span><br><span class="line">255.255.255.255/32 dev en0  scope link</span><br><span class="line">255.255.255.255/32 dev utun3  scope link</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>建议看<a target="_blank" rel="noopener" href="https://icloudnative.io/posts/wireguard-docs-theory/#1-wireguard-%E6%9C%AF%E8%AF%AD">WireGuard 教程：WireGuard 的工作原理</a> 和<a target="_blank" rel="noopener" href="https://icloudnative.io/posts/linux-routing-of-wireguard/">WireGuard 基础教程：wg-quick 路由策略解读</a>，详细解释了wg是如何修改路由表规则的。</p>
<h3 id="wireguard-运行原理以及配置文件"><a href="#wireguard-运行原理以及配置文件" class="headerlink" title="wireguard 运行原理以及配置文件"></a>wireguard 运行原理以及配置文件</h3><p>默认会产生51840的路由table，<code>ip rule</code>优先级较高。可以通过配置文件中添加<code>PostUp</code>来修改最后一个default的路由规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@snode6:/etc/wireguard<span class="comment"># cat wg0.conf</span></span><br><span class="line">[Interface]</span><br><span class="line">Address = 192.168.253.5/32,fd00::aaaa:5/128</span><br><span class="line">PrivateKey = eGj5skRAGJu8d………………1PVfu0lY=</span><br><span class="line"><span class="comment"># PublicKey = VWe0wBVztgX………………xd7/kZ2CVJlEvS51c=</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Table必须有，不然默认的还是会修改ip rule</span></span><br><span class="line">Table = 51820</span><br><span class="line"><span class="comment">#DNS = 1.1.1.1 #指定DNS服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动时运行： %i 是指wg的路由， 默认修改default， metric 一般不用指定</span></span><br><span class="line">PostUp   = /sbin/ip -4 route replace default dev %i table default metric 1</span><br><span class="line">PostUp   = /sbin/ip -6 route replace default dev %i table default metric 1</span><br><span class="line"><span class="comment">#down后运行</span></span><br><span class="line">PostDown = /sbin/ip -4 route delete  default dev %i table default metric 1</span><br><span class="line">PostDown = /sbin/ip -6 route delete  default dev %i table default metric 1</span><br></pre></td></tr></table></figure>

<p><code>PostUp</code>会产生下面的规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@snode6:/staff/shaojiemike<span class="comment"># ip ro show table default</span></span><br><span class="line">default dev wg0 scope <span class="built_in">link</span> metric 1</span><br></pre></td></tr></table></figure>

<h3 id="OpenVPN原理"><a href="#OpenVPN原理" class="headerlink" title="OpenVPN原理"></a>OpenVPN原理</h3><p>OpenVPN原理通过在main添加all规则来实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shaojiemike @ node5 in ~ [22:29:05]</span></span><br><span class="line">$ ip route show table main</span><br><span class="line">0.0.0.0/1 via 192.168.255.5 dev tun1</span><br></pre></td></tr></table></figure>

<h3 id="clash-TUN模式"><a href="#clash-TUN模式" class="headerlink" title="clash TUN模式"></a>clash TUN模式</h3><p>Macbook上的应用上的ClashX Pro的增强模式类似, 会添加如下配置，将基本所有流量代理（除开<code>0.0.0.0/8</code>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ip route</span><br><span class="line">1.0.0.0/8 via 198.18.0.1 dev utun3</span><br><span class="line">2.0.0.0/7 via 198.18.0.1 dev utun3</span><br><span class="line">4.0.0.0/6 via 198.18.0.1 dev utun3</span><br><span class="line">8.0.0.0/5 via 198.18.0.1 dev utun3</span><br><span class="line">16.0.0.0/4 via 198.18.0.1 dev utun3</span><br><span class="line">32.0.0.0/3 via 198.18.0.1 dev utun3</span><br><span class="line">64.0.0.0/2 via 198.18.0.1 dev utun3</span><br><span class="line">128.0.0.0/1 via 198.18.0.1 dev utun3 <span class="comment">#前面接受所有的ip，然后转换成198.18.0.1</span></span><br><span class="line">198.18.0.1/32 via 198.18.0.1 dev utun3 <span class="comment">#接受转换后的198.18.0.1，由于最长前缀匹配</span></span><br></pre></td></tr></table></figure>

<p>明显有代理死循环问题，如何解决？？？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shaojiemike@shaojiemikedeMacBook-Air ~/github/hugoMinos (main*) [10:59:32]</span><br><span class="line">&gt; ip route get 198.18.0.42</span><br><span class="line">198.18.0.42 via 198.18.0.1 dev utun3  src 198.18.0.1</span><br><span class="line">shaojiemike@shaojiemikedeMacBook-Air ~/github/hugoMinos (main*) [10:59:38]</span><br><span class="line">&gt; ip route get 198.18.0.1</span><br><span class="line">198.18.0.1 dev utun3  src 198.18.0.1</span><br></pre></td></tr></table></figure>

<h2 id="Wireguard-环境配置"><a href="#Wireguard-环境配置" class="headerlink" title="Wireguard 环境配置"></a>Wireguard 环境配置</h2><p>wireguard-go: 安装客户端 wg-quick up config<br>wireguard-tools: 安装服务端 wg</p>
<h2 id="Wireguard-常见命令"><a href="#Wireguard-常见命令" class="headerlink" title="Wireguard 常见命令"></a>Wireguard 常见命令</h2><ul>
<li>启动<code>wg-quick up wg1</code></li>
<li>关闭<code>wg-quick down wg1</code></li>
<li>查看状态 <code>wg</code>显示全部，或者<code>wg show wg1</code>显示wg1</li>
</ul>
<h2 id="wireguard开机启动"><a href="#wireguard开机启动" class="headerlink" title="wireguard开机启动"></a>wireguard开机启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable wg-quick@wg1 --now</span><br></pre></td></tr></table></figure>

<h2 id="使用wireguard-代理ipv6请求"><a href="#使用wireguard-代理ipv6请求" class="headerlink" title="使用wireguard 代理ipv6请求"></a>使用wireguard 代理ipv6请求</h2><ul>
<li><a target="_blank" rel="noopener" href="https://icloudnative.io/posts/wireguard-docs-practice/#ipv6">WireGuard 也支持 IPv6</a>。OpenWRT 服务端，当然要allowed ip <code>fd00::aaaa:5/128</code>、</li>
<li>注意：这是伪需求，为什么ipv6的流量需要走ipv6，不走wg，每个机器可以获得独立的公网ipv6，对于PT做种是很好的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">brainiac1<span class="comment"># cat wg-tsj.conf</span></span><br><span class="line">[Interface]</span><br><span class="line">PrivateKey = xxx</span><br><span class="line">ListenPort = 51828</span><br><span class="line">Address = 10.0.233.7/32, fd00::aaaa:5/128</span><br><span class="line">Table = 51820</span><br><span class="line"><span class="comment">#DNS = 1.1.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用iptable修改ipv6的路由规则</span></span><br><span class="line">PostUp   = /sbin/ip -4 route replace default dev %i table default metric 1</span><br><span class="line">PostUp   = /sbin/ip -6 route replace default dev %i table default metric 1</span><br><span class="line">PostDown = /sbin/ip -4 route delete  default dev %i table default metric 1</span><br><span class="line">PostDown = /sbin/ip -6 route delete  default dev %i table default metric 1</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line"><span class="comment">#AllowedIPs = 0.0.0.0/0,::/0</span></span><br><span class="line">PublicKey = xxx</span><br><span class="line">AllowedIPs = 0.0.0.0/1, 128.0.0.0/1</span><br><span class="line">Endpoint = 4.shaojiemike.top:51822</span><br><span class="line">PersistentKeepalive = 30</span><br></pre></td></tr></table></figure>

<h2 id="两次wireguard上网"><a href="#两次wireguard上网" class="headerlink" title="两次wireguard上网"></a>两次wireguard上网</h2><p>修改<code>sysctl.conf</code>文件的<code>net.ipv4.ip_forward</code>参数。其值为0,说明禁止进行IP转发；如果是1,则说明IP转发功能已经打开。</p>
<p>需要执行指令<code>sysctl -p</code> 后新的配置才会生效。</p>
<h3 id="两台机器的wireguard配置"><a href="#两台机器的wireguard配置" class="headerlink" title="两台机器的wireguard配置"></a>两台机器的wireguard配置</h3><p>注意中间需要NAT转换, 相当于把kunpeng机器的请求，隐藏成snode6的请求。在后一次wireguard转发时，就不会被过滤掉。</p>
<p><img src="https://pic.shaojiemike.top/img/20221031233739.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PostUp   = iptables -t nat -A POSTROUTING -s 10.1.0.0/24 ! -o %i -j MASQUERADE</span><br><span class="line">PostDown = iptables -t nat -D POSTROUTING -s 10.1.0.0/24 ! -o %i -j MASQUERADE || true</span><br></pre></td></tr></table></figure>

<h2 id="机器（Nas）使用Wireguard上网"><a href="#机器（Nas）使用Wireguard上网" class="headerlink" title="机器（Nas）使用Wireguard上网"></a>机器（Nas）使用Wireguard上网</h2><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>由于换了wg服务端，导致nas变成闭环的网络了。最后是通过群晖助手(Synology Assistant &#x2F; Web Assistant)的设置静态ip才连接上机器，但是iptable被设置乱了。</p>
<p>??? failure “Synology Assistant can not find nas”</p>
<p>静态连接上机器，首先在网页管理页面切换成DHCP（静态ip的DNS解析有误），iptable变成如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sh-4.4<span class="comment"># ip ro</span></span><br><span class="line">default via 222.195.90.254 dev eth0  src 222.195.90.2</span><br><span class="line">10.0.233.0/24 dev wg1  proto kernel  scope <span class="built_in">link</span>  src 10.0.233.3</span><br><span class="line">222.195.90.0/24 dev eth0  proto kernel  scope <span class="built_in">link</span>  src 222.195.90.2</span><br><span class="line"></span><br><span class="line">sh-4.4<span class="comment"># ip ro s t eth0-table</span></span><br><span class="line">222.195.90.0/24 via 222.195.90.2 dev eth0</span><br></pre></td></tr></table></figure>

<p>注意iptable的修改是实时生效的。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了让nas上网我们需要满足两点</p>
<ol>
<li>本地ssh eth0的222.195.90.2能访问机器(优先级更高)</li>
<li>其余网络走wg</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重要项如下</span></span><br><span class="line">sh-4.4<span class="comment"># ip rule</span></span><br><span class="line">3:      from 222.195.90.2 lookup eth0-table (ping 和 ssh ip 222.195.90.2的会使用这个规则)</span><br><span class="line">32766:  from all lookup main (ping 和 ssh 其余ip 比如wg的10.0.233.3的会使用这个规则)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 设置本地ssh eth0的222.195.90.2的高优先级，不至于开启wg断开ssh</span></span><br><span class="line"><span class="comment"># 使用命令添加： ip ro add default via 222.195.90.254 dev eth0 table eth0-table</span></span><br><span class="line">sh-4.4<span class="comment"># ip route show table eth0-table</span></span><br><span class="line">default via 222.195.90.254 dev eth0</span><br><span class="line">222.195.90.0/24 via 222.195.90.2 dev eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 为了使得除开本地ssh网络走wg，需要删除屏蔽default的wg的DHCP(如果提前删，导致机器ssh连接不上了，重新插拔网线，让DHCP重新配置)：</span></span><br><span class="line"><span class="comment"># 使用命令添加：ip ro d default via 222.195.90.254 dev eth0  src 222.195.90.2 table main，</span></span><br><span class="line"><span class="comment"># 3. 防止服务端重启，Nas的wg客户端失联</span></span><br><span class="line"><span class="comment"># 使用命令添加：ip ro a 114.214.233.0/24 via 222.195.90.254 dev eth0  src 222.195.90.2 table main </span></span><br><span class="line"><span class="comment"># 4. 测试： ping域名能正常运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其余方法：为了使得除开本地ssh网络走wg，也可以不删除，在DHCP的前面添加wg的网络通路</span></span><br><span class="line"><span class="comment"># 使用命令添加： ip ro add default dev wg1  proto kernel  scope link  src 10.0.233.3 table main</span></span><br><span class="line">sh-4.4<span class="comment"># ip r s t main</span></span><br><span class="line">default dev wg1  proto kernel  scope <span class="built_in">link</span>  src 10.0.233.3</span><br></pre></td></tr></table></figure>

<p>使用wg1配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sh-4.4<span class="comment"># cat /etc/wireguard/wg1.conf</span></span><br><span class="line">[Interface]</span><br><span class="line">PrivateKey = xxx</span><br><span class="line">ListenPort = xxx</span><br><span class="line">Address = 10.0.xxx.xxx/24</span><br><span class="line"></span><br><span class="line">Table = 51820</span><br><span class="line">PostUp   = /sbin/ip -4 route replace default dev %i table default metric 1</span><br><span class="line">PostDown = /sbin/ip -4 route delete  default dev %i table default metric 1</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = xxx</span><br><span class="line">AllowedIPs = 0.0.0.0/1, 128.0.0.0/1</span><br><span class="line">Endpoint = 114.xxx.xxx.xxx:xxx</span><br><span class="line">PersistentKeepalive = 25</span><br></pre></td></tr></table></figure>

<h3 id="问题：服务端重启，Nas的wg客户端失联"><a href="#问题：服务端重启，Nas的wg客户端失联" class="headerlink" title="问题：服务端重启，Nas的wg客户端失联"></a>问题：服务端重启，Nas的wg客户端失联</h3><p>要保留没有wg的时候访问服务端的eth0(114.214.233.xxx)的通路</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh-4.4<span class="comment"># ip ro s t main</span></span><br><span class="line">···</span><br><span class="line">114.214.233.0/24 via 222.195.90.254 dev eth0  src 222.195.90.2</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<h2 id="来自eth0的ssh与ping请求原路返回"><a href="#来自eth0的ssh与ping请求原路返回" class="headerlink" title="来自eth0的ssh与ping请求原路返回"></a>来自eth0的ssh与ping请求原路返回</h2><h3 id="源地址为自身IP的包走学校的路由器"><a href="#源地址为自身IP的包走学校的路由器" class="headerlink" title="源地址为自身IP的包走学校的路由器"></a>源地址为自身IP的包走学校的路由器</h3><p>目的：需要ssh和ping ipv4成功</p>
<p>修改<code>netplan</code>的配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shaojiemike @ node5 in ~ [22:29:11]</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/netplan/acsa.yaml</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    eno0:</span><br><span class="line">      dhcp4: <span class="literal">false</span></span><br><span class="line">      dhcp6: <span class="literal">false</span></span><br><span class="line">      accept-ra: <span class="literal">false</span></span><br><span class="line">      addresses:</span><br><span class="line">        - 202.38.73.217/24</span><br><span class="line">        - 2001:da8:d800:730::217/64</span><br><span class="line">      gateway4: 202.38.73.254</span><br><span class="line">      gateway6: 2001:da8:d800:730::1</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses:</span><br><span class="line">          - 202.38.64.1</span><br><span class="line">      routing-policy:</span><br><span class="line">        - from: 202.38.73.217</span><br><span class="line">          table: 1</span><br><span class="line">          priority: 2</span><br><span class="line">      routes:</span><br><span class="line">        - to: 0.0.0.0/0</span><br><span class="line">          via: 202.38.73.254</span><br><span class="line">          table: 1</span><br><span class="line"></span><br><span class="line"><span class="variable">$netplan</span> apply</span><br></pre></td></tr></table></figure>

<p><code>routing-policy</code>会产生</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shaojiemike @ node5 in ~ [22:30:33]</span></span><br><span class="line">$ ip rule</span><br><span class="line">0:      from all lookup <span class="built_in">local</span></span><br><span class="line">2:      from 202.38.73.217 lookup 1</span><br><span class="line">32766:  from all lookup main</span><br><span class="line">32767:  from all lookup default</span><br><span class="line"><span class="comment"># 也可以手动添加</span></span><br><span class="line">ip rule add from 202.38.73.217 table 1 pref 2</span><br><span class="line">或者</span><br><span class="line">ip rule add from 202.38.73.217 lookup 1 pref 2</span><br></pre></td></tr></table></figure>

<p>由于2优先级高，使得ping和ssh的返回信包(源地址为自身机器IP的包)走table1 规则，而不是走</p>
<p><code>routes</code>使得所有的table1都会走学校的路由器(202.38.73.254)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show table 1</span><br><span class="line">default via 202.38.73.254 dev eno0 proto static</span><br><span class="line"><span class="comment"># 也可以通过`ip route add`</span></span><br><span class="line">$ ip route add default via 202.38.73.254 dev eno0 proto static table 1</span><br></pre></td></tr></table></figure>

<h3 id="衍生问题：网络请求的源地址不是自己吗？怎么确定的"><a href="#衍生问题：网络请求的源地址不是自己吗？怎么确定的" class="headerlink" title="衍生问题：网络请求的源地址不是自己吗？怎么确定的"></a>衍生问题：网络请求的源地址不是自己吗？怎么确定的</h3><p>开启wg后，网络请求源地址变成了<code>10.0.33.2</code>。不是<code>202.38.73.217</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node5:/home/shaojiemike# ip ro</span><br><span class="line">10.0.33.0/24 dev wg2 proto kernel scope link src 10.0.33.2</span><br></pre></td></tr></table></figure>

<p>但是外界ping的是<code>202.38.73.217</code>。返回包交换所以会产生源地址为<code>202.38.73.217</code>的包</p>
<h2 id="wireguard-实现翻墙"><a href="#wireguard-实现翻墙" class="headerlink" title="wireguard 实现翻墙"></a>wireguard 实现翻墙</h2><ul>
<li>WireGuard 在国内网络环境下会遇到一个致命的问题：UDP 封锁&#x2F;限速。虽然通过 WireGuard 可以在隧道内传输任何基于 IP 的协议（TCP、UDP、ICMP、SCTP、IPIP、GRE 等），但 WireGuard 隧道本身是通过 UDP 协议进行通信的，而国内运营商根本没有能力和精力根据 TCP 和 UDP 的不同去深度定制不同的 QoS 策略，几乎全部采取一刀切的手段：<strong>对 UDP 进行限速甚至封锁。</strong></li>
<li>虽然对 UDP 不友好，但却无力深度检测 TCP 连接的真实性。</li>
<li>将 UDP 连接伪装成 TCP 连接不就蒙混过关了。目前支持将 UDP 流量伪装成 TCP 流量的主流工具是 udp2raw，但是有一款更强大的新工具： <a target="_blank" rel="noopener" href="https://icloudnative.io/posts/wireguard-over-tcp-using-phantun/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">Phantun</a>。</li>
</ul>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://icloudnative.io/posts/wireguard-over-tcp-using-phantun/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">WireGuard 基础教程：使用 Phantun 将 WireGuard 的 UDP 流量伪装成 TCP</a></p>
<p><a target="_blank" rel="noopener" href="https://nordvpn.com/zh-tw/blog/vpn-xieyi/">https://nordvpn.com/zh-tw/blog/vpn-xieyi/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.mozcp.com/wireguard-usage/">https://blog.mozcp.com/wireguard-usage/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-26T16:00:00.000Z" title="6/26/2023, 4:00:00 PM">2023-06-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.611Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Architecture/">Architecture</a></span><span class="level-item">13 minutes read (About 1908 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/26/Work/Programming/2.1-Assembly/assembly/">Assembly X86</a></p><div class="content"><p>关于X86 与 arm的寄存器的区别写在了arm那篇下</p>
<h2 id="IDA-analysis"><a href="#IDA-analysis" class="headerlink" title="IDA analysis"></a>IDA analysis</h2><p><img src="https://pic.shaojiemike.top/img/20211118221425.png"></p>
<h2 id="word-dword-qword"><a href="#word-dword-qword" class="headerlink" title="word&#x2F; dword&#x2F; qword"></a>word&#x2F; dword&#x2F; qword</h2><p>In x86 terminology&#x2F;documentation, a “word” is 16 bits </p>
<p>x86 word &#x3D; 2 bytes</p>
<p>x86 dword &#x3D; 4 bytes (double word)</p>
<p>x86 qword &#x3D; 8 bytes (quad word)</p>
<p>x86 double-quad or xmmword &#x3D; 16 bytes, e.g. movdqa xmm0, [rdi].</p>
<h2 id="常见X86汇编"><a href="#常见X86汇编" class="headerlink" title="常见X86汇编"></a>常见X86汇编</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a></p>
<p><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/">https://www.felixcloutier.com/x86/</a></p>
<p><a target="_blank" rel="noopener" href="https://officedaytime.com/simd512e/">https://officedaytime.com/simd512e/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">官方手册第一个4800页</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHR	    # Shift right (unsigned shift right)</span><br><span class="line">SAL       # Shift Arithmetically left (signed shift left)</span><br><span class="line">lea       # Load Effective Address, like mov but not change Flags, can store in any register, three opts</span><br><span class="line">imul      # Signed multiply</span><br><span class="line">movslq    # Move doubleword to quadword with sign-extension.</span><br><span class="line">movl $0x46dd0bfe, 0x804a1dc #将数值0x46dd0bfe放入0x804a1dc的地址中</span><br><span class="line">movl 0x46dd0bfe, 0x804a1dc #将0x46dd0bfe地址里的内容放入0x804a1dc地址中</span><br></pre></td></tr></table></figure>

<h3 id="lea-leaq"><a href="#lea-leaq" class="headerlink" title="lea &amp; leaq"></a>lea &amp; leaq</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea    -0xc(%ebp),%eax</span><br><span class="line">mov    %eax,0x8(%esp) #常见于scanf第三个参数，lea传结果写入地址</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// x is %rdi, result is %rax 就是计算地址，没有寻址操作</span><br><span class="line">lea    0x0(,%rdi,8),%rax //result = x * 8;</span><br><span class="line">lea    0x4b(,%rdi),%rax //result = x + 0x4b;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.shaojiemike.top/img/20220112101023.png"></p>
<h3 id="call-ret"><a href="#call-ret" class="headerlink" title="call &amp; ret"></a>call &amp; ret</h3><ul>
<li><code>Call 地址</code>：返回地址入栈（等价于“<code>Push %eip，mov 地址，%eip</code>”；注意eip指向下一条尚未执行的指令）</li>
<li><code>ret</code>：从栈中弹出地址，并跳到那个地址（<code>pop %eip</code>）</li>
</ul>
<h3 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h3><p><code>leave</code>：使栈做好返回准备，等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov %ebp，%esp</span><br><span class="line">pop %ebp</span><br></pre></td></tr></table></figure>

<h3 id="compare-order"><a href="#compare-order" class="headerlink" title="compare order"></a>compare order</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl   $0x5,$0x1</span><br><span class="line">jle    8048bc5 # Jump if Less or Equal 会触发，前面的 1&lt;=5</span><br></pre></td></tr></table></figure>
<h3 id="X86-load-store"><a href="#X86-load-store" class="headerlink" title="X86 load store"></a>X86 load store</h3><p>X86 不像 ARM有专门的<code>ldr</code>， <code>str</code>指令。是通过mov实现的</p>
<p><code>movswl (%rdi), %eax</code> sign-extending load from word (w) to dword (l). Intel <code>movsx eax, word [rdi]</code></p>
<h3 id="AVX"><a href="#AVX" class="headerlink" title="AVX"></a>AVX</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E36784_01/html/E36859/gntbd.html">https://docs.oracle.com/cd/E36784_01/html/E36859/gntbd.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vxorpd   XORPD</span><br><span class="line">Bitwise Logical XOR for Double-Precision Floating-Point Values</span><br><span class="line"></span><br><span class="line">vxorps   XORPS</span><br><span class="line">Bitwise Logical XOR for Single-Precision Floating-Point Values</span><br><span class="line"></span><br><span class="line">vmovaps  MOVAPS</span><br><span class="line">Move Aligned Packed Single-Precision Floating-Point Values</span><br></pre></td></tr></table></figure>

<h3 id="test-jump"><a href="#test-jump" class="headerlink" title="test &amp; jump"></a>test &amp; jump</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test    al, al</span><br><span class="line">jne     0x1000bffcc</span><br></pre></td></tr></table></figure>

<p>The <code>test</code> instruction performs a logical and of the two operands and sets the CPU flags register according to the result (which is not stored anywhere). If <code>al</code> is zero, the anded result is zero and that sets the Z flag. If <code>al</code> is nonzero, it clears the Z flag. (Other flags, such as Carry, oVerflow, Sign, Parity, etc. are affected too, but this code has no instruction testing them.)</p>
<p>The <code>jne</code> instruction alters EIP if the Z flag is not set. There is another mnemonic for the same operation called <code>jnz</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test   %eax,%eax</span><br><span class="line">jg     &lt;phase_4+0x35&gt; # eax &amp; eax &gt; 0 jump</span><br></pre></td></tr></table></figure>

<p>注意 <code>cmp</code>不等于 <code>test</code></p>
<p>The <code>TEST</code> operation sets the flags <code>CF</code> and <code>OF</code> to zero.</p>
<p>The <code>SF</code> is set to the MSB(most significant bit) of the result of the <code>AND</code>.</p>
<p>If the result of the <code>AND</code> is 0, the <code>ZF</code> is set to 1, otherwise set to 0.</p>
<h3 id="kinds-of-jump"><a href="#kinds-of-jump" class="headerlink" title="kinds of jump"></a>kinds of jump</h3><p><img src="https://pic.shaojiemike.top/img/20211111094314.png"></p>
<p>AT&amp;T syntax <code>jmpq *0x402390(,%rax,8)</code> into INTEL-syntax: <code>jmp [RAX*8 + 0x402390]</code>.</p>
<h3 id="ja-VS-jg"><a href="#ja-VS-jg" class="headerlink" title="ja VS jg"></a>ja VS jg</h3><p><code>JUMP IF ABOVE</code> AND <code>JUMP IF GREATER</code></p>
<p><code>ja</code> jumps if <code>CF = 0</code> and <code>ZF = 0</code> (unsigned Above: no carry and not equal)</p>
<p><code>jg</code> jumps if <code>SF = OF</code> and <code>ZF = 0</code> (signed Greater, excluding equal)</p>
<h3 id="FLAGS"><a href="#FLAGS" class="headerlink" title="FLAGS"></a>FLAGS</h3><p><code>cmp</code> performs a <code>sub</code> (but does not keep the result).</p>
<p><code>cmp eax, ebx</code></p>
<p>Let’s do the same by hand:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg     hex value   binary value  </span><br><span class="line"></span><br><span class="line">eax = 0xdeadc0de    ‭11011110101011011100000011011110‬</span><br><span class="line">ebx = 0x1337ca5e    ‭00010011001101111100101001011110‬</span><br><span class="line"> -    ----------</span><br><span class="line">res   0xCB75F680    11001011011101011111011010000000 </span><br></pre></td></tr></table></figure>

<p>The flags are set as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OF (overflow) : did bit 31 change      -&gt; no</span><br><span class="line">SF (sign)     : is bit 31 set          -&gt; yes</span><br><span class="line">CF (carry)    : is abs(ebx) &lt; abs(eax) -&gt; no  </span><br><span class="line">ZF (zero)     : is result zero         -&gt; no</span><br><span class="line">PF (parity)   : is parity of LSB even  -&gt; no (archaic)</span><br><span class="line">AF (Adjust)   : overflow in bits 0123  -&gt; archaic, for BCD only.</span><br></pre></td></tr></table></figure>

<h3 id="Carry-Flag"><a href="#Carry-Flag" class="headerlink" title="Carry Flag"></a>Carry Flag</h3><p><strong>Carry Flag</strong> is a flag set when:</p>
<p>a) two unsigned numbers were added and the result is larger than “capacity” of register where it is saved.</p>
<p>Ex: we wanna add two 8 bit numbers and save result in 8 bit register. In your example: 255 + 9 &#x3D; 264 which is more that 8 bit register can store. So the value “8” will be saved there (264 &amp; 255 &#x3D; 8) and CF flag will be set.</p>
<p>b) two unsigned numbers were subtracted and we subtracted the bigger one from the smaller one.</p>
<p>Ex: 1-2 will give you 255 in result and CF flag will be set.</p>
<p><strong>Auxiliary Flag</strong> is used as CF but when working with BCD. So AF will be set when we have overflow or underflow on in BCD calculations. For example: considering 8 bit ALU unit, Auxiliary flag is set when there is carry from 3rd bit to 4th bit i.e. carry from lower nibble to higher nibble. (Wiki link)</p>
<p><strong>Overflow Flag</strong> is used as CF but when we work on signed numbers.</p>
<p>Ex we wanna add two 8 bit signed numbers: 127 + 2. the result is 129 but it is too much for 8bit signed number, so OF will be set.</p>
<p>Similar when the result is too small like -128 - 1 &#x3D; -129 which is out of scope for 8 bit signed numbers.</p>
<h2 id="register-signed-unsigned"><a href="#register-signed-unsigned" class="headerlink" title="register signed &amp; unsigned"></a>register signed &amp; unsigned</h2><p><strong>Positive or negative</strong><br>The CPU does not know (or care) whether a number is positive or negative. The only person who knows is you. If you test <strong>SF</strong> and <strong>OF</strong>, then you treat the number as signed. If you only test <strong>CF</strong> then you treat the number as unsigned.<br>In order to help you the processor keeps track of all flags at once. You decide which flags to test and by doing so, you decide how to interpret the numbers.</p>
<h2 id="register-multiply"><a href="#register-multiply" class="headerlink" title="register multiply"></a>register multiply</h2><p>The computer makes use of <strong>binary multiplication(AND)</strong>, followed by <strong>bit shift</strong> (in the direction in which the multiplication proceeds), followed by <strong>binary addition(OR)</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1100100</span><br><span class="line">0110111</span><br><span class="line">=======</span><br><span class="line">0000000</span><br><span class="line">-1100100</span><br><span class="line">--1100100</span><br><span class="line">---0000000</span><br><span class="line">----1100100</span><br><span class="line">-----1100100</span><br><span class="line">------1100100</span><br><span class="line">==============</span><br><span class="line">1010101111100</span><br><span class="line"></span><br><span class="line">100 = 1.1001 * 2^6</span><br><span class="line">55  = 1.10111* 2^5</span><br><span class="line">100 * 55 -&gt; 1.1001 * 1.10111 * 2^(6+5)</span><br></pre></td></tr></table></figure>

<p>for more:</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3060064/how-computer-multiplies-2-numbers">How computer multiplies 2 numbers?</a><br>And:<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_multiplier">Binary multiplier - Wikipedia</a></p>
<h2 id="Memory-and-Addressing-Modes"><a href="#Memory-and-Addressing-Modes" class="headerlink" title="Memory and Addressing Modes"></a>Memory and Addressing Modes</h2><h3 id="声明静态代码区域"><a href="#声明静态代码区域" class="headerlink" title="声明静态代码区域"></a>声明静态代码区域</h3><p><strong>DB, DW, and DD</strong> can be used to declare one, two, and four byte data locations,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 基本例子</span><br><span class="line">.DATA		</span><br><span class="line">var	DB <span class="number">64</span>  	; Declare a byte, referred to as location var, containing the value <span class="number">64.</span></span><br><span class="line">var2	DB ?	; Declare an uninitialized byte, referred to as location var2.</span><br><span class="line">DB <span class="number">10</span>	; Declare a byte with no label, containing the value <span class="number">10.</span> Its location is var2 + <span class="number">1.</span></span><br><span class="line">X	DW ?	; Declare a <span class="number">2</span>-byte uninitialized value, referred to as location X.</span><br><span class="line">Y	DD <span class="number">30000</span>    	; Declare a <span class="number">4</span>-byte value, referred to as location Y, initialized to <span class="number">30000.</span></span><br></pre></td></tr></table></figure>

<p>数组的声明，The <strong>DUP</strong> directive tells the assembler to duplicate an expression a given number of times. For example, 4 DUP(2) is equivalent to 2, 2, 2, 2.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Z	DD 1, 2, 3	; Declare three 4-byte values, initialized to 1, 2, and 3. The value of location Z + 8 will be 3.</span><br><span class="line">bytes  	DB 10 DUP(?)	; Declare 10 uninitialized bytes starting at location bytes.</span><br><span class="line">arr	DD 100 DUP(0)    	; Declare 100 4-byte words starting at location arr, all initialized to 0</span><br><span class="line">str	DB &#x27;hello&#x27;,0	; Declare 6 bytes starting at the address str, initialized to the ASCII character values for hello and the null (0) byte.</span><br></pre></td></tr></table></figure>

<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>32位X86机器寻址支持</p>
<ol>
<li>最多支持32位寄存器和32位有符号常数相加</li>
<li>其中一个寄存器可以再乘上 2，4，8</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># right</span><br><span class="line">mov eax, [ebx]	; Move the 4 bytes in memory at the address contained in EBX into EAX</span><br><span class="line">mov [var], ebx	; Move the contents of EBX into the 4 bytes at memory address var. (Note, var is a 32-bit constant).</span><br><span class="line">mov eax, [esi-4]	; Move 4 bytes at memory address ESI + (-4) into EAX</span><br><span class="line">mov [esi+eax], cl	; Move the contents of CL into the byte at address ESI+EAX</span><br><span class="line">mov edx, [esi+4*ebx]    	; Move the 4 bytes of data at address ESI+4*EBX into EDX</span><br><span class="line"></span><br><span class="line"># wrong and reason</span><br><span class="line">mov eax, [ebx-ecx]	; Can only add register values</span><br><span class="line">mov [eax+esi+edi], ebx    	; At most 2 registers in address computation</span><br></pre></td></tr></table></figure>

<h3 id="指定存储在地址的数据大小"><a href="#指定存储在地址的数据大小" class="headerlink" title="指定存储在地址的数据大小"></a>指定存储在地址的数据大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov BYTE PTR [ebx], 2	; Move 2 into the single byte at the address stored in EBX.</span><br><span class="line">mov WORD PTR [ebx], 2	; Move the 16-bit integer representation of 2 into the 2 bytes starting at the address in EBX.</span><br><span class="line">mov DWORD PTR [ebx], 2    	; Move the 32-bit integer representation of 2 into the 4 bytes starting at the address in EBX.</span><br></pre></td></tr></table></figure>

<h2 id="汇编寄存器顺序，作用方向"><a href="#汇编寄存器顺序，作用方向" class="headerlink" title="汇编寄存器顺序，作用方向"></a>汇编寄存器顺序，作用方向</h2><p>这和汇编器语法有关：</p>
<h3 id="X86-instructions"><a href="#X86-instructions" class="headerlink" title="X86 instructions"></a>X86 instructions</h3><p>For instructions with two operands, the first (lefthand) operand is the <strong>source</strong> operand, and the second (righthand) operand is the <strong>destination</strong> operand (that is, source-&gt;destination).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx — copy the value in ebx into eax</span><br><span class="line">add eax, 10 — EAX ← EAX + 10</span><br></pre></td></tr></table></figure>

<h3 id="AT-T-syntax"><a href="#AT-T-syntax" class="headerlink" title="AT&amp;T syntax"></a>AT&amp;T syntax</h3><p>AT&amp;T Syntax is an assembly syntax used in UNIX environments, that originates from <strong>AT&amp;T Bell Labs</strong>. It is descended from the MIPS assembly syntax. (AT&amp;T, American Telephone &amp; Telegraph)</p>
<p>AT&amp;T Syntax is an assembly syntax used mostly in <strong>UNIX</strong> environments or by tools like <strong>gcc</strong> that originated in that environment.</p>
<p><img src="https://pic.shaojiemike.top/img/20211007205016.png"></p>
<p>语法特点：<a target="_blank" rel="noopener" href="https://stackoverflow.com/tags/att/info">https://stackoverflow.com/tags/att/info</a></p>
<p>需要注意的：</p>
<ol>
<li>Operands are in <strong>destination-last</strong> order</li>
<li><strong>Register</strong> names are prefixed with <code>%</code>, and <strong>immediates</strong> are prefixed with <code>$</code><ol>
<li><code>sub $24, %rsp</code> reserves 24 bytes on the stack.</li>
</ol>
</li>
<li><strong>Operand-size</strong> is indicated with a <code>b/w/l/q</code> suffix on the mnemonic<ol>
<li><code>addb $1, byte_table(%rdi)</code> increment a byte in a static table.</li>
<li>The mov suffix (b, w, l, or q) indicates how many bytes are being copied (1, 2, 4, or 8 respectively)</li>
<li><img src="https://i.loli.net/2021/10/22/DQeC8qVm3s9MKzR.png"></li>
</ol>
</li>
<li><code>imul $13, 16(%rdi, %rcx, 4),  %eax</code> 32-bit load from <code>rdi + rcx&lt;&lt;2 + 16</code>, multiply that by 13, put the result in <code>%eax</code>. <strong>Intel</strong> <code>imul eax, [16 + rdi + rcx*4], 13</code>.</li>
<li><code>movswl (%rdi), %eax</code> sign-extending load from word (w) to dword (l). Intel <code>movsx eax, word [rdi]</code>.</li>
</ol>
<h3 id="Intel-syntax-used-in-Intel-AMD-manuals"><a href="#Intel-syntax-used-in-Intel-AMD-manuals" class="headerlink" title="Intel syntax  (used in Intel&#x2F;AMD manuals)."></a>Intel syntax  (used in Intel&#x2F;AMD manuals).</h3><p>The Intel assembler(icc,icpc我猜) uses the <strong>opposite</strong> order (destination&lt;-source) for operands.<br><img src="https://pic.shaojiemike.top/img/20211007204947.png"></p>
<p>语法特点： <a target="_blank" rel="noopener" href="https://stackoverflow.com/tags/intel-syntax/info">https://stackoverflow.com/tags/intel-syntax/info</a></p>
<h3 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beq rs1, rs2, Label #RISC-V</span><br><span class="line">SW rs2, imm(rs1)  # Mem[rs1+imm]=rs2 ,汇编将访存放在最后</span><br><span class="line">add rd, rs1, rs2  # rd = rs1 + rs2</span><br></pre></td></tr></table></figure>

<h3 id="反汇编器"><a href="#反汇编器" class="headerlink" title="反汇编器"></a>反汇编器</h3><p>但是这个语法不是很重要，因为decompiler有选项控制语法</p>
<p><code>objdump</code> has <code>-Mintel</code> flag, <code>gdb</code> has <code>set disassembly-flavor intel</code> option.</p>
<p> <code>gcc -masm=intel -S</code> or <code>objdump -drwC -Mintel</code>.</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">https://www.cs.virginia.edu/~evans/cs216/guides/x86.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-22T16:00:00.000Z" title="6/22/2023, 4:00:00 PM">2023-06-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.615Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/network/">network</a></span><span class="level-item">4 minutes read (About 668 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/22/Work/network/0-basic/localhost/">Localhost</a></p><div class="content"><h2 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h2><ul>
<li>环回地址，是指不离开主机的数据包(也就是说，这些数据包不会通过外部网络接口)。<ul>
<li>任何发往环回地址的数据包，其处理都在 TCP&#x2F;IP 协议叠的链路层中实现的。这些数据包不会向下交由网卡（NIC）或者设备驱动程序处理，既不应在电脑系统以外出现，也不可经路由器转发。</li>
<li>环回地址是主机用于向自身发送通信的一个特殊地址，帮助我们在同一台主机上实现client和server的功能。</li>
<li>运用本地环回机制，便可在主机上运行网络服务，期间不须安装实体网络接口卡，也无须将该服务开放予主机所在网络。</li>
</ul>
</li>
</ul>
<h2 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h2><ul>
<li>localhost 是一个别名，用于指代为环回保留的 IP 地址(环回地址)。<ul>
<li>IPv4使用 A 类地址的最后一个块（从 127.0.0.1 到 127.255.255）<ul>
<li>发送到这些地址（127.0.0.1 到 127.255.255.255）的所有数据包都会返回本机。</li>
</ul>
</li>
<li>而IPv6保留第一个（0:0:0:0:0:0:0:1 - 或 : :1）作为其环回地址。</li>
</ul>
</li>
</ul>
<h2 id="0-0-0-0-任意ip"><a href="#0-0-0-0-任意ip" class="headerlink" title="0.0.0.0 任意ip"></a>0.0.0.0 任意ip</h2><ul>
<li>0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的IPV4地址。</li>
<li>监听0.0.0.0的端口，就是监听本机中所有IP的端口。</li>
<li>0.0.0.0是不能被ping通的。</li>
</ul>
<h2 id="localhost-与-127-0-0-1区别"><a href="#localhost-与-127-0-0-1区别" class="headerlink" title="localhost 与 127.0.0.1区别"></a>localhost 与 127.0.0.1区别</h2><ul>
<li>localhost(本地主机)不是专门指 127.0.0.1，而是指为环回保留的整个 IP 地址范围。<ul>
<li>注意你不能总是使用127.0.0.1进行环回。<ul>
<li>仅限 IPv6 的系统不会响应此类请求，因为它们的 localhost 链接到地址::1。</li>
<li>修改<code>/etc/hosts</code>文件即可修改环回的地址。但是十分不建议这样做，很可能导致本地服务崩溃</li>
</ul>
</li>
</ul>
</li>
<li>请求的发送方式不同???<ul>
<li>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</li>
<li>localhost不会解析成ip，也不会占用网卡、网络资源。一般设置程序时本地服务用localhost是最好的。</li>
</ul>
</li>
</ul>
<h2 id="如何将环回地址某端口上的服务映射到外部网络接口"><a href="#如何将环回地址某端口上的服务映射到外部网络接口" class="headerlink" title="如何将环回地址某端口上的服务映射到外部网络接口"></a>如何将环回地址某端口上的服务映射到外部网络接口</h2><ul>
<li>可以使用ssh转发<code>ssh -L 1313:localhost:8020 shaojiemike@202.38.72.23</code>将服务器<code>localhost:1313</code>上的内容转发到本地8020端口</li>
<li><code>hugo server -D -d ~/test/public</code>默认会部署在localhost上<ul>
<li>解决办法<code>hugo server --bind=202.38.72.23 --baseURL=http://202.38.72.23:1313 -D -d ~/test/public</code></li>
</ul>
</li>
</ul>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://blog.nnwk.net/article/107">https://blog.nnwk.net/article/107</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-20T16:00:00.000Z" title="6/20/2023, 4:00:00 PM">2023-06-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.623Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Values/">Values</a></span><span class="level-item">3 minutes read (About 479 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/20/diary/4-viewOnOthers/4.1-game/">UnimportantView: Game</a></p><div class="content"><h2 id="如何筛选适合的游戏"><a href="#如何筛选适合的游戏" class="headerlink" title="如何筛选适合的游戏"></a>如何筛选适合的游戏</h2><p>现状：游玩时间少，时间碎片化，无规律</p>
<ul>
<li>游玩体验一定要舒适<ul>
<li>体验的主线内容：真实的幻想世界<ul>
<li>轻松快乐的主线剧情体验，(-20 ~ 35) <ul>
<li>一起提供代入感和沉浸式的游玩体验</li>
<li>无剧情该项为0</li>
<li>扣分：枯燥拖沓的演出(-10)</li>
<li>加分：刺激有趣的剧情表演(+10)、诙谐的台本(+5),令人有所感悟的主线故事(+15)、动容的NPC故事(+5)</li>
</ul>
</li>
<li>有趣新颖的玩法(30)<ul>
<li>新鲜玩法(15)</li>
<li>眼前一亮的细节(5)</li>
<li>足够深的游戏内容，来随意探索;(10)<ul>
<li>或者足够精致宏大的单机主线内容(FF,大镖客2)</li>
</ul>
</li>
</ul>
</li>
<li>精致华丽的美术(30)<ul>
<li>交互界面UI(3)</li>
<li>开放世界风景(7) 震撼华丽的大场景可以弥补角色喜爱塑造的缺失</li>
<li>令人喜爱的角色(15)</li>
<li>动听的音乐(5)</li>
</ul>
</li>
</ul>
</li>
<li>日常周常体验(40)<ul>
<li>耗时&#x2F;门槛(20)：<ul>
<li>无需投入大量前期时间才能正常体验<ul>
<li>经验训练技巧</li>
<li>前置任务过多</li>
</ul>
</li>
<li>没有强制的任务指标来限制&#x2F;延长在线时长</li>
</ul>
</li>
<li>收获感(10)：投入有回报(货币)、提升(数值)</li>
<li>新鲜感(10)：有Rougelike元素，避免无聊</li>
</ul>
</li>
<li>手游根据逼氪程度减分<ul>
<li>200以上减5；1000以上减10</li>
</ul>
</li>
</ul>
</li>
<li>适合的类型：<ul>
<li>合家欢小游戏(主玩法，轻竞技)：蛋仔、任系游戏</li>
<li>主剧情的单机RPG游戏</li>
<li>主美术的二次元轻度手游</li>
</ul>
</li>
<li>不适合的类型：<ul>
<li>有紧迫任务目标的游戏（大量限时任务的网游）</li>
<li>快乐建立在胜负上的竞技类游戏(PVP游戏)</li>
</ul>
</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><!-- ![](https://pic.shaojiemike.top/img/20230501102804.png) -->

<p><img src="https://pic.shaojiemike.top/img/20230621212739.png"></p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-15T16:00:00.000Z" title="6/15/2023, 4:00:00 PM">2023-06-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-11-15T09:17:16.603Z" title="11/15/2023, 9:17:16 AM">2023-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">13 minutes read (About 1920 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/15/Work/HPC/0-overview/optimizationOutline/">Optimization Outline</a></p><div class="content"><h2 id="Sun’s-常见超线性加速的情况"><a href="#Sun’s-常见超线性加速的情况" class="headerlink" title="Sun’s 常见超线性加速的情况"></a>Sun’s 常见超线性加速的情况</h2><p><a target="_blank" rel="noopener" href="http://www.cs.iit.edu/%7Esun/cs546.html#materials">http://www.cs.iit.edu/%7Esun/cs546.html#materials</a></p>
<p><a target="_blank" rel="noopener" href="https://annals-csis.org/Volume_8/pliks/498.pdf">https://annals-csis.org/Volume_8/pliks/498.pdf</a></p>
<p>Superlinear Speedup in HPC Systems: why and when?</p>
<ol>
<li>Cache size increased 多核的cache总size增加<ol>
<li>在大多数的并行计算系统中，每个处理器都有少量的高速缓存，当某一问题执行在大量的处理器上，而所需要的数据都放在高速缓存中时，由于数据的复用，总的计算时间趋于减少，如果由于这种高速缓存效应补偿了由于通信造成的额外开销，就有可能造成超线性加速比。</li>
</ol>
</li>
<li>Overhead reduced 锁减少，粒度变小</li>
<li>Latency hidden 数据预取更多了</li>
<li>Randomized algorithms<ol>
<li>在某些并行搜索算法中，允许不同的处理器在不同的分支方向上同时搜索，当某一处理器一旦迅速的找到了解，它就向其余的处理器发出中止搜索的信号，这就会提前取消那些在串行算法中所做的无谓的搜索分枝，从而出现超线性加速比现象</li>
</ol>
</li>
<li>Mathematical inefficiency of the serial algorithm 改并行算法</li>
<li>Higher memory consumption access cost for in sequantial processing</li>
</ol>
<h2 id="应用优化前提"><a href="#应用优化前提" class="headerlink" title="应用优化前提"></a>应用优化前提</h2><ol>
<li><p>迭代进行 ：分析程序最大热点(perf,vtune工具)-&gt;优化该热点—&gt;分析程序最大热点-&gt;……</p>
</li>
<li><p>自顶向下分析优化程序热点的思路</p>
<ol>
<li>全局算法的调研、理解、总体设计改进</li>
<li>程序任务划分，并行各部分模块</li>
<li>仔细分析热点的kernel循环</li>
</ol>
</li>
<li><p>基本了解物理数学背景公式</p>
</li>
<li><p>阅读代码，明白实现</p>
<ol>
<li>从main函数开始看的都是大撒比，没错，说的就是我</li>
<li>带着问题看，才能快速抓住重点</li>
</ol>
</li>
<li><p>建议串行直接用vtune判断算法热点和时间</p>
<ol>
<li>粗略判断热点</li>
<li>加入<strong>各部分热点的时间输出</strong> (必需的:积极的正向反馈，会提高积极性和理清思路)</li>
</ol>
</li>
<li><p>寻找合适的<strong>大例子</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line">itime = omp_get_wtime();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nTime taken is %f&quot;</span>,omp_get_wtime()-itime);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行n次求得平均值; 或者对不同大小的例子在不同参数下的效果拉图对比<ol>
<li>单机不同数量多核，同机器的不同编译器，不同核心kernel&#x2F;CPU</li>
<li>warmup&#x3D;10 loop&#x3D;50 先热身10次，然后循环10次</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./SLIC_0805_3 |tee 3.log &amp;&amp; ./SLIC_0805_3 |tee 3.log &amp;&amp; ./SLIC_0805_3 |tee 3.log</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.shaojiemike.top/img/20210909155842.png"><br>7. 每次优化基给予正确性的评价，并对负优化进行解释。</p>
<ol>
<li>查看汇编</li>
<li>基本并行加速实现后，vtune检查<strong>访存</strong>,或者用Intel advisor的Roofline Model来分析。</li>
<li>新函数用 <code>utils.cpp</code>和 <code>utils.h</code>写</li>
</ol>
<h2 id="应用类型及其常见优化"><a href="#应用类型及其常见优化" class="headerlink" title="应用类型及其常见优化"></a>应用类型及其常见优化</h2><ol>
<li>计算密集<ol>
<li>采用适合并行平台的算法</li>
<li>CPU核数利用率<ol>
<li>多进程<ol>
<li>进程池动态调度</li>
</ol>
</li>
<li>多线程(对于特别小的例子，一个cpu的核就够用了)<ol>
<li>线程亲和性</li>
<li>线程动态调度</li>
</ol>
</li>
</ol>
</li>
<li>向量化率(提高单次计算量)SIMD<ol>
<li>自动向量化提升有限吗？怎么写出好让编译器自动向量化的代码<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyl910/?type=blog">https://blog.csdn.net/zyl910/?type=blog</a> SIMD测试比较</li>
</ol>
</li>
<li>pragma omp parallel for simd</li>
<li>循环展开，凑够无依赖计算，填满流水线avx512的宽度(8个float)</li>
<li>intrins接口手动向量化</li>
<li>注意边界，不足8个单独计算</li>
<li>手动向量化avx2一般会快一些</li>
<li><img src="https://pic.shaojiemike.top/img/20211001225407.png"></li>
</ol>
</li>
<li>降低计算量技巧<ol>
<li><a target="_blank" rel="noopener" href="https://developer.51cto.com/article/710503.html">其他各种小技巧</a></li>
<li>使用掩码代替分支判断<ol>
<li>增A：<code>|A</code> 删A：<code>&amp;（~A）</code>判断：<code>&amp;A!=0</code></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyl910/article/details/7345655">https://blog.csdn.net/zyl910/article/details/7345655</a></li>
</ol>
</li>
<li>替换if <code>tmp[i][j] = (!(cnt^3))||((a[i][j]&amp;1)&amp;&amp;(!(cnt^4)));</code></li>
<li>使用乘法代替除法</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35580883/article/details/78318142">位运算实现整数绝对值</a><ol>
<li><a target="_blank" rel="noopener" href="http://www.cppblog.com/SmartPtr/archive/2007/07/05/27552.aspx">位运算实现浮点数绝对值</a></li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cncnlg/article/details/42784739">位运算实现整数MaxMin</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1802321">位运算求二进制内1的个数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lady_killer9/article/details/88067317">位运算代替乘除2运算</a></li>
<li><img src="https://pic.shaojiemike.top/img/20211001230813.png"></li>
<li>重新划分去除乘除，小代价是归约一下sigma<img src="https://pic.shaojiemike.top/img/20211001231708.png"></li>
</ol>
</li>
<li>混合精度(降低部分精度，降低计算量)</li>
<li>数据重用(不重复计算，降低计算量)</li>
</ol>
</li>
<li>访存密集<ol>
<li>vtune memory access分析，提高cpu访存带宽，优化2CPU通信<ol>
<li>store与load比stream慢很多<ol>
<li>原因store是将要写的数据load到缓存里，然后修改。而stream是直接写内存。</li>
</ol>
</li>
<li><img src="https://pic.shaojiemike.top/img/B(EWVUD74G@%60$H8%7BT)J5GBR.png"></li>
<li><img src="https://pic.shaojiemike.top/img/Z%606%5BUK5MOU@%60BCQBKRE9UJR.png"></li>
</ol>
</li>
<li>计算分块<ol>
<li>根据L1的大小设置块大小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MiB = Mebibyte = 1024 KB,</span><br><span class="line">KiB = Kibibyte = 1024 Bytes,</span><br><span class="line">MB = Megabyte = 1,000 KB,</span><br><span class="line">KB = Kilobyte = 1,000 Bytes</span><br></pre></td></tr></table></figure></li>
<li>double 8 bytes</li>
</ol>
</li>
<li>改变数据结构优化访存(提高cache命中率)<ol>
<li>不合理的数据结构定义，导致数据存储不连续。通过改变数据结构，通过内存指针访问连续地址</li>
</ol>
</li>
<li>强制使用静态链接库glibc</li>
<li>访存局部性原理(提高cache命中率)<ol>
<li>c语言先行后列</li>
<li>循环拆分、循环重组</li>
</ol>
</li>
<li>根据cache空间，以及cache策略，进行cache数据预取，</li>
<li>计算融合(减少访存次数)<ol>
<li>计算结果及时使用，去除中间结果的存储访问时间</li>
<li>将多个循环整合为一个</li>
</ol>
</li>
<li>对于对同一个地址的连续读写依赖，采取pingpong-buffer来两个分治</li>
<li>申请空间<ol>
<li><img src="https://pic.shaojiemike.top/img/20210828120805.png"></li>
</ol>
</li>
</ol>
</li>
<li>负载均衡(并行划分)<ol>
<li><img src="https://pic.shaojiemike.top/img/20210828105142.png"></li>
<li>对不同的数据量进行不同的策略，比如数据特别少，单cpu反而最快。</li>
<li>二维的图，无脑按照y划分就行。<ol>
<li>合并的时候，按照并查集（1.维护顺序 2.有代表性）</li>
</ol>
</li>
<li>针对数据规模，是否要并行。</li>
</ol>
</li>
<li>IO密集<ol>
<li>并行读取</li>
<li>内存硬盘化</li>
</ol>
</li>
<li>通讯密集<ol>
<li>IB网通信</li>
<li>改变通信结构</li>
<li>打包发送</li>
<li>希尔伯特划分（一维二维）</li>
</ol>
</li>
<li>编译选项<ol>
<li>O3优化,ipo过程优化,fp-model fast&#x3D;2加速浮点计算</li>
</ol>
</li>
<li>其他未分类<ol>
<li><img src="https://pic.shaojiemike.top/img/20210828120944.png"></li>
</ol>
</li>
</ol>
<h2 id="还没来得及看的优化"><a href="#还没来得及看的优化" class="headerlink" title="还没来得及看的优化"></a>还没来得及看的优化</h2><p>Software optimization resources ：<a target="_blank" rel="noopener" href="https://www.agner.org/optimize/">https://www.agner.org/optimize/</a></p>
<h2 id="AMD-罗马米兰平台优化"><a href="#AMD-罗马米兰平台优化" class="headerlink" title="AMD 罗马米兰平台优化"></a>AMD 罗马米兰平台优化</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19q4y197uX?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV19q4y197uX?spm_id_from=333.999.0.0</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vU4y1u7nL?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1vU4y1u7nL?spm_id_from=333.999.0.0</a><br><img src="https://pic.shaojiemike.top/img/20211026172536.png"><br><img src="https://pic.shaojiemike.top/img/20211026172201.png"><br><img src="https://pic.shaojiemike.top/img/20211026172231.png"><br><img src="https://pic.shaojiemike.top/img/20211026172128.png"></p>
<h2 id="常见的参数"><a href="#常见的参数" class="headerlink" title="常见的参数"></a>常见的参数</h2><p>2 sockets cpu latency : 50&#x2F;60</p>
<p>core memory bandwidth ：20GB&#x2F;s</p>
<h2 id="样例图片"><a href="#样例图片" class="headerlink" title="样例图片"></a>样例图片</h2><ol>
<li>不合理数据结构,和合理的数据结构<br><img src="https://pic.shaojiemike.top/img/$%7DL9FL9$GN)0F1X@WZW~J9U.png"><br><img src="https://pic.shaojiemike.top/img/23.png"></li>
<li>编译选项<br><img src="https://pic.shaojiemike.top/img/2333.png"><br><img src="https://pic.shaojiemike.top/img/1232333.png"></li>
</ol>
<h2 id="性能-功耗-与容错"><a href="#性能-功耗-与容错" class="headerlink" title="性能 功耗 与容错"></a>性能 功耗 与容错</h2><p>陈子忠 教授( 美国加州大学河滨分校 ) 230616报告</p>
<ol>
<li>多核的出现，单核能耗与频率三次方成正比，难以压住散热</li>
<li>在已知调度时间复杂度估计的情况下，降低频率DVFS延长执行能大幅度节约功耗。同理提升频率也行。</li>
<li>纠错：检查点机制，中间验证算法复杂度比计算算法复杂度低。</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p><a target="_blank" rel="noopener" href="https://johnysswlab.com/">https://johnysswlab.com/</a></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>太糊了<br><img src="https://pic.shaojiemike.top/img/20211001235425.png"></p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><p>因为参加2021 IPCC,观看B站视频，学到很多特地总结一下</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Dv411p7ay">https://www.bilibili.com/video/BV1Dv411p7ay</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/15/">Previous</a></div><div class="pagination-next"><a href="/page/17/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/15/">15</a></li><li><a class="pagination-link is-current" href="/page/16/">16</a></li><li><a class="pagination-link" href="/page/17/">17</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/35/">35</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="Shaojie Tan"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shaojie Tan</p><p class="is-size-6 is-block">𝘊𝘰𝘮𝘱𝘶𝘵𝘦𝘳 𝘈𝘳𝘤𝘩𝘪𝘵𝘦𝘤𝘵𝘶𝘳𝘦 &amp; 𝘏𝘗𝘊</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Anhui, Hefei, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">342</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">470</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Kirrito-k423" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Kirrito-k423"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithms/"><span class="level-start"><span class="level-item">Algorithms</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/Architecture/"><span class="level-start"><span class="level-item">Architecture</span></span><span class="level-end"><span class="level-item tag">36</span></span></a></li><li><a class="level is-mobile" href="/categories/Artificial-Intelligence/"><span class="level-start"><span class="level-item">Artificial Intelligence</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Databases/"><span class="level-start"><span class="level-item">Databases</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/HPC/"><span class="level-start"><span class="level-item">HPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/OOW/"><span class="level-start"><span class="level-item">OOW</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Operating-system/"><span class="level-start"><span class="level-item">Operating system</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Overview/"><span class="level-start"><span class="level-item">Overview</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Tips/"><span class="level-start"><span class="level-item">Tips</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Treasure/"><span class="level-start"><span class="level-item">Treasure</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tutorials/"><span class="level-start"><span class="level-item">Tutorials</span></span><span class="level-end"><span class="level-item tag">118</span></span></a></li><li><a class="level is-mobile" href="/categories/Values/"><span class="level-start"><span class="level-item">Values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/architecture/"><span class="level-start"><span class="level-item">architecture</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/diary/"><span class="level-start"><span class="level-item">diary</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/english/"><span class="level-start"><span class="level-item">english</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/math/"><span class="level-start"><span class="level-item">math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/operating-system/"><span class="level-start"><span class="level-item">operating system</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/security/"><span class="level-start"><span class="level-item">security</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/software/"><span class="level-start"><span class="level-item">software</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/thinking/"><span class="level-start"><span class="level-item">thinking</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/toLearn/"><span class="level-start"><span class="level-item">toLearn</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/categories/values/"><span class="level-start"><span class="level-item">values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://ibug.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ibugs</span></span><span class="level-right"><span class="level-item tag">ibug.io</span></span></a></li><li><a class="level is-mobile" href="https://jia.je/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">jiegec</span></span><span class="level-right"><span class="level-item tag">jia.je</span></span></a></li><li><a class="level is-mobile" href="https://leimao.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">leimao</span></span><span class="level-right"><span class="level-item tag">leimao.github.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-15T01:11:04.000Z">2023-11-15</time></p><p class="title"><a href="/2023/11/15/Work/Algorithms/datastructure/dataStructureSummary/">Data Structure Summary</a></p><p class="categories"><a href="/categories/Algorithms/">Algorithms</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-14T07:38:50.000Z">2023-11-14</time></p><p class="title"><a href="/2023/11/14/Work/Architecture/PIM/HostCoreWithPIMCoreIn3DMem/">Host-Core With PIM-Core In 3D-stacked Mem</a></p><p class="categories"><a href="/categories/Architecture/">Architecture</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-14T03:24:26.000Z">2023-11-14</time></p><p class="title"><a href="/2023/11/14/Work/Architecture/PIM/AddressTranslationForPIM/">AddressTranslationForPIM</a></p><p class="categories"><a href="/categories/toLearn/">toLearn</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-14T03:23:38.000Z">2023-11-14</time></p><p class="title"><a href="/2023/11/14/Work/Architecture/PIM/experimentsForPIMMotivation/">Experiments For PIM Motivation</a></p><p class="categories"><a href="/categories/toLearn/">toLearn</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-13T01:42:31.000Z">2023-11-13</time></p><p class="title"><a href="/2023/11/13/Work/Architecture/microHardware/Predictor/">Predictor</a></p><p class="categories"><a href="/categories/toLearn/">toLearn</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">203</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">67</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">72</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/5G/"><span class="tag">5G</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/64bits-vs-32bits/"><span class="tag">64bits vs 32bits</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMAT/"><span class="tag">AMAT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMD/"><span class="tag">AMD</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ASPLOS/"><span class="tag">ASPLOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ATI/"><span class="tag">ATI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AVX/"><span class="tag">AVX</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Alpha/"><span class="tag">Alpha</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Analysis/"><span class="tag">Analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Apt/"><span class="tag">Apt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BFS/"><span class="tag">BFS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BHive/"><span class="tag">BHive</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BT/"><span class="tag">BT</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BTL/"><span class="tag">BTL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Baka-Mitai/"><span class="tag">Baka Mitai</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Big-Endian/"><span class="tag">Big-Endian</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a><p class="is-size-7"><span>&copy; 2023 Shaojie Tan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>