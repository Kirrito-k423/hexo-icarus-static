<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SHAOJIE&#039;S BOOK</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SHAOJIE&#039;S BOOK"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SHAOJIE&#039;S BOOK"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="SHAOJIE&#039;S BOOK"><meta property="og:url" content="http://icarus.shaojiemike.top/"><meta property="og:site_name" content="SHAOJIE&#039;S BOOK"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://icarus.shaojiemike.top/img/og_image.png"><meta property="article:author" content="Shaojie Tan"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://icarus.shaojiemike.top/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://icarus.shaojiemike.top"},"headline":"SHAOJIE'S BOOK","image":["http://icarus.shaojiemike.top/img/og_image.png"],"author":{"@type":"Person","name":"Shaojie Tan"},"publisher":{"@type":"Organization","name":"SHAOJIE'S BOOK","logo":{"@type":"ImageObject","url":"http://icarus.shaojiemike.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-22T16:00:00.000Z" title="6/22/2023, 4:00:00 PM">2023-06-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.198Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/network/">network</a></span><span class="level-item">4 minutes read (About 668 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/22/Work/network/0-basic/localhost/">Localhost</a></p><div class="content"><h2 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h2><ul>
<li>环回地址，是指不离开主机的数据包(也就是说，这些数据包不会通过外部网络接口)。<ul>
<li>任何发往环回地址的数据包，其处理都在 TCP&#x2F;IP 协议叠的链路层中实现的。这些数据包不会向下交由网卡（NIC）或者设备驱动程序处理，既不应在电脑系统以外出现，也不可经路由器转发。</li>
<li>环回地址是主机用于向自身发送通信的一个特殊地址，帮助我们在同一台主机上实现client和server的功能。</li>
<li>运用本地环回机制，便可在主机上运行网络服务，期间不须安装实体网络接口卡，也无须将该服务开放予主机所在网络。</li>
</ul>
</li>
</ul>
<h2 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h2><ul>
<li>localhost 是一个别名，用于指代为环回保留的 IP 地址(环回地址)。<ul>
<li>IPv4使用 A 类地址的最后一个块（从 127.0.0.1 到 127.255.255）<ul>
<li>发送到这些地址（127.0.0.1 到 127.255.255.255）的所有数据包都会返回本机。</li>
</ul>
</li>
<li>而IPv6保留第一个（0:0:0:0:0:0:0:1 - 或 : :1）作为其环回地址。</li>
</ul>
</li>
</ul>
<h2 id="0-0-0-0-任意ip"><a href="#0-0-0-0-任意ip" class="headerlink" title="0.0.0.0 任意ip"></a>0.0.0.0 任意ip</h2><ul>
<li>0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的IPV4地址。</li>
<li>监听0.0.0.0的端口，就是监听本机中所有IP的端口。</li>
<li>0.0.0.0是不能被ping通的。</li>
</ul>
<h2 id="localhost-与-127-0-0-1区别"><a href="#localhost-与-127-0-0-1区别" class="headerlink" title="localhost 与 127.0.0.1区别"></a>localhost 与 127.0.0.1区别</h2><ul>
<li>localhost(本地主机)不是专门指 127.0.0.1，而是指为环回保留的整个 IP 地址范围。<ul>
<li>注意你不能总是使用127.0.0.1进行环回。<ul>
<li>仅限 IPv6 的系统不会响应此类请求，因为它们的 localhost 链接到地址::1。</li>
<li>修改<code>/etc/hosts</code>文件即可修改环回的地址。但是十分不建议这样做，很可能导致本地服务崩溃</li>
</ul>
</li>
</ul>
</li>
<li>请求的发送方式不同???<ul>
<li>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</li>
<li>localhost不会解析成ip，也不会占用网卡、网络资源。一般设置程序时本地服务用localhost是最好的。</li>
</ul>
</li>
</ul>
<h2 id="如何将环回地址某端口上的服务映射到外部网络接口"><a href="#如何将环回地址某端口上的服务映射到外部网络接口" class="headerlink" title="如何将环回地址某端口上的服务映射到外部网络接口"></a>如何将环回地址某端口上的服务映射到外部网络接口</h2><ul>
<li>可以使用ssh转发<code>ssh -L 1313:localhost:8020 shaojiemike@202.38.72.23</code>将服务器<code>localhost:1313</code>上的内容转发到本地8020端口</li>
<li><code>hugo server -D -d ~/test/public</code>默认会部署在localhost上<ul>
<li>解决办法<code>hugo server --bind=202.38.72.23 --baseURL=http://202.38.72.23:1313 -D -d ~/test/public</code></li>
</ul>
</li>
</ul>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://blog.nnwk.net/article/107">https://blog.nnwk.net/article/107</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-20T16:00:00.000Z" title="6/20/2023, 4:00:00 PM">2023-06-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.106Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Values/">Values</a></span><span class="level-item">8 minutes read (About 1178 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/20/Thinking/4-viewOnOthers/4.1-game/">UnimportantView: Game</a></p><div class="content"><h2 id="关于偏好的循环"><a href="#关于偏好的循环" class="headerlink" title="关于偏好的循环"></a>关于偏好的循环</h2><article class="message is-warning">
        <div class="message-header"><p><i class="fa-solid fa-question mr-2"></i>轮回与回旋镖：小别胜新婚</p>
</div>
        <div class="message-body">
            <p>我发现我陷入了一种循环：</p>
<p>正向：</p>
<ol>
<li>美术音乐和玩法的新鲜感：一开始游戏新鲜内容好奇，然后在新鲜内容耗尽时。</li>
<li>成就感</li>
<li>史诗故事感（真实代入感），和领悟</li>
<li>刺激感？（不适用我这里</li>
</ol>
<p>反向：</p>
<ol start="5">
<li>日常的枯燥的刷任务积累，实在令人厌烦。</li>
<li>PVP的队友的争吵和失败的挫败感也会大幅降低游玩意愿</li>
</ol>

        </div>
    </article>

<article class="message is-success">
        <div class="message-header"><p><i class="fa-brands fa-gripfire mr-2"></i>关于PVP 和 PVE</p>
</div>
        <div class="message-body">
            <p>如果在游玩的时候，如果没有对面是电脑的想法，任务的难度就是<strong>合适的，有趣的，或者有挑战</strong>的。</p>
<p>如果意识到了NPC反应的<strong>模板化，枯燥化，简单化</strong>的PVE就不行。 PVP可以避免这三点，但是组队的门槛、队内的矛盾、和失利会带来反向效果。</p>
<p>比如GTA5 online通关之后，上线之后所有东西都尝试过后，就没有留恋的意思了。除非将NPC接入AI并且动态调节难度，就可以避免这点。</p>

        </div>
    </article>

<h2 id="如何筛选适合的游戏"><a href="#如何筛选适合的游戏" class="headerlink" title="如何筛选适合的游戏"></a>如何筛选适合的游戏</h2><p>现状：游玩时间少，时间碎片化，无规律</p>
<ul>
<li>游玩体验一定要舒适<ul>
<li>体验的主线内容：真实的幻想世界<ul>
<li>轻松快乐的主线剧情体验，(-20 ~ 35) <ul>
<li>一起提供代入感和沉浸式的游玩体验</li>
<li>无剧情该项为0</li>
<li>扣分：枯燥拖沓的演出(-10)</li>
<li>加分：刺激有趣的剧情表演(+10)、诙谐的台本(+5),令人有所感悟的主线故事(+15)、动容的NPC故事(+5)</li>
</ul>
</li>
<li>有趣新颖的玩法(30)<ul>
<li>新鲜玩法(15)</li>
<li>眼前一亮的细节(5)</li>
<li>足够深的游戏内容，来随意探索;(10)<ul>
<li>或者足够精致宏大的单机主线内容(FF,大镖客2)</li>
</ul>
</li>
</ul>
</li>
<li>精致华丽的美术(30)<ul>
<li>交互界面UI(3)</li>
<li>开放世界风景(7) 震撼华丽的大场景可以弥补角色喜爱塑造的缺失</li>
<li>令人喜爱的角色(15)</li>
<li>动听的音乐(5)</li>
</ul>
</li>
</ul>
</li>
<li>日常周常体验(40)<ul>
<li>耗时&#x2F;门槛(20)：<ul>
<li>无需投入大量前期时间才能正常体验<ul>
<li>经验训练技巧</li>
<li>前置任务过多</li>
</ul>
</li>
<li>没有强制的任务指标来限制&#x2F;延长在线时长</li>
</ul>
</li>
<li>收获感(10)：投入有回报(货币)、提升(数值)</li>
<li>新鲜感(10)：有Rougelike元素，避免无聊</li>
</ul>
</li>
<li>手游根据逼氪程度减分<ul>
<li>200以上减5；1000以上减10</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="适合的类型："><a href="#适合的类型：" class="headerlink" title="适合的类型："></a>适合的类型：</h2><ul>
<li>合家欢小游戏(主玩法，轻竞技)：<ul>
<li>蛋仔、任系游戏（惊奇）</li>
</ul>
</li>
<li>主剧情的单机RPG游戏<ul>
<li>王国之泪，星际争霸（金手指）</li>
</ul>
</li>
<li>主美术的二次元轻度手游<ul>
<li>铁道</li>
</ul>
</li>
<li>网状叙事的电影史<ul>
<li>博德之门3</li>
</ul>
</li>
</ul>
<h2 id="不适合的类型："><a href="#不适合的类型：" class="headerlink" title="不适合的类型："></a>不适合的类型：</h2><ul>
<li>有紧迫任务目标的游戏（大量限时任务的网游）</li>
<li>快乐建立在胜负上的竞技类游戏(PVP游戏)</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><!-- ![](https://pic.shaojiemike.top/img/20230501102804.png) -->

<p><img src="https://pic.shaojiemike.top/img/20230621212739.png"></p>
<h3 id="231221-少女前线2-追放"><a href="#231221-少女前线2-追放" class="headerlink" title="231221 少女前线2 追放"></a>231221 少女前线2 追放</h3><p>首先，我没有玩过少前1，和战棋类游戏，和偏写实的剧情。</p>
<ol>
<li>剧情与主线： <ol>
<li>沉浸感低：<strong>谜语人</strong>，各种看不到的名词。我不知道是为了装逼还是少前1的基本概念。好的游戏，都不会在玩家理解上制造问题。</li>
<li>个人感觉<strong>写实的剧情</strong>立意不足，和目的性，意义行解释不清楚，导致游玩时，感觉动力不足。 由于本人并不喜欢打杀。我玩游戏也是认真玩的，如果剧情感觉不够恢弘，写实的枪战细节剧情感觉不是很动人。(可能是玄幻和幻想游戏玩多了，写实类剧情完全没接触过)，需要<strong>平衡好真实感与现实的繁琐程度</strong></li>
</ol>
</li>
<li>美术<ol>
<li>UI简洁好看</li>
<li><strong>好但可以更好</strong>，人物, 闪电姐的脸总感觉怪怪的胖胖的。黑丝等拟真质感确实不错。但是人物服饰什么的都是冷淡风，只能说之后的潜力很大。（比如像 尘白禁区泳装一样。</li>
</ol>
</li>
<li>玩法<ol>
<li><strong>好但可以更好</strong>，利用地形杀，和道具之类的。（有潜力</li>
</ol>
</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-15T16:00:00.000Z" title="6/15/2023, 4:00:00 PM">2023-06-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.166Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">13 minutes read (About 1920 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/15/Work/HPC/0-overview/optimizationOutline/">Optimization Outline</a></p><div class="content"><h2 id="Sun’s-常见超线性加速的情况"><a href="#Sun’s-常见超线性加速的情况" class="headerlink" title="Sun’s 常见超线性加速的情况"></a>Sun’s 常见超线性加速的情况</h2><p><a target="_blank" rel="noopener" href="http://www.cs.iit.edu/%7Esun/cs546.html#materials">http://www.cs.iit.edu/%7Esun/cs546.html#materials</a></p>
<p><a target="_blank" rel="noopener" href="https://annals-csis.org/Volume_8/pliks/498.pdf">https://annals-csis.org/Volume_8/pliks/498.pdf</a></p>
<p>Superlinear Speedup in HPC Systems: why and when?</p>
<ol>
<li>Cache size increased 多核的cache总size增加<ol>
<li>在大多数的并行计算系统中，每个处理器都有少量的高速缓存，当某一问题执行在大量的处理器上，而所需要的数据都放在高速缓存中时，由于数据的复用，总的计算时间趋于减少，如果由于这种高速缓存效应补偿了由于通信造成的额外开销，就有可能造成超线性加速比。</li>
</ol>
</li>
<li>Overhead reduced 锁减少，粒度变小</li>
<li>Latency hidden 数据预取更多了</li>
<li>Randomized algorithms<ol>
<li>在某些并行搜索算法中，允许不同的处理器在不同的分支方向上同时搜索，当某一处理器一旦迅速的找到了解，它就向其余的处理器发出中止搜索的信号，这就会提前取消那些在串行算法中所做的无谓的搜索分枝，从而出现超线性加速比现象</li>
</ol>
</li>
<li>Mathematical inefficiency of the serial algorithm 改并行算法</li>
<li>Higher memory consumption access cost for in sequantial processing</li>
</ol>
<h2 id="应用优化前提"><a href="#应用优化前提" class="headerlink" title="应用优化前提"></a>应用优化前提</h2><ol>
<li><p>迭代进行 ：分析程序最大热点(perf,vtune工具)-&gt;优化该热点—&gt;分析程序最大热点-&gt;……</p>
</li>
<li><p>自顶向下分析优化程序热点的思路</p>
<ol>
<li>全局算法的调研、理解、总体设计改进</li>
<li>程序任务划分，并行各部分模块</li>
<li>仔细分析热点的kernel循环</li>
</ol>
</li>
<li><p>基本了解物理数学背景公式</p>
</li>
<li><p>阅读代码，明白实现</p>
<ol>
<li>从main函数开始看的都是大撒比，没错，说的就是我</li>
<li>带着问题看，才能快速抓住重点</li>
</ol>
</li>
<li><p>建议串行直接用vtune判断算法热点和时间</p>
<ol>
<li>粗略判断热点</li>
<li>加入<strong>各部分热点的时间输出</strong> (必需的:积极的正向反馈，会提高积极性和理清思路)</li>
</ol>
</li>
<li><p>寻找合适的<strong>大例子</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line">itime = omp_get_wtime();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nTime taken is %f&quot;</span>,omp_get_wtime()-itime);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行n次求得平均值; 或者对不同大小的例子在不同参数下的效果拉图对比<ol>
<li>单机不同数量多核，同机器的不同编译器，不同核心kernel&#x2F;CPU</li>
<li>warmup&#x3D;10 loop&#x3D;50 先热身10次，然后循环10次</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./SLIC_0805_3 |tee 3.log &amp;&amp; ./SLIC_0805_3 |tee 3.log &amp;&amp; ./SLIC_0805_3 |tee 3.log</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.shaojiemike.top/img/20210909155842.png"><br>7. 每次优化基给予正确性的评价，并对负优化进行解释。</p>
<ol>
<li>查看汇编</li>
<li>基本并行加速实现后，vtune检查<strong>访存</strong>,或者用Intel advisor的Roofline Model来分析。</li>
<li>新函数用 <code>utils.cpp</code>和 <code>utils.h</code>写</li>
</ol>
<h2 id="应用类型及其常见优化"><a href="#应用类型及其常见优化" class="headerlink" title="应用类型及其常见优化"></a>应用类型及其常见优化</h2><ol>
<li>计算密集<ol>
<li>采用适合并行平台的算法</li>
<li>CPU核数利用率<ol>
<li>多进程<ol>
<li>进程池动态调度</li>
</ol>
</li>
<li>多线程(对于特别小的例子，一个cpu的核就够用了)<ol>
<li>线程亲和性</li>
<li>线程动态调度</li>
</ol>
</li>
</ol>
</li>
<li>向量化率(提高单次计算量)SIMD<ol>
<li>自动向量化提升有限吗？怎么写出好让编译器自动向量化的代码<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyl910/?type=blog">https://blog.csdn.net/zyl910/?type=blog</a> SIMD测试比较</li>
</ol>
</li>
<li>pragma omp parallel for simd</li>
<li>循环展开，凑够无依赖计算，填满流水线avx512的宽度(8个float)</li>
<li>intrins接口手动向量化</li>
<li>注意边界，不足8个单独计算</li>
<li>手动向量化avx2一般会快一些</li>
<li><img src="https://pic.shaojiemike.top/img/20211001225407.png"></li>
</ol>
</li>
<li>降低计算量技巧<ol>
<li><a target="_blank" rel="noopener" href="https://developer.51cto.com/article/710503.html">其他各种小技巧</a></li>
<li>使用掩码代替分支判断<ol>
<li>增A：<code>|A</code> 删A：<code>&amp;（~A）</code>判断：<code>&amp;A!=0</code></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyl910/article/details/7345655">https://blog.csdn.net/zyl910/article/details/7345655</a></li>
</ol>
</li>
<li>替换if <code>tmp[i][j] = (!(cnt^3))||((a[i][j]&amp;1)&amp;&amp;(!(cnt^4)));</code></li>
<li>使用乘法代替除法</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35580883/article/details/78318142">位运算实现整数绝对值</a><ol>
<li><a target="_blank" rel="noopener" href="http://www.cppblog.com/SmartPtr/archive/2007/07/05/27552.aspx">位运算实现浮点数绝对值</a></li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cncnlg/article/details/42784739">位运算实现整数MaxMin</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1802321">位运算求二进制内1的个数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lady_killer9/article/details/88067317">位运算代替乘除2运算</a></li>
<li><img src="https://pic.shaojiemike.top/img/20211001230813.png"></li>
<li>重新划分去除乘除，小代价是归约一下sigma<img src="https://pic.shaojiemike.top/img/20211001231708.png"></li>
</ol>
</li>
<li>混合精度(降低部分精度，降低计算量)</li>
<li>数据重用(不重复计算，降低计算量)</li>
</ol>
</li>
<li>访存密集<ol>
<li>vtune memory access分析，提高cpu访存带宽，优化2CPU通信<ol>
<li>store与load比stream慢很多<ol>
<li>原因store是将要写的数据load到缓存里，然后修改。而stream是直接写内存。</li>
</ol>
</li>
<li><img src="https://pic.shaojiemike.top/img/B(EWVUD74G@%60$H8%7BT)J5GBR.png"></li>
<li><img src="https://pic.shaojiemike.top/img/Z%606%5BUK5MOU@%60BCQBKRE9UJR.png"></li>
</ol>
</li>
<li>计算分块<ol>
<li>根据L1的大小设置块大小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MiB = Mebibyte = 1024 KB,</span><br><span class="line">KiB = Kibibyte = 1024 Bytes,</span><br><span class="line">MB = Megabyte = 1,000 KB,</span><br><span class="line">KB = Kilobyte = 1,000 Bytes</span><br></pre></td></tr></table></figure></li>
<li>double 8 bytes</li>
</ol>
</li>
<li>改变数据结构优化访存(提高cache命中率)<ol>
<li>不合理的数据结构定义，导致数据存储不连续。通过改变数据结构，通过内存指针访问连续地址</li>
</ol>
</li>
<li>强制使用静态链接库glibc</li>
<li>访存局部性原理(提高cache命中率)<ol>
<li>c语言先行后列</li>
<li>循环拆分、循环重组</li>
</ol>
</li>
<li>根据cache空间，以及cache策略，进行cache数据预取，</li>
<li>计算融合(减少访存次数)<ol>
<li>计算结果及时使用，去除中间结果的存储访问时间</li>
<li>将多个循环整合为一个</li>
</ol>
</li>
<li>对于对同一个地址的连续读写依赖，采取pingpong-buffer来两个分治</li>
<li>申请空间<ol>
<li><img src="https://pic.shaojiemike.top/img/20210828120805.png"></li>
</ol>
</li>
</ol>
</li>
<li>负载均衡(并行划分)<ol>
<li><img src="https://pic.shaojiemike.top/img/20210828105142.png"></li>
<li>对不同的数据量进行不同的策略，比如数据特别少，单cpu反而最快。</li>
<li>二维的图，无脑按照y划分就行。<ol>
<li>合并的时候，按照并查集（1.维护顺序 2.有代表性）</li>
</ol>
</li>
<li>针对数据规模，是否要并行。</li>
</ol>
</li>
<li>IO密集<ol>
<li>并行读取</li>
<li>内存硬盘化</li>
</ol>
</li>
<li>通讯密集<ol>
<li>IB网通信</li>
<li>改变通信结构</li>
<li>打包发送</li>
<li>希尔伯特划分（一维二维）</li>
</ol>
</li>
<li>编译选项<ol>
<li>O3优化,ipo过程优化,fp-model fast&#x3D;2加速浮点计算</li>
</ol>
</li>
<li>其他未分类<ol>
<li><img src="https://pic.shaojiemike.top/img/20210828120944.png"></li>
</ol>
</li>
</ol>
<h2 id="还没来得及看的优化"><a href="#还没来得及看的优化" class="headerlink" title="还没来得及看的优化"></a>还没来得及看的优化</h2><p>Software optimization resources ：<a target="_blank" rel="noopener" href="https://www.agner.org/optimize/">https://www.agner.org/optimize/</a></p>
<h2 id="AMD-罗马米兰平台优化"><a href="#AMD-罗马米兰平台优化" class="headerlink" title="AMD 罗马米兰平台优化"></a>AMD 罗马米兰平台优化</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19q4y197uX?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV19q4y197uX?spm_id_from=333.999.0.0</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vU4y1u7nL?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1vU4y1u7nL?spm_id_from=333.999.0.0</a><br><img src="https://pic.shaojiemike.top/img/20211026172536.png"><br><img src="https://pic.shaojiemike.top/img/20211026172201.png"><br><img src="https://pic.shaojiemike.top/img/20211026172231.png"><br><img src="https://pic.shaojiemike.top/img/20211026172128.png"></p>
<h2 id="常见的参数"><a href="#常见的参数" class="headerlink" title="常见的参数"></a>常见的参数</h2><p>2 sockets cpu latency : 50&#x2F;60</p>
<p>core memory bandwidth ：20GB&#x2F;s</p>
<h2 id="样例图片"><a href="#样例图片" class="headerlink" title="样例图片"></a>样例图片</h2><ol>
<li>不合理数据结构,和合理的数据结构<br><img src="https://pic.shaojiemike.top/img/$%7DL9FL9$GN)0F1X@WZW~J9U.png"><br><img src="https://pic.shaojiemike.top/img/23.png"></li>
<li>编译选项<br><img src="https://pic.shaojiemike.top/img/2333.png"><br><img src="https://pic.shaojiemike.top/img/1232333.png"></li>
</ol>
<h2 id="性能-功耗-与容错"><a href="#性能-功耗-与容错" class="headerlink" title="性能 功耗 与容错"></a>性能 功耗 与容错</h2><p>陈子忠 教授( 美国加州大学河滨分校 ) 230616报告</p>
<ol>
<li>多核的出现，单核能耗与频率三次方成正比，难以压住散热</li>
<li>在已知调度时间复杂度估计的情况下，降低频率DVFS延长执行能大幅度节约功耗。同理提升频率也行。</li>
<li>纠错：检查点机制，中间验证算法复杂度比计算算法复杂度低。</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p><a target="_blank" rel="noopener" href="https://johnysswlab.com/">https://johnysswlab.com/</a></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>太糊了<br><img src="https://pic.shaojiemike.top/img/20211001235425.png"></p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><p>因为参加2021 IPCC,观看B站视频，学到很多特地总结一下</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Dv411p7ay">https://www.bilibili.com/video/BV1Dv411p7ay</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-14T16:00:00.000Z" title="6/14/2023, 4:00:00 PM">2023-06-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.142Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/math/">math</a></span><span class="level-item">an hour read (About 8867 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/14/Work/math/probabilityTheory/">Probability Theory</a></p><div class="content"><h2 id="常用离散分布"><a href="#常用离散分布" class="headerlink" title="常用离散分布"></a>常用离散分布</h2><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>二项分布（Binomial Distribution）是概率论中常见的离散概率分布，用于描述在n重伯努利实验中成功事件发生的次数。</p>
<p>n重伯努利实验是指进行了n次独立重复的伯努利试验。伯努利试验是一种只有两个可能结果的随机试验，通常称为成功（S）和失败（F）。每次试验成功的概率为p，失败的概率为1-p。特点是每次试验只有两种可能的结果，通常表示为成功和失败。</p>
<p>在二项分布中，我们关注的是在<strong>n次独立重复试验</strong>中成功事件发生的次数（记为X），其中每次试验成功的概率为p。二项分布的概率质量函数可以表示为：</p>
<p>$$P(X &#x3D; k) &#x3D; C(n, k) * p^k * (1-p)^{n-k}$$</p>
<p>P(X &#x3D; k)表示在n次试验中成功事件发生k次的概率。</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>泊松分布（Poisson Distribution）是一种离散概率分布，用于描述在一段<strong>固定时间或空间内随机事件发生的次数</strong>。它的特点是事件发生的次数是离散的且无限可数，且事件发生的概率在整个时间或空间内是恒定的。</p>
<p>在泊松分布中，我们关注的是在给定的时间或空间内，事件发生的次数（记为X）。泊松分布的概率质量函数可以表示为：</p>
<p>$$P(X &#x3D; k) &#x3D; (λ^k * e^{-λ}) &#x2F; k!$$</p>
<p>其中，P(X &#x3D; k)表示在给定时间或空间内事件发生k次的概率。λ是事件发生的平均次数，即单位时间或空间内事件发生的平均频率。e是自然对数的底数，k!表示k的阶乘。</p>
<p>泊松分布常用于描述稀有事件的发生情况，例如单位时间内电话呼叫次数、单位面积内放射性粒子的撞击次数等。通过泊松分布，我们可以计算在给定平均发生率下，事件发生特定次数的概率，从而进行概率推断和预测。</p>
<h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>超几何分布（Hypergeometric Distribution）是一种离散概率分布，用于描述从<strong>有限总体中进行抽样时，抽取的样本中具有某种特征的个数的分布</strong>。它与二项分布相似，但有一些关键区别。</p>
<p>在超几何分布中，我们考虑从总体中抽取固定大小的样本，总体中有M个具有某种特征的元素和N-M个没有该特征的元素。我们关注的是在抽样过程中，样本中具有该特征的元素的个数（记为X）。</p>
<p>超几何分布的概率质量函数可以表示为：</p>
<p>$$P(X &#x3D; k) &#x3D; (C(M, k) * C(N-M, n-k)) &#x2F; C(N, n)$$</p>
<p>其中，P(X &#x3D; k)表示样本中具有该特征的元素个数为k的概率。C(M, k)表示在M个具有该特征的元素中选择k个元素的组合数，C(N-M, n-k)表示在N-M个没有该特征的元素中选择n-k个元素的组合数，C(N, n)表示在总体中选择n个元素的组合数。</p>
<p>超几何分布常用于从有限总体中进行抽样，并研究样本中某种特征的出现情况。它的特点是，随着抽样数量的增加，成功事件的概率不再是恒定的，因为每次抽样都会影响总体中元素的可选性。通过超几何分布，我们可以计算在给定总体和抽样大小的情况下，样本中具有该特征的元素个数的概率分布。</p>
<h3 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h3><p>几何分布描述的是在独立重复试验中，<strong>第一次成功事件A发生所需的试验次数</strong>。每次试验都有成功（S）和失败（F）两种可能结果，且成功概率为p。几何分布的概率质量函数可以表示为：</p>
<p>$$P(X &#x3D; k) &#x3D; (1 - p)^{k-1} * p$$</p>
<p>其中，P(X &#x3D; k)表示第一次成功事件发生在第k次试验的概率。</p>
<h3 id="负二项分布（帕斯卡分布"><a href="#负二项分布（帕斯卡分布" class="headerlink" title="负二项分布（帕斯卡分布)"></a>负二项分布（帕斯卡分布)</h3><p>负二项分布描述的是在独立重复试验中，成功事件发生r次所需的试验次数。每次试验都有成功（S）和失败（F）两种可能结果，且成功概率为p。负二项分布的概率质量函数可以表示为：</p>
<p>$$P(X &#x3D; k) &#x3D; C(k-1, r-1) * (1 - p)^{k-r} * p^r$$</p>
<p>其中，P(X &#x3D; k)表示成功事件发生r次在第k次试验的概率。C(k-1, r-1)表示组合数，表示在前k-1次试验中取r-1次成功的组合数。</p>
<h2 id="常用连续分布"><a href="#常用连续分布" class="headerlink" title="常用连续分布"></a>常用连续分布</h2><p>常用密度函数表示</p>
<h3 id="正态分布（高斯分布）"><a href="#正态分布（高斯分布）" class="headerlink" title="正态分布（高斯分布）"></a>正态分布（高斯分布）</h3><p>正态分布，也称为高斯分布（Gaussian Distribution），是统计学中最重要且广泛应用的连续概率分布之一。</p>
<p>正态分布的概率密度函数（Probability Density Function, PDF）可以用以下公式表示：</p>
<p>$$f(x) &#x3D; (1 &#x2F; (σ * \sqrt{2π})) * exp(-(x-μ)^2 &#x2F; (2σ^2))$$</p>
<p>其中，f(x)表示随机变量X的概率密度函数。μ表示分布的均值（期望值），σ表示标准差，π表示圆周率，exp表示自然对数的指数函数。</p>
<p>正态分布具有以下特点：</p>
<ul>
<li>对称性：正态分布的概率密度函数是关于均值对称的，呈现出钟形曲线的形状。</li>
<li>唯一性：正态分布由其均值和标准差唯一确定。</li>
<li>中心极限定理：许多随机现象的总体分布趋向于正态分布，尤其在样本量足够大时。</li>
<li>68-95-99.7规则：在正态分布中，约有68%的数据落在均值的一个标准差范围内，约有95%的数据落在两个标准差范围内，约有99.7%的数据落在三个标准差范围内。</li>
</ul>
<h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>均匀分布（Uniform Distribution）是一种简单而常见的概率分布，它在指定的区间内的取值具有相等的概率。在均匀分布中，每个可能的取值都具有相同的概率密度。</p>
<p>均匀分布的概率密度函数（Probability Density Function, PDF）可以用以下公式表示：</p>
<p>f(x) &#x3D; 1 &#x2F; (b - a)，如果 <code>a ≤ x ≤ b</code><br>f(x) &#x3D; 0，其他情况</p>
<p>其中，f(x)表示随机变量X的概率密度函数。a和b分别表示分布的下限和上限。</p>
<h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>指数分布（Exponential Distribution）是一种连续概率分布，常用于描述事件发生的时间间隔。它是一种特殊的连续随机变量的分布，具有单峰、右偏的特点。</p>
<p>指数分布的概率密度函数（Probability Density Function, PDF）可以用以下公式表示：</p>
<p><code>f(x) = λ * exp(-λx)</code>，如果 x ≥ 0<br><code>f(x) = 0</code>，其他情况</p>
<p>其中，f(x)表示随机变量X的概率密度函数，λ是分布的参数，被称为率参数。</p>
<p>指数分布具有以下特点：</p>
<ul>
<li>单峰性：指数分布的概率密度函数是单峰的，峰值出现在0点，随着时间的增长逐渐减小。</li>
<li>无记忆性：指数分布具有无记忆性的特性，即给定已经等待了一段时间，再等待更多的时间的概率与刚开始等待的概率是相同的。这是指数分布与其他分布不同的重要特点。</li>
</ul>
<p>指数分布在实际应用中具有广泛的应用。例如，它常用于描述随机事件的<strong>到达时间、服务时间、寿命</strong>等。在可靠性工程和排队论中，指数分布经常用于模拟和分析各种事件的发生和持续时间。</p>
<h3 id="伽马分布"><a href="#伽马分布" class="headerlink" title="伽马分布"></a>伽马分布</h3><p>伽马分布（Gamma Distribution）是一种连续概率分布，它常用于描述正数随机变量的分布，如事件的等待时间、寿命等。伽马分布是指数分布的推广形式，它可以具有更灵活的形状。</p>
<p>伽马分布的概率密度函数（Probability Density Function, PDF）可以用以下公式表示：</p>
<p>$$ f(x) &#x3D; (1 &#x2F; (Γ(k) * θ^k)) * x^{k-1} * exp(-x&#x2F;θ)$$，如果 x ≥ 0<br>0，其他情况</p>
<p>其中，f(x)表示随机变量X的概率密度函数，k和θ是分布的参数，k被称为形状参数，θ被称为尺度参数，<code>Γ(k)</code>表示伽马函数（Gamma function）。</p>
<p>伽马分布具有以下特点：</p>
<ul>
<li>随机变量为正数：伽马分布的取值范围为正数，不包括0及负数。</li>
<li>形状灵活：通过调节形状参数k，可以改变伽马分布的形状。当k为整数时，伽马分布退化为Erlang分布。</li>
<li>可以用于建模持续时间：伽马分布常用于建模持续时间，如等待时间、寿命等，特别是当事件的发生率不是恒定的情况下。</li>
</ul>
<p>伽马分布在实际应用中具有广泛的应用。例如，在可靠性工程中，它常用于描述零部件的寿命和故障时间。在金融领域，伽马分布被用于模拟和分析资产价格的变动。</p>
<h3 id="贝塔分布"><a href="#贝塔分布" class="headerlink" title="贝塔分布"></a>贝塔分布</h3><p>贝塔分布（Beta Distribution）是一种连续概率分布，它定义在<strong>区间[0, 1]上</strong>，并且常用于描述概率分布、比例、概率参数等随机变量的分布。</p>
<p>贝塔分布的概率密度函数（Probability Density Function, PDF）可以用以下公式表示：</p>
<p>$$f(x) &#x3D; (x^{α-1} * (1-x)^{β-1}) &#x2F; B(α, β)$$，如果 0 ≤ x ≤ 1<br>0，其他情况</p>
<p>其中，f(x)表示随机变量X的概率密度函数，α和β是分布的两个形状参数，<code>B(α, β)</code>表示贝塔函数（Beta function）。</p>
<p>贝塔分布具有以下特点：</p>
<ul>
<li>取值范围：贝塔分布的取值范围为区间[0, 1]，对应于概率或比例的取值范围。</li>
<li>形状灵活：通过调节形状参数α和β的值，可以改变贝塔分布的形状，使其适应不同的数据分布。</li>
<li>可以用于建模随机概率：贝塔分布常用于建模随机概率、比例等，例如二项分布中的成功概率、伯努利分布中的参数等。</li>
</ul>
<p>贝塔分布在实际应用中具有广泛的应用。它常被用于贝叶斯统计推断、可靠性分析、A&#x2F;B测试、市场份额预测等领域。此外，贝塔分布还与其他概率分布有着密切的关联，例如伯努利分布、二项分布和贝叶斯推断中的共轭先验分布等。</p>
<h2 id="三大抽样分布"><a href="#三大抽样分布" class="headerlink" title="三大抽样分布"></a>三大抽样分布</h2><ul>
<li>卡方分布（Chi-Square Distribution）：卡方分布是一种连续概率分布，用于描述<strong>随机变量的平方和</strong>的分布。</li>
<li>F分布是一种连续概率分布，用于描述两个独立正态分布<strong>方差比</strong>的分布。</li>
<li>t分布（t-Distribution）：t分布是一种连续概率分布，用于描述小样本情况下样本均值的分布。与正态分布相比，t分布的尖峰更高、尾部更厚，适用于<strong>样本容量较小</strong>或总体方差未知的情况。</li>
</ul>
<h2 id="随机过程"><a href="#随机过程" class="headerlink" title="随机过程"></a>随机过程</h2><h3 id="泊松过程"><a href="#泊松过程" class="headerlink" title="泊松过程"></a>泊松过程</h3><p>泊松过程（Poisson Process）是一种随机过程，用于描述在固定时间间隔内随机事件发生的模式。泊松过程的关键特征是事件在时间上的独立性和固定的平均发生率。它可以用于建模各种事件的发生，例如电话呼叫到达、事故发生、信号传输等。</p>
<h3 id="马尔科夫"><a href="#马尔科夫" class="headerlink" title="马尔科夫"></a>马尔科夫</h3><h4 id="马尔可夫性质"><a href="#马尔可夫性质" class="headerlink" title="马尔可夫性质"></a>马尔可夫性质</h4><p>当一个随机过程其<strong>未来</strong>状态的条件概率分布仅依赖于<strong>当前</strong>状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程即具有马尔可夫性质。</p>
<h4 id="马尔可夫链、过程"><a href="#马尔可夫链、过程" class="headerlink" title="马尔可夫链、过程"></a>马尔可夫链、过程</h4><p>马尔可夫链（Markov Chain, MC）是概率论和数理统计中具有马尔可夫性质（Markov property）且存在于离散的指数集（index set）和状态空间（state space）内的随机过程（stochastic process）</p>
<p>适用于连续指数集的马尔可夫链被称为马尔可夫过程（Markov process）</p>
<h4 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h4><p>马尔可夫决策过程（Markov Decision Process, MDP）是序贯决策（sequential decision）的数学模型，用于在系统状态具有马尔可夫性质的环境中模拟智能体可实现的随机性策略与回报<img src="https://pic.shaojiemike.top/img/20220130201230.png"></p>
<h3 id="平稳过程"><a href="#平稳过程" class="headerlink" title="平稳过程"></a>平稳过程</h3><p>平稳过程（Stationary Process）是一种随机过程，其统计特性在时间上保持不变。具体而言，一个平稳过程在不同时间段内具有相同的概率分布和统计特性，如均值、方差和自协方差。</p>
<h3 id="布朗运动"><a href="#布朗运动" class="headerlink" title="布朗运动"></a>布朗运动</h3><p>布朗运动（Brownian Motion），也被称为维纳过程（Wiener Process），是一种随机过程，以英国生物学家罗伯特·布朗（Robert Brown）的名字命名。布朗运动是一种连续时间、连续空间的随机运动，它在各个时间点上的位置是随机的。</p>
<p>布朗运动的特点包括：</p>
<ul>
<li>随机性：布朗运动的运动路径是随机的，不可预测的。在每个时间点上，粒子的位置随机地变化。</li>
<li>连续性：布朗运动在连续的时间和空间上进行。粒子在任意瞬时的位置是连续变化的。</li>
<li>马尔可夫性：布朗运动满足马尔可夫性质，即未来的运动只与当前的位置有关，而与过去的运动路径无关。</li>
<li>独立增量：布朗运动的位置变化是具有独立增量的，即在不同时间段上的位置变化是相互独立的。</li>
</ul>
<p>布朗运动在物理学、金融学、生物学等领域具有广泛的应用。它可以用来描述微粒在流体中的扩散、金融市场中的价格变动、细胞内分子的运动等随机现象。布朗运动的数学描述采用随机微分方程，其中包括随机增量项，用来表示随机性和不确定性。</p>
<h3 id="鞅过程"><a href="#鞅过程" class="headerlink" title="鞅过程"></a>鞅过程</h3><p>鞅过程（Martingale Process）是一种随机过程，它在概率论和数学金融领域中具有重要的应用。鞅过程是一种随机变量序列，它满足一定的条件，其中最重要的性质是<strong>条件期望的无偏性</strong>。</p>
<p>具体而言，设{X(t), t ≥ 0}是一个随机过程，定义在一个概率空间上，关于时间t的随机变量。如果对于任意的s ≤ t，条件期望E[X(t) | X(s)]等于X(s)，即 <code>E[X(t) | X(s)] = X(s)</code>，那么这个随机过程被称为鞅过程。</p>
<p>换句话说，鞅过程在任意时刻的当前值的条件期望等于过去时刻的值，表明鞅过程在平均意义上不随时间变化而漂移。</p>
<p>一个典型的实际案例是赌博游戏中的赌徒之行。</p>
<p>假设有一个赌徒在每轮游戏中抛掷硬币，正面朝上赢得1单位的奖励，反面朝上输掉1单位的赌注。我们可以用一个鞅过程来描述赌徒的资金变化。假设赌徒的初始资金为0单位，并且在每轮游戏中抛硬币的结果是一个独立的随机事件。赌徒的资金变化可以表示为一个鞅过程<code>&#123;X(t), t ≥ 0&#125;</code>，其中X(t)表示赌徒在时间t时的资金。</p>
<p>在这个例子中，条件期望的无偏性意味着在任意时刻t，赌徒的当前资金的条件期望等于过去时刻的资金，即 <code>E[X(t) | X(s)] = X(s)</code>，其中s ≤ t。<br>这意味着赌徒在每轮游戏中没有系统性地赢或输。无论他之前的赢利或亏损情况如何，当前的资金预期值等于他之前的资金。</p>
<p>鞅过程在金融市场建模、随机控制理论、概率论等领域有广泛的应用。它在金融中可以用来描述资产价格的动态演化、期权定价、风险度量等。在概率论中，鞅过程是一类重要的随机过程，其具有丰富的性质和数学结构，被广泛研究和应用。</p>
<h2 id="大数定理，中心极限定理"><a href="#大数定理，中心极限定理" class="headerlink" title="大数定理，中心极限定理"></a>大数定理，中心极限定理</h2><h3 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a>大数定理</h3><p>大数定理（Law of Large Numbers）是概率论中的一条重要定理，描述了随机变量序列的均值的收敛性质。它指出，当随机变量的样本容量足够大时，样本均值将接近于随机变量的期望值。</p>
<h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><p>中心极限定理（Central Limit Theorem）是概率论和统计学中的重要结果之一。它描述了在一定条件下，当独立随机变量的数量足够大时，它们的平均值的分布将近似于正态分布。</p>
<p>中心极限定理的主要内容如下：</p>
<p>假设有n个独立随机变量X1, X2, …, Xn，它们具有相同的分布和参数。这些随机变量的和S_n &#x3D; X1 + X2 + … + Xn的分布在n趋近于无穷大时，以及适当的标准化后，将近似于正态分布。</p>
<p>具体而言，当n足够大时，S_n的近似分布可以用正态分布来描述。</p>
<h2 id="参数估计-概率分布模型"><a href="#参数估计-概率分布模型" class="headerlink" title="参数估计(概率分布模型)"></a>参数估计(概率分布模型)</h2><p>在参数估计中，确实需要事先假设或确定一个概率分布模型(注意不是确定的模型，不然可以根据结果直接算出参数)。参数估计的前提是我们假设观测数据来自于某个特定的概率分布，而我们的目标是估计这个概率分布中的未知参数。</p>
<p>具体来说，参数估计的过程通常包括以下步骤：</p>
<ul>
<li>假设概率分布模型：我们需要根据问题的特点和领域知识，假设观测数据符合某个特定的概率分布模型，例如正态分布、泊松分布、伽马分布等。这个假设是基于对问题的理解和经验的。</li>
<li>确定参数：在所假设的概率分布模型中，可能存在一个或多个未知参数，我们需要明确这些参数，并确定我们想要估计的参数。</li>
<li>收集观测数据：根据实际情况，我们收集一组观测数据，作为对概率分布中参数的估计依据。</li>
<li>构建估计方法：根据所选的概率分布模型和参数，我们构建相应的估计方法，例如最大似然估计、矩估计等。</li>
<li>估计参数：利用观测数据和估计方法，计算出对未知参数的估计值。</li>
</ul>
<p>需要注意的是，参数估计的准确性和可靠性依赖于所假设的概率分布模型的正确性和数据的充分性。如果所假设的概率分布模型与实际情况不符，或者观测数据过少或存在较大的噪声，估计结果可能会出现偏差或不准确的情况。</p>
<p>因此，在参数估计之前，我们需要对问题进行合理的假设和模型选择，并在数据收集和估计方法的过程中考虑到模型假设的合理性和数据的质量。</p>
<h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><p>贝叶斯定理是概率论中的一个基本定理，描述了在观测到新的证据（观测数据）后，如何更新对某个事件的概率估计。</p>
<p>假设有两个事件 A 和 B，其中事件 A 是我们要推断或估计的事件，而事件 B 是观测到的证据。贝叶斯定理表述如下：</p>
<p><code>P(A|B) = (P(B|A) * P(A)) / P(B)</code></p>
<p>其中：</p>
<ul>
<li><code>P(A|B)</code> 是在观测到事件 B 后事件 A 发生的条件概率，也称为后验概率。</li>
<li><code>P(B|A)</code> 是在事件 A 发生的条件下观测到事件 B 的概率，也称为似然函数。</li>
<li><code>P(A)</code> 是事件 A 的先验概率，即在观测到事件 B 之前对事件 A 发生的估计。</li>
<li><code>P(B)</code> 是事件 B 的边际概率，即观测到事件 B 的概率。</li>
</ul>
<p>贝叶斯定理的核心思想是通过观测到的证据（事件 B），更新对事件 A 的概率估计。它将先验概率和似然函数结合起来，得到后验概率。具体而言，贝叶斯定理可以用于根据已知信息更新模型参数、进行推断、进行分类等。</p>
<p>贝叶斯定理在贝叶斯统计学中具有重要的应用，它允许我们利用已有知识（先验）和新的证据（似然函数）来更新对未知事件的估计（后验）。通过不断地更新先验概率，我们可以根据新的观测数据获得更准确和可靠的后验概率估计。</p>
<h3 id="先验分布-后验概率分布"><a href="#先验分布-后验概率分布" class="headerlink" title="先验分布 后验概率分布"></a>先验分布 后验概率分布</h3><p>在贝叶斯统计中，先验分布和后验概率分布是两个关键概念，用于描述我们对参数的初始信念和通过观测数据更新后的信念。</p>
<ul>
<li>先验分布（Prior Distribution）：先验分布是在观测数据之前对参数的分布做出的<strong>假设或先验信念</strong>。它反映了我们在观测数据之前对参数可能取值的主观或客观的认识。先验分布通常用一个概率分布函数来表示，例如贝塔分布、高斯分布等。先验分布可以看作是参数的<strong>初始猜测</strong>，它对参数的可能取值进行了一定的限制或权重。</li>
<li>后验概率分布（Posterior Probability Distribution）：后验概率分布是在观测到数据后，通过贝叶斯定理将先验分布与似然函数结合起来得到的参数分布。它表示了在考虑观测数据之后，对参数取值的更新后的概率分布。后验概率分布结合了先验信息和观测数据的信息，提供了对参数的更准确估计，并反映了参数的不确定性程度。</li>
</ul>
<p>先验分布和后验概率分布之间的关系可以用贝叶斯定理来表示：</p>
<p><code>后验概率分布 ∝ 先验分布 × 似然函数</code></p>
<p>其中，似然函数描述了观测数据出现的可能性。通过将先验分布与观测数据的似然函数相乘，并进行适当的归一化，可以得到后验概率分布。</p>
<p>贝叶斯统计的核心思想是通过不断地更新先验分布，利用观测数据提供的信息，得到后验概率分布，并在此基础上做出推断和决策。先验分布提供了先验知识和信念，而后验概率分布则是在<strong>考虑观测数据后对参数的更新和修正</strong>。</p>
<h3 id="点估计与无偏性"><a href="#点估计与无偏性" class="headerlink" title="点估计与无偏性"></a>点估计与无偏性</h3><p>点估计（Point Estimation）是参数估计的一种方法，它通过使用样本数据来估计总体参数的具体值。点估计的目标是找到一个单一的估计值，作为对未知参数的最佳猜测。</p>
<p>无偏性是点估计的性质之一。一个无偏估计是指在重复抽样的情况下，<strong>估计值的期望</strong>等于被估计参数的真实值。换句话说，如果一个估计值的期望与真实参数值相等，则该估计值是无偏的。</p>
<h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3><ul>
<li>使用使用样本矩来逼近&#x2F;替代总体矩，从而得到参数的估计值。<ul>
<li>样本矩（Sample Moments）：样本矩是根据从总体中抽取的样本数据计算得出的统计量。常见的样本矩包括样本均值、样本方差、样本偏度、样本峰度等。</li>
</ul>
</li>
</ul>
<h3 id="最大似然估计与EM算法"><a href="#最大似然估计与EM算法" class="headerlink" title="最大似然估计与EM算法"></a>最大似然估计与EM算法</h3><ul>
<li>最大似然估计(maximum likelihood estimation，MLE)，或者最大对数似然：<ul>
<li>简单来说：估计的是已知概率分布模型的参数值，输入是测试的结果&#x2F;样本。简单来说，模型已定，参数未知下，用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！</li>
</ul>
</li>
</ul>
<p>最大似然估计的基本思想是，在给定观测数据的情况下，寻找使得观测数据的联合概率密度函数（或概率质量函数）最大化的参数值。具体步骤包括以下几个步骤：</p>
<ul>
<li>建立概率模型：首先需要确定一个适当的概率模型，假设观测数据满足某个概率分布，如正态分布、泊松分布等。</li>
<li>构建似然函数：根据概率模型，将观测数据的联合概率密度函数（或概率质量函数）表示为参数的函数，即似然函数。似然函数描述了在给定参数值的情况下，观测数据出现的可能性。</li>
<li>寻找最大似然估计：通过优化方法（如求导、迭代算法等），找到使得似然函数最大化的参数值。最大似然估计的目标是寻找最可能产生观测数据的参数值，使得观测数据的出现概率最大化。</li>
</ul>
<p>最大似然估计具有一些良好的性质，例如在大样本下，最大似然估计的估计值具有<strong>渐近正态分布</strong>，且具有一致性和渐进有效性等特性。最大似然估计在统计学和机器学习等领域中广泛应用，用于估计参数、构建模型和进行推断。</p>
<ul>
<li>EM算法（Expectation-Maximization Algorithm）是一种迭代优化算法，用于在存在隐变量或缺失数据的统计模型中进行参数估计。它通过交替进行两个步骤：E步（Expectation Step）和M步（Maximization Step），以最大化似然函数或完成参数的最大似然估计。</li>
</ul>
<p>EM算法的基本思想是通过引入隐变量，将含有缺失数据的问题转化为完全数据的问题。具体步骤如下：</p>
<ul>
<li>初始化参数：首先需要对模型的参数进行初始化。</li>
<li>E步（Expectation Step）：在E步中，根据当前参数的估计值，计算隐变量的后验概率（或期望），即给定观测数据下隐变量的分布。这一步利用当前参数的估计值进行”填补”缺失数据或估计隐变量的取值。</li>
<li>M步（Maximization Step）：在M步中，根据E步得到的隐变量后验概率，重新估计模型的参数。这一步通过最大化完全数据的对数似然函数来更新参数的估计值。</li>
<li>迭代更新：重复进行E步和M步，直到参数的估计值收敛或满足停止准则。</li>
</ul>
<p>EM算法通过迭代的方式逐步优化参数的估计值，使得在每次迭代中似然函数都得到增大，从而逐渐逼近最优参数值。由于每次迭代中的E步和M步都可以分别求解，因此EM算法在理论上保证了在每一步都能得到似然函数的增加。然而，EM算法并不能保证收敛到全局最优解，可能陷入局部最优解。</p>
<p>EM算法在许多统计学和机器学习问题中都有广泛的应用，特别是在存在隐变量的概率模型、混合模型、高斯混合模型等领域中。它为解决这些问题提供了一种有效的参数估计方法。</p>
<h3 id="最小方差无偏估计"><a href="#最小方差无偏估计" class="headerlink" title="最小方差无偏估计"></a>最小方差无偏估计</h3><ul>
<li>对于小样本， 无偏估计使用<strong>最小方差</strong>，对于有偏估计常使用<strong>均方误差</strong>。<ul>
<li>有偏估计是指在统计学中，估计量的期望值不等于被估计参数的真实值。换句话说，有偏估计会在估计过程中引入一定的系统性偏差。</li>
<li>我的理解, 你设计的模型，就不是真实的(也无法保证)，自然就从根本上不完全准确，有系统性偏差，所以常用均方误差。</li>
</ul>
</li>
</ul>
<h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>频率学派和贝叶斯学派是统计学中两种不同的观点或方法论。</p>
<p>频率学派（Frequentist Approach）注重使用频率或概率的概念进行推断和估计。在频率学派中，参数被视为固定但未知的，通过基于样本数据的统计量来推断参数的值。频率学派强调利用大量的重复抽样来研究统计性质，并通过估计量的偏差、方差和置信区间等指标来评估估计的准确性和可靠性。</p>
<p>贝叶斯学派（Bayesian Approach）则采用贝叶斯定理和概率论的观点来进行推断和估计。在贝叶斯学派中，参数被视为随机变量，其先验分布和样本数据的条件下的后验分布共同决定了参数的估计。贝叶斯学派注重将<strong>先验知识或信念</strong>结合到推断过程中，并使用后验分布来提供关于参数的概率分布以及置信区间等信息。</p>
<p>贝叶斯估计是贝叶斯学派中一种参数估计的方法。它利用贝叶斯定理计算参数的后验分布，并将后验分布作为参数的估计。贝叶斯估计不仅考虑了样本数据的信息，还结合了<strong>先验知识或信念</strong>，因此可以提供更全面和灵活的估计结果。贝叶斯估计还可以通过调整先验分布的参数或选择不同的先验分布来灵活地处理不同的问题和背景。</p>
<p>需要注意的是，频率学派和贝叶斯学派并不是相互排斥的，它们是统计学中不同的方法论和观点，各自有其适用的领域和优势。在实际应用中，可以根据问题的特点、数据的性质以及研究目的来选择适合的学派和方法。</p>
<h3 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h3><p>区间估计是统计学中一种参数估计的方法，用于估计未知参数的范围或区间。与点估计不同，区间估计提供了一个范围，该范围内有一定的置信度（置信水平）包含了真实参数值。</p>
<p>区间估计的基本思想是通过样本数据来构建一个区间，该区间涵盖了真实参数值的可能范围。在频率学派中，常用的区间估计方法包括置信区间。置信区间是基于样本数据计算出来的一个区间，其具体形式为”估计值 ± 误差”，其中误差由抽样误差和估计误差组成。</p>
<p>置信区间的置信水平表示该区间在重复抽样中包含真实参数值的概率。例如，95%的置信水平意味着在多次重复抽样中，有95%的置信区间会包含真实参数值。</p>
<p>区间估计的优势在于提供了对未知参数范围的估计，并提供了对估计结果的不确定性的量化。它能够更全面地反映估计的可靠性，并且可以与其他区间进行比较，进行统计推断和假设检验等。</p>
<p>需要注意的是，区间估计并不提供关于真实参数值的具体点估计，而是提供了一个范围。不同的置信水平会得到不同宽度的区间，较高的置信水平通常会导致较宽的区间。在应用中，选择适当的置信水平需要权衡估计的准确性和置信区间的宽度。</p>
<h2 id="方差回归与回归分析"><a href="#方差回归与回归分析" class="headerlink" title="方差回归与回归分析"></a>方差回归与回归分析</h2><h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-13T16:00:00.000Z" title="6/13/2023, 4:00:00 PM">2023-06-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.194Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">39 minutes read (About 5909 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/13/Work/Artificial%20Intelligence/framework/pytorch/">Pytorch</a></p><div class="content"><article class="message is-info">
        <div class="message-header"><p><i class="fa-solid fa-clipboard mr-2"></i>导言</p>
</div>
        <div class="message-body">
            <p>（本人是rookie，纯小白~</p>

        </div>
    </article></div><a class="article-more button is-small is-size-7" href="/2023/06/13/Work/Artificial%20Intelligence/framework/pytorch/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-03T16:00:00.000Z" title="6/3/2023, 4:00:00 PM">2023-06-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.206Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithms/">Algorithms</a></span><span class="level-item">16 minutes read (About 2454 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/03/Work/Algorithms/algorithm/">Algorithm: leetcode</a></p><div class="content"><h2 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h2><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img src="https://pic.shaojiemike.top/img/20230604160214.png"></p>
<ul>
<li>排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。</li>
<li>计数排序 中 k是数据出现的范围</li>
<li>基数排序时间复杂度为O(N*M)，其中N为数据个数，M为数据位数。</li>
</ul>
<h3 id="按照实现方法分类"><a href="#按照实现方法分类" class="headerlink" title="按照实现方法分类"></a>按照实现方法分类</h3><ul>
<li><p>选择排序</p>
<ul>
<li>直接选择排序：N轮，每轮变小的范围内找到最小值，然后与第i个交换。</li>
<li>堆排序：<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">最大堆与数组的映射关系</a> 大顶堆：<code>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</code>  </li>
<li>维护每轮范围变小的堆，每次将最大的堆顶移动到最后。每次维护堆需要O(logn)交换，把pop上来的小元素沉底到叶节点。</li>
<li>初始建堆需要O(nlogn)</li>
</ul>
</li>
</ul>
</li>
<li><p>插入排序</p>
<ul>
<li>直接插入：N轮，每轮从i开始向前插入（移动来交换），直到插入到合适的位置</li>
<li>希尔排序: 希尔排序是插入排序改良的算法，<ul>
<li>希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，</li>
<li>直至步长为1，步长选择是关键。</li>
</ul>
</li>
</ul>
</li>
<li><p>交换排序</p>
<ul>
<li>冒泡排序：冒泡N轮，每轮变小的范围内确定最后一个。</li>
<li>快速排序：在数组中随机选一个数（默认数组首个&#x2F;末尾元素），数组中小于等于此数的放在左边部分(<strong>交换到前面的排列</strong>)，大于此数的放在右边部分，这个操作确保了这个数是处于正确位置的，再对左边部分数组和右边部分数组递归调用快速排序，重复这个过程。</li>
</ul>
</li>
<li><p>分治合并</p>
<ul>
<li>归并排序： 首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次合并进行得到长度为4、8、16的区间，直到合成整个区间。</li>
</ul>
</li>
<li><p>计数排序：数据出现的范围k &lt;&lt; O(n)时，或者k&#x3D;O(n)都可以采用该方法。</p>
</li>
<li><p>基数排序：对数据的每一位(共M位)从低位到高位进行stableSort。大部分时候选择计数排序O(N+k)。总时间复杂度O(M*(N+k))</p>
</li>
<li><p>桶排序：类似计数排序的思想，但是一般是对于区间等分为桶。桶内可以采用插入排序。n个元素n个桶，数学期望是O(n)</p>
</li>
</ul>
<h3 id="堆排序代码细节"><a href="#堆排序代码细节" class="headerlink" title="堆排序代码细节"></a>堆排序代码细节</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//先建立堆</span></span><br><span class="line">    <span class="keyword">for</span> (i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(array,i,n);<span class="comment">//从下向上，从右向左调整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换最大堆顶，重复n次</span></span><br><span class="line">    <span class="keyword">for</span>( i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(array, <span class="number">1</span>, i);</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(array, <span class="number">1</span>, i<span class="number">-1</span>);<span class="comment">//从上到下，从左向右调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> s, <span class="type">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,temp;</span><br><span class="line">    temp = array[s];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>*s;i&lt;=n;i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n&amp;&amp;array[i]&lt;array[i<span class="number">+1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换左右子树最大的那个</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=array[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了插入的合适的位置，子节点更小，父节点更大</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点向上移动</span></span><br><span class="line">        array[s]=array[i];</span><br><span class="line">        s=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最顶部插入到合适的位置</span></span><br><span class="line">    array[s]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp=array[i];</span><br><span class="line">    array[i]=array[j];</span><br><span class="line">    array[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序相关的问题"><a href="#排序相关的问题" class="headerlink" title="排序相关的问题"></a>排序相关的问题</h3><ul>
<li>既然时间复杂度堆排序、归并排序好于快排，为什么C++的qsort使用的是快排<ul>
<li>快速排序访存更友好，堆排序访问是跳跃的</li>
<li>对于同样的数据，排序过程中，堆排序算法的数据交换次数多于快排<ul>
<li>堆排序建立堆，与堆顶的交换，很多时候都是无用功</li>
</ul>
</li>
<li>在数据量小的时候快速排序当属第一，堆排序最差，但随着数据的不断增大归并排序的性能会逐步赶上并超过快速排序，性能成为三种算法之首。</li>
</ul>
</li>
<li>C++ 的 stable_sort 是基于归并排序的</li>
</ul>
<h2 id="LeetCode-常见算法"><a href="#LeetCode-常见算法" class="headerlink" title="LeetCode 常见算法"></a>LeetCode 常见算法</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序常用来确定一个依赖关系集(图关系)中，事物发生的顺序。</p>
<p>带信号量判断的无依赖队列来实现，入队无依赖集合，出队的无依赖元素(add to result)去除后续元素的依赖信号量，信号量为0代表无依赖，可以入队。</p>
<h3 id="无环图（树图）中最长距离"><a href="#无环图（树图）中最长距离" class="headerlink" title="无环图（树图）中最长距离"></a>无环图（树图）中最长距离</h3><p>找到图中距离最远的两个节点与它们之间的路径：</p>
<p>以任意节点 pp 出现，利用广度优先搜索或者深度优先搜索找到以 pp 为起点的最长路径的终点 xx；</p>
<p>以节点 xx 出发，找到以 xx 为起点的最长路径的终点 yy；</p>
<p>xx 到 yy 之间的路径即为图中的最长路径，找到路径的中间节点即为根节点。</p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/article/9ixykn/">https://leetcode-cn.com/circle/article/9ixykn/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-mutable/">https://leetcode-cn.com/problems/range-sum-query-mutable/</a></p>
<h3 id="广度搜索确定图中各点对0点最近距离"><a href="#广度搜索确定图中各点对0点最近距离" class="headerlink" title="广度搜索确定图中各点对0点最近距离"></a>广度搜索确定图中各点对0点最近距离</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input [[0,1],[1,2]]</span></span><br><span class="line"><span class="comment">//维护</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; adj(n); <span class="comment">//先找出每个点的有关边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; <span class="title function_">visit</span><span class="params">(n, <span class="literal">false</span>)</span>;   <span class="comment">//维护已访问元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">qu.emplace(<span class="number">0</span>);</span><br><span class="line">visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> dist = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!qu.empty()) &#123;</span><br><span class="line">    <span class="type">int</span> sz = qu.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> curr = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : adj[curr]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[v]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qu.emplace(v);</span><br><span class="line">            <span class="comment">//对应处理</span></span><br><span class="line">            visit[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dist++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2进制数表示子集合"><a href="#2进制数表示子集合" class="headerlink" title="2进制数表示子集合"></a>2进制数表示子集合</h3><p>对集合大小为n，可以用大于等于0小于<code>1&lt;&lt;n</code>的<code>2^n-1</code>个数字来表示子集。</p>
<p>但是对每个子集都会单独计算，有重复。 不如用按每位是否存在回溯</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">2044</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countMaxOrSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> maxOr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)&#123;</span><br><span class="line">            maxOr = n | maxOr;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums, maxOr, <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> maxOr, <span class="type">int</span> idx, <span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == maxOr)&#123;</span><br><span class="line">            ans += <span class="number">1</span> &lt;&lt; (nums.size()-idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == nums.size())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(nums, maxOr, idx+<span class="number">1</span>, cur | nums[idx]);</span><br><span class="line">        dfs(nums, maxOr, idx+<span class="number">1</span>, cur);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2进制表示使用状态true-false"><a href="#2进制表示使用状态true-false" class="headerlink" title="2进制表示使用状态true false"></a>2进制表示使用状态true false</h3><p>int 可以表示32个元素的使用情况</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/can-i-win/">https://leetcode.cn/problems/can-i-win/</a></p>
<h3 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h3><p><code>前缀和</code><br>和<code>差分</code><br>是一组互逆的方法；他们的关系和<code>积分</code><br>与<code>求导</code><br>实质是一样的。前缀和可以帮我们通过预处理快速的求出区间的和；差分则可以快速帮助我们记录区间的修改。</p>
<p>将区间前一个加一，最后一个减一实现。</p>
<p>leetcode 798</p>
<h3 id="预处理查询的数组"><a href="#预处理查询的数组" class="headerlink" title="预处理查询的数组"></a>预处理查询的数组</h3><p>通过预处理记录信息来减少查询的时间</p>
<p>leetcode 2055</p>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>二分寻找满足条件的最小整数,  注意<code>left + 1 &lt; right</code>和<code>s &gt;= cars</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123; <span class="comment">// 开区间</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = (left + right) / <span class="number">2</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r : ranks)</span><br><span class="line">        s += <span class="built_in">sqrt</span>(mid / r);</span><br><span class="line">    (s &gt;= cars ? right : left) = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作者：灵茶山艾府</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode.cn/problems/minimum-time-to-repair-cars/solutions/2177199/er-fen-da-an-pythonjavacgo-by-endlessche-keqf/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>

<h3 id="直接模拟"><a href="#直接模拟" class="headerlink" title="直接模拟"></a>直接模拟</h3><p>最常用的方法</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>根据设定的哈希函数H（key）和处理冲突方法将一组关键字映象到一个有限的地址区间上的算法。也称为散列算法、杂凑算法。</p>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>一般有：开放定址法、链地址法（拉链法）、再哈希法、建立公共溢出区</p>
<h2 id="LeetCode-代码优化加速"><a href="#LeetCode-代码优化加速" class="headerlink" title="LeetCode 代码优化加速"></a>LeetCode 代码优化加速</h2><h3 id="cin-tie与sync-with-stdio加速输入输出"><a href="#cin-tie与sync-with-stdio加速输入输出" class="headerlink" title="cin.tie与sync_with_stdio加速输入输出"></a>cin.tie与sync_with_stdio加速输入输出</h3><p>std::ios::sync_with_stdio(); 是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。也就是 C++标准streams(cin,cout,cerr…) 与相应的C标准程序库文件(stdin,stdout,stderr)同步，使用相同的 stream 缓冲区。<br>默认是同步的，但由于同步会带来某些不必要的负担，因此该函数作用是使得用户可以自行取消同步。</p>
<p>cin.tie(NULL) 取消 cin 和 cout 的绑定。</p>
<p>这对于输入数据个数<strong>在10^5以上的程序十分有效</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> x = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> io_sync_off = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(nullptr);</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> init = []() &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(nullptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<h3 id="问题拆分循环调用"><a href="#问题拆分循环调用" class="headerlink" title="问题拆分循环调用"></a>问题拆分循环调用</h3><p>不如从底层动态规划合并，不要嵌套函数调用，还可以用二维数据，数据局部性较好。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/optimal-division/submissions/">https://leetcode-cn.com/problems/optimal-division/submissions/</a></p>
<h3 id="不一定要执着数据只遍历一遍"><a href="#不一定要执着数据只遍历一遍" class="headerlink" title="不一定要执着数据只遍历一遍"></a>不一定要执着数据只遍历一遍</h3><p>可以将复杂的一次遍历，拆开成两次遍历，一次处理数据并存储，一次遍历统计。速度反而会快</p>
<h3 id="简单递归循环"><a href="#简单递归循环" class="headerlink" title="简单递归循环"></a>简单递归循环</h3><p>用while代替函数递归调用，eg二分法</p>
<h3 id="减少if语句"><a href="#减少if语句" class="headerlink" title="减少if语句"></a>减少if语句</h3><p>可以保存分支的值来实现(1748)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//0ms</span><br><span class="line">int sumOfUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"> int state[101]&#123;&#125;, ans = 0, d[101]&#123;1,-1&#125;;</span><br><span class="line"> for(int x: nums) ans += d[state[x]++] * x;</span><br><span class="line"> return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//4ms</span><br><span class="line">int sumOfUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"> array&lt;char,101&gt; isshowed &#123;&#125;;</span><br><span class="line"> int sum=0;</span><br><span class="line"> for(auto&amp; num:nums)&#123;</span><br><span class="line">  if(isshowed[num]==0)&#123;</span><br><span class="line">   isshowed[num]=1;</span><br><span class="line">   sum+=num;</span><br><span class="line">  &#125;else if(isshowed[num]==1)&#123;</span><br><span class="line">   isshowed[num]=2;</span><br><span class="line">   sum-=num;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通过判断筛选掉"><a href="#通过判断筛选掉" class="headerlink" title="通过判断筛选掉"></a>通过判断筛选掉</h3><p>无用的遍历计算(1219)</p>
<h3 id="减少for循环"><a href="#减少for循环" class="headerlink" title="减少for循环"></a>减少for循环</h3><p>循环展开，只有一两种情况就不要写for循环了</p>
<h2 id="注意的细节"><a href="#注意的细节" class="headerlink" title="注意的细节"></a>注意的细节</h2><h3 id="计算防止溢出"><a href="#计算防止溢出" class="headerlink" title="计算防止溢出"></a>计算防止溢出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2</span><br></pre></td></tr></table></figure>

<h3 id="转化成加减，而不用乘法"><a href="#转化成加减，而不用乘法" class="headerlink" title="转化成加减，而不用乘法"></a>转化成加减，而不用乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &lt; B/2</span><br><span class="line">变成</span><br><span class="line">A &lt; B-A</span><br></pre></td></tr></table></figure>

<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/basic/">https://oi-wiki.org/dp/basic/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md">https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md</a></p>
<p>作者：AC_OIer<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/gong-shui-san-xie-zhuang-ya-dp-yun-yong-gz4w5/">https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/gong-shui-san-xie-zhuang-ya-dp-yun-yong-gz4w5/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-06-03T16:00:00.000Z" title="6/3/2023, 4:00:00 PM">2023-06-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.174Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Operating-system/">Operating system</a></span><span class="level-item">23 minutes read (About 3463 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/03/Work/Operating%20system/lock/">Lock</a></p><div class="content"><h2 id="互斥与同步的实现和使用"><a href="#互斥与同步的实现和使用" class="headerlink" title="互斥与同步的实现和使用"></a>互斥与同步的实现和使用</h2><p>在进程&#x2F;线程并发执行的过程中，进程&#x2F;线程之间存在协作的关系，例如有互斥、同步的关系。</p>
<p>为了实现进程&#x2F;线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：</p>
<ul>
<li><p>锁：加锁、解锁操作；</p>
<ul>
<li>自旋锁(spin lock， 忙等待锁)，基于原子操作指令 —— 测试和置位（Test-and-Set）指令</li>
<li>无等待锁：思想，把当前线程放入到锁的等待队列，然后执行调度程序</li>
</ul>
</li>
<li><p>信号量：P、V 操作；</p>
</li>
</ul>
<p>这两个都可以方便地实现进程&#x2F;线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程&#x2F;线程同步。</p>
<h2 id="锁相关问题"><a href="#锁相关问题" class="headerlink" title="锁相关问题"></a>锁相关问题</h2><ol start="6">
<li>共享内存加锁之后释放锁，别的进程是如何知道锁释放的<ol>
<li>常用的方法是在共享内存中设置<strong>标志位或信号量</strong>等，并在共享内存中保证这个标志位或信号量只有在锁被释放时才会被更新。这样，其它进程可以通过<strong>轮询或者等待通知</strong>的方式来获取锁并开始修改共享内存，从而避免冲突。在共享内存中设置的标志位或信号量通常需要原子操作的支持，以确保并发修改时的正确性。<ol>
<li>轮询：轮询是指线程反复检查某个条件是否成立，直到条件成立为止。在锁机制中，当一个线程持有锁时，其他线程会不断地轮询锁的状态，直到该锁被释放。这种方式的优点是实现简单，不需要额外的通知机制，缺点是占用CPU资源，效率较低。</li>
<li>等待通知：等待通知是指线程在某个条件不满足时挂起等待，当条件满足时由其他线程通知它继续执行。在锁机制中，当一个线程持有锁时，其他线程会进入等待状态，直到该锁被释放，此时其他线程会被通知并继续执行。这种方式的优点是占用CPU资源少，效率高，缺点是实现稍微复杂一些，需要额外的通知机制。</li>
</ol>
</li>
<li>另外，也可以使用一个中央锁服务器或者等待队列来管理锁，当一个进程获取锁时，会向中央锁服务器或等待队列发出请求，直到锁被成功获取，并在共享内存中记录锁的状态。当锁被释放时，中央锁服务器或等待队列会通知其它进程，并让其它进程开始自由修改共享内存。</li>
</ol>
</li>
<li>如何保证操作的原子性<ol>
<li>操作系统提供的原子操作：一些操作系统会提供线程安全的原子操作接口，如Compare-And-Swap（CAS）等，它们能够确保指令的原子性，从而保证线程安全。</li>
<li>事务：事务是指一组操作被视为一个不可分割的操作序列，要么全部执行成功，要么全部失败，具有原子性和一致性保证。常用于数据库操作等场景。</li>
<li>锁机制：锁机制是一种常用的多线程同步机制，能够确保同一时刻只有一个线程（或进程）可以访问共享资源，从而保证原子性。</li>
</ol>
</li>
<li>如何避免死锁<ol>
<li>避免使用多把锁并且同时持有多个锁。当需要持有多个锁时，可以通过加锁的顺序来避免死锁。如果所有可能的锁按照固定的顺序加锁，那么可以避免死锁。</li>
<li>设置请求超时时间。当一个进程请求锁时，如果在超时时间内没有获得锁，可以释放之前持有的锁，并尝试重新获取。这样可以避免某一个进程一直持有锁而导致死锁。</li>
<li>引入随机性。在获取锁的时候加入一些随机因素，让不同的程序在不同的时间获取锁。这样可以防止程序之间在自己的重试过程中的饥饿状态导致的死锁。</li>
</ol>
</li>
</ol>
<h2 id="RedStar-小红书-笔试"><a href="#RedStar-小红书-笔试" class="headerlink" title="RedStar (小红书) 笔试"></a>RedStar (小红书) 笔试</h2><h3 id="图中有依赖的任务的，需要几个信号量来实现同步"><a href="#图中有依赖的任务的，需要几个信号量来实现同步" class="headerlink" title="图中有依赖的任务的，需要几个信号量来实现同步"></a>图中有依赖的任务的，需要几个信号量来实现同步</h3><p>如<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45385429/article/details/115250919">CSDN</a>，有一条依赖线，需要一个信号量</p>
<p>在使用信号量(Semaphore)进行线程同步时,P(proberen)和V(verhogen)操作是非常重要的概念。</p>
<ol>
<li>P操作（也称为Wait操作或Down操作）：</li>
</ol>
<ul>
<li>表示获取或等待信号量。</li>
<li>如果信号量内部计数值大于0,获取信号量并将计数值减1。</li>
<li>如果计数值等于0,线程将等待,直到计数值大于0。如果信号量的值大于0，表示资源可用，进程可以继续执行。如果信号量的值为0，表示资源不可用，P操作将阻塞（即等待）进程，直到该信号量的值大于0为止。</li>
</ul>
<p>伪代码表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(S):</span><br><span class="line">  while S &lt;= 0:</span><br><span class="line">    // 等待，直到S大于0</span><br><span class="line">  S = S - 1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>V操作（也称为Signal操作或Up操作）：</li>
</ol>
<ul>
<li>表示释放或增加信号量。</li>
<li>将信号量内部计数值加1。</li>
<li>如果存在等待线程,唤醒其中一个线程继续执行。</li>
</ul>
<p>伪代码表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V(S):</span><br><span class="line">  S = S + 1</span><br></pre></td></tr></table></figure>

<p>P和V操作保证了对共享资源的互斥访问。</p>
<p>一个线程使用P操作等待获取信号量,V操作在使用完共享资源后释放信号量。</p>
<p>信号量的值通常用于控制共享资源的数量，它可以是<strong>非负整数</strong>。当信号量被初始化为1时，称为二进制信号量（Binary Semaphore），因为它只能取0或1的值，通常用于实现互斥访问临界区。如果信号量的值大于1，称为计数信号量，可用于限制对资源的并发访问数。</p>
<p>在实际编程中，P操作和V操作通常是原子操作，确保在多线程或多进程环境下的正确同步和竞争条件的安全处理。</p>
<h2 id="TP-link笔试"><a href="#TP-link笔试" class="headerlink" title="TP-link笔试"></a>TP-link笔试</h2><p>设计的程序在多个CPU上运行时，不应使用哪个实现多个CPU间的数据访问同步？</p>
<ul>
<li><p>自旋锁(spinlock): 多线程同步的一种忙等待锁，线程反复检查锁变量是否可用。</p>
<ul>
<li>优点：避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，操作系统的内核经常使用自旋锁。</li>
<li>缺点：如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度<ul>
<li>线程持有锁的时间越长，则持有该锁的线程将被 OS(Operating System) 调度程序中断的风险越大。</li>
</ul>
</li>
<li>解决办法： TicketLock 是采用排队叫号的机制。CLHLock和MCSLock通过链表的方式避免了减少了处理器缓存同步，极大的提高了性能，区别在于CLHLock是通过轮询其前驱节点的状态，而MCS则是查看当前节点的锁状态。</li>
</ul>
</li>
<li><p>互斥锁(mutex)：把自己阻塞起来（内核态和用户态之间的切换进入阻塞状态，可能上下文切换），等待重新调度请求。</p>
<ul>
<li>互斥锁的实现<ol>
<li>软件实现：软件互斥锁需要借助操作系统提供的原子操作（如Compare-And-Swap，CAS）来实现 优点是灵活性高 缺点是性能较低，</li>
<li>CAS操作需要三个参数，内存地址A，期望值V，新值N。执行过程如下：<ul>
<li>读取内存地址A的原始值，保存在临时变量Value中</li>
<li>比较Value和期待值V是否相等，如果相等则将内存地址A的值更新为新值N</li>
<li>如果内存地址A的值已经被其他线程改变，则不进行更新操作</li>
</ul>
</li>
</ol>
<ul>
<li>TAS（test and set）<ul>
<li>一个TAS指令包括两个子步骤，把给定的内存地址设置为1，然后返回之前的旧值。</li>
</ul>
<ol start="2">
<li>硬件实现：硬件互斥锁使用计算机硬件提供的特殊指令（如锁总线指令）来实现。当线程要获取锁时，它会发出一个锁总线指令，这个指令会占用系统总线，使得其他CPU无法读写内存。<ol>
<li>当lock前缀指令执行时，它将锁定处理器总线，确保其他处理器无法同时访问同一内存区域，</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>读写锁（ReadWrite Lock）</p>
<ul>
<li>在读操作和写操作之间提供了更细粒度的同步控制。</li>
<li>多个线程可以同时获取读锁，但只有一个线程能够获取写锁。<ul>
<li>读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态</li>
<li>规则<ul>
<li>当读写锁在写加锁模式下，任何试图对这个锁进行加锁的线程都会被阻塞，直到写进程对其解锁。</li>
<li>当读写锁在读加锁模式先，任何线程都可以对其进行读加锁操作，但是所有试图进行写加锁操作的线程都会被阻塞，直到所有的读线程都解锁。</li>
</ul>
</li>
</ul>
</li>
<li>缺点：当读者源源不断到来的时候，写者总是得不到读写锁，就会造成不公平的状态。<ul>
<li>避免方法： 当处于读模式的读写锁接收到一个试图对其进行写模式加锁操作时，便会阻塞后面对其进行读模式加锁操作的线程。这样等到已经加读模式的锁解锁后，写进程能够访问此锁保护的资源。</li>
</ul>
</li>
<li>优点：<ul>
<li>读写锁可以提高并发性，允许多个线程同时读取数据，而只有在需要修改数据时才会互斥。</li>
<li>适合对数据结构读的次数远远大于写的情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>RCU（Read-Copy-Update）</p>
<ul>
<li>对读写锁的一种改进。适用于读多写少场景的数据同步机制。</li>
<li>具体内容<ul>
<li>并发读取数据不再需要加锁</li>
<li>写数据时，RCU机制通过创建一个副本来实现读写分离，确保在更新过程中没有线程正在读取旧的数据。<ul>
<li>写者修改数据前首先拷贝一个被修改元素的副本，然后在副本上进行修改，修改完毕后它向垃圾回收器注册一个回调函数以便在适当的时机执行真正的修改操作。</li>
<li>读者必须提供一个信号给写者以便写者能够确定数据可以被安全地释放或修改的时机。</li>
<li>有一个专门的垃圾收集器来探测读者的信号，一旦所有的读者都已经发送信号告知它们都不在使用被RCU保护的数据结构，垃圾收集器就调用回调函数完成最后的数据释放或修改操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>悲观锁</p>
<ol>
<li><strong>读</strong>写操作时，需要预先加锁，防止其他进程对资源的访问。</li>
<li>通过<strong>互斥锁（Mutex）和信号量（Semaphore）</strong>来实现。</li>
</ol>
</li>
<li><p>乐观锁</p>
<ol>
<li>在读取或修改共享资源时，并不先进行加锁操作，而是先读取资源，然后在对资源进行写操作时再进行一次比较，看看在这个时间间隔内是否发生了竞争。如果没有发生竞争，就可以将更新后的值写入共享资源，并结束操作；如果发生了竞争，则需要放弃本次更新，并进行重试</li>
<li>通过<strong>版本号</strong>的方式来实现。在共享资源中记录该资源的版本号，当一个进程想要修改共享资源时，需要先获取当前资源的版本号。如果当前版本号与自己保存的版本号相符，说明没有其他进程在这段时间内修改该资源，则可以进行写操作；如果版本号已经发生变化，则说明有其他进程对该资源进行了修改，当前进程需要放弃本次写操作，更新版本号，重新获取新的资源，并重新执行操作。</li>
</ol>
</li>
</ul>
<p>下面回答部分<strong>来自ChatGPT-3.5</strong>，暂时没有校验其可靠性(看上去貌似说得通)。</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.cswiki.top/pages/f398f1/#blocking-i-o">https://www.cswiki.top/pages/f398f1/#blocking-i-o</a></p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15437629/article/details/79116590">https://blog.csdn.net/qq_15437629/article/details/79116590</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/161936748">https://zhuanlan.zhihu.com/p/161936748</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-30T16:00:00.000Z" title="5/30/2023, 4:00:00 PM">2023-05-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.162Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">24 minutes read (About 3665 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/30/Work/HPC/llvm-mca/LLVM-mca/">LLVM-MCA: docs</a></p><div class="content"><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>LLVM Machine Code Analyzer 是一种性能分析工具，它使用llvm中可用的信息（如调度模型）静态测量特定CPU中机器代码的性能。</p>
<p>性能是根据<strong>吞吐量</strong>和<strong>处理器资源消耗</strong>来衡量的。该工具目前适用于在后端中使用LLVM调度模型的处理器。</p>
<p>该工具的主要目标不仅是预测代码在目标上运行时的性能，还帮助诊断潜在的性能问题。</p>
<p>给定汇编代码，llvm-mca可以估计每个周期的指令数（IPC）以及硬件资源压力。分析和报告风格的灵感来自英特尔的IACA工具。</p>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/main/llvm/tools/llvm-mca">https://github.com/llvm/llvm-project/tree/main/llvm/tools/llvm-mca</a></p>
<h3 id="docs"><a href="#docs" class="headerlink" title="docs"></a>docs</h3><p><a target="_blank" rel="noopener" href="https://llvm.org/docs/CommandGuide/llvm-mca.html">https://llvm.org/docs/CommandGuide/llvm-mca.html</a></p>
<h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><h3 id="architecture"><a href="#architecture" class="headerlink" title="architecture"></a>architecture</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-mtriple=&lt;target triple&gt;</span><br><span class="line">    eg. -mtriple=x86_64-unknown-unknown</span><br><span class="line">-march=&lt;arch&gt;</span><br><span class="line">    Specify the architecture for which to analyze the code. It defaults to the host default target.</span><br><span class="line">-march=&lt;arch&gt;</span><br><span class="line">    Specify the architecture for which to analyze the code. It defaults to the host default target.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看支持的arch</span></span><br><span class="line">llc --version</span><br><span class="line"><span class="comment"># 查看具体支持的CPU Architecture</span></span><br><span class="line">llc -march=x86 -mattr=<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h3 id="output-report"><a href="#output-report" class="headerlink" title="output-report"></a>output-report</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-output-asm-variant=&lt;variant id&gt;</span><br><span class="line">    为工具生成的报告指定输出程序集变量。???</span><br><span class="line">-print-imm-hex</span><br><span class="line">    优先16进制输出。</span><br><span class="line">-json</span><br><span class="line">    除了瓶颈分析，基本都支持json格式输出视图</span><br><span class="line">-timeline</span><br><span class="line">    打印指令流水线情况</span><br></pre></td></tr></table></figure>

<h3 id="runtime-options"><a href="#runtime-options" class="headerlink" title="runtime options"></a>runtime options</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-dispatch=&lt;width&gt;</span><br><span class="line">    为处理器指定不同的调度宽度。调度宽度默认为处理器调度模型中的“IssueWidth”字段。</span><br><span class="line">-register-file-size=&lt;size&gt;</span><br><span class="line">    指定寄存器文件的大小。指定时，该项会限制可用于寄存器重命名的物理寄存器的数量。此标志的值为零意味着“无限数量的物理寄存器”。</span><br><span class="line">-iterations=&lt;number of iterations&gt;</span><br><span class="line">    指定要运行的迭代次数。如果此标志设置为 0，则该工具会将迭代次数设置为默认值（即 100）。</span><br><span class="line">-noalias=&lt;bool&gt;</span><br><span class="line">    loads and stores don’t alias</span><br><span class="line">-lqueue=&lt;load queue size&gt;</span><br><span class="line">-squeue=&lt;store queue size&gt;</span><br><span class="line">    在工具模拟的加载/存储单元中指定加载队列的大小。默认情况下，该工具假定加载队列中的条目数量不受限制。此标志的零值将被忽略，而是使用默认加载队列大小。</span><br><span class="line">-disable-cb</span><br><span class="line">    强制使用通用的 CustomBehaviour 和 InstrPostProcess 类，而不是使用目标特定的实现。通用类从不检测任何自定义危险或对指令进行任何后处理修改。</span><br></pre></td></tr></table></figure>

<h3 id="more-values-Info"><a href="#more-values-Info" class="headerlink" title="more values&#x2F;Info"></a>more values&#x2F;Info</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-resource-pressure</span><br><span class="line">    Enable the resource pressure view. This is enabled by default.</span><br><span class="line">-register-file-stats</span><br><span class="line">    启用注册文件使用统计。</span><br><span class="line">-dispatch-stats</span><br><span class="line">-scheduler-stats</span><br><span class="line">-retire-stats</span><br><span class="line">-instruction-info</span><br><span class="line">    启用额外的调度/发出/retire control unit统计。该视图收集和分析指令分派事件，以及静态/动态分派停顿事件。默认情况下禁用此视图。</span><br><span class="line">-show-encoding</span><br><span class="line">    打印指令16进制</span><br><span class="line">-all-stats</span><br><span class="line">-all-views</span><br><span class="line">-instruction-tables</span><br><span class="line">    这与资源压力视图不同，因为它不需要模拟代码。相反，它按顺序打印每个指令的资源压力的理论均匀分布。</span><br><span class="line">-bottleneck-analysis</span><br><span class="line">    打印有关影响吞吐量的瓶颈的信息。这种分析可能很昂贵，并且默认情况下是禁用的。瓶颈在摘要视图中突出显示。具有有序后端的处理器目前不支持瓶颈分析。???</span><br></pre></td></tr></table></figure>

<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><p><img src="https://pic.shaojiemike.top/img/38FD1039D93F746E0A45477E84CF74A0.png"></p>
<h2 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h2><h3 id="quick-overview-of-the-performance-throughput"><a href="#quick-overview-of-the-performance-throughput" class="headerlink" title="quick overview of the performance throughput"></a>quick overview of the performance throughput</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterations:        300</span><br><span class="line">Instructions:      900</span><br><span class="line">Total Cycles:      610</span><br><span class="line">Total uOps:        900</span><br><span class="line"></span><br><span class="line">Dispatch Width:    2</span><br><span class="line">uOps Per Cycle:    1.48</span><br><span class="line">IPC:               1.48</span><br><span class="line">Block RThroughput: 2.0</span><br></pre></td></tr></table></figure>

<ol>
<li>IPC<ol>
<li>理论最大值是$$\frac{OneLoopInstructions}{Block_RThroughput}&#x3D;(OneLoopInstructions)*(Block_Throughput)$$</li>
</ol>
</li>
<li>uOps Per Cycle<ol>
<li>simulated micro opcodes (uOps)</li>
<li><strong>每个周期的simulated micro opcodes数</strong></li>
<li>在不考虑循环依赖的情况下，理论上最大值是$$\frac{OneLoopUOps}{Block_RThroughput}&#x3D;(OneLoopUOps)*(Block_Throughput)$$</li>
<li>A delta between Dispatch Width and this field is an indicator of a performance issue.</li>
<li>The delta between the Dispatch Width (2.00), and the theoretical maximum uOp throughput (1.50) is an indicator of a performance bottleneck caused by the lack of hardware resources, and the Resource pressure view can help to identify the problematic resource usage.</li>
</ol>
</li>
<li>Dispatch Width<ol>
<li>发射到乱序后端的最大微指令操作数(the maximum number of micro opcodes&#x2F;uOps)？</li>
</ol>
</li>
<li>Block RThroughput (Block Reciprocal Throughput)<ol>
<li>在不考虑循环依赖的情况下，理论上的<strong>每次循环的最大block或者iterations数</strong></li>
<li>受限于dispatch rate和the availability of hardware resources.</li>
</ol>
</li>
</ol>
<h3 id="Instruction-info-view"><a href="#Instruction-info-view" class="headerlink" title="Instruction info view"></a>Instruction info view</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Instruction Info:</span><br><span class="line">[1]: #uOps</span><br><span class="line">[2]: Latency</span><br><span class="line">[3]: RThroughput</span><br><span class="line">[4]: MayLoad</span><br><span class="line">[5]: MayStore</span><br><span class="line">[6]: HasSideEffects (U)</span><br><span class="line"></span><br><span class="line">[1]    [2]    [3]    [4]    [5]    [6]    Instructions:</span><br><span class="line"> 1      2     1.00                        vmulps      %xmm0, %xmm1, %xmm2</span><br><span class="line"> 1      3     1.00                        vhaddps     %xmm2, %xmm2, %xmm3</span><br><span class="line"> 1      3     1.00                        vhaddps     %xmm3, %xmm3, %xmm4</span><br></pre></td></tr></table></figure>

<p>显示了指令里队列每条指令的<strong>延迟</strong>和<strong>吞吐量的倒数</strong>。</p>
<p>RThroughput是指令吞吐量的倒数。在不考虑循环依赖的情况下，吞吐量是<strong>单周期能执行的同类型指令的最大数量</strong>。</p>
<h3 id="Resource-pressure-view"><a href="#Resource-pressure-view" class="headerlink" title="Resource pressure view"></a>Resource pressure view</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Resources:</span><br><span class="line">[0]   - JALU0</span><br><span class="line">[1]   - JALU1</span><br><span class="line">[2]   - JDiv</span><br><span class="line">[3]   - JFPA</span><br><span class="line">[4]   - JFPM</span><br><span class="line">[5]   - JFPU0</span><br><span class="line">[6]   - JFPU1</span><br><span class="line">[7]   - JLAGU</span><br><span class="line">[8]   - JMul</span><br><span class="line">[9]   - JSAGU</span><br><span class="line">[10]  - JSTC</span><br><span class="line">[11]  - JVALU0</span><br><span class="line">[12]  - JVALU1</span><br><span class="line">[13]  - JVIMUL</span><br><span class="line"></span><br><span class="line">Resource pressure per iteration:</span><br><span class="line">[0]    [1]    [2]    [3]    [4]    [5]    [6]    [7]    [8]    [9]    [10]   [11]   [12]   [13]</span><br><span class="line"> -      -      -     2.00   1.00   2.00   1.00    -      -      -      -      -      -      -</span><br><span class="line"></span><br><span class="line">Resource pressure by instruction:</span><br><span class="line">[0]    [1]    [2]    [3]    [4]    [5]    [6]    [7]    [8]    [9]    [10]   [11]   [12]   [13]   Instructions:</span><br><span class="line"> -      -      -      -     1.00    -     1.00    -      -      -      -      -      -      -     vmulps      %xmm0, %xmm1, %xmm2</span><br><span class="line"> -      -      -     1.00    -     1.00    -      -      -      -      -      -      -      -     vhaddps     %xmm2, %xmm2, %xmm3</span><br><span class="line"> -      -      -     1.00    -     1.00    -      -      -      -      -      -      -      -     vhaddps     %xmm3, %xmm3, %xmm4</span><br></pre></td></tr></table></figure>

<p>每次循环或者每条指令执行，消耗的资源周期数。从而找到高资源占用的部分。</p>
<h3 id="Timeline-View"><a href="#Timeline-View" class="headerlink" title="Timeline View"></a>Timeline View</h3><p>可打印流水线情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Timeline view:</span><br><span class="line">                    012345</span><br><span class="line">Index     0123456789</span><br><span class="line"></span><br><span class="line">[0,0]     DeeER.    .    .   vmulps   %xmm0, %xmm1, %xmm2</span><br><span class="line">[0,1]     D==eeeER  .    .   vhaddps  %xmm2, %xmm2, %xmm3</span><br><span class="line">[0,2]     .D====eeeER    .   vhaddps  %xmm3, %xmm3, %xmm4</span><br><span class="line">[1,0]     .DeeE-----R    .   vmulps   %xmm0, %xmm1, %xmm2</span><br><span class="line">[1,1]     . D=eeeE---R   .   vhaddps  %xmm2, %xmm2, %xmm3</span><br><span class="line">[1,2]     . D====eeeER   .   vhaddps  %xmm3, %xmm3, %xmm4</span><br><span class="line">[2,0]     .  DeeE-----R  .   vmulps   %xmm0, %xmm1, %xmm2</span><br><span class="line">[2,1]     .  D====eeeER  .   vhaddps  %xmm2, %xmm2, %xmm3</span><br><span class="line">[2,2]     .   D======eeeER   vhaddps  %xmm3, %xmm3, %xmm4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Average Wait times (based on the timeline view):</span><br><span class="line">[0]: Executions</span><br><span class="line">[1]: Average time spent waiting in a scheduler&#x27;s queue</span><br><span class="line">[2]: Average time spent waiting in a scheduler&#x27;s queue while ready</span><br><span class="line">[3]: Average time elapsed from WB until retire stage</span><br><span class="line"></span><br><span class="line">      [0]    [1]    [2]    [3]</span><br><span class="line">0.     3     1.0    1.0    3.3       vmulps   %xmm0, %xmm1, %xmm2</span><br><span class="line">1.     3     3.3    0.7    1.0       vhaddps  %xmm2, %xmm2, %xmm3</span><br><span class="line">2.     3     5.7    0.0    0.0       vhaddps  %xmm3, %xmm3, %xmm4</span><br><span class="line">       3     3.3    0.5    1.4       &lt;total&gt;</span><br></pre></td></tr></table></figure>

<p>影响因素包括：</p>
<ol>
<li>数据冲突&#x2F;依赖：读后写，写后读依赖 。无法指令级并行，也可以通过寄存器重命名解决</li>
<li>结构冲突：占用发射位 或者 同一硬件</li>
<li>控制冲突：分支？</li>
<li>instructions must retire in program order, so [1,0] has to wait for [0,2] to be retired first</li>
</ol>
<h3 id="Bottleneck-Analysis"><a href="#Bottleneck-Analysis" class="headerlink" title="Bottleneck Analysis"></a>Bottleneck Analysis</h3><ul>
<li>可以分析出数据冲突&#x2F;依赖和结构冲突的影响大小</li>
<li>准确性取决于模拟和是否有对应CPU模型。</li>
<li>暂时不支持有序后端。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cycles with backend pressure increase [ 91.52% ]</span><br><span class="line">Throughput Bottlenecks:</span><br><span class="line">  Resource Pressure       [ 0.01% ]</span><br><span class="line">  - SBPort0  [ 0.01% ]</span><br><span class="line">  - SBPort1  [ 0.01% ]</span><br><span class="line">  - SBPort5  [ 0.01% ]</span><br><span class="line">  Data Dependencies:      [ 91.51% ]</span><br><span class="line">  - Register Dependencies [ 91.51% ]</span><br><span class="line">  - Memory Dependencies   [ 10.76% ]</span><br></pre></td></tr></table></figure>

<ul>
<li>端口信息来自TableGen <code>llvm/lib/Target/X86/X86SchedSandyBridge.td</code></li>
<li>鲲鹏920的来自 <code>llvm/lib/Target/AArch64/AArch64SchedTSV110.td</code></li>
</ul>
<h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><ol>
<li>Dynamic Dispatch Stall Cycles</li>
<li>Dispatch Logic<ol>
<li>可以看出流水线发射满带宽或几条指令的时间占比</li>
</ol>
</li>
<li>Schedulers<ol>
<li>每个周期微指令发射数占比</li>
</ol>
</li>
<li>Scheduler’s queue usage<ol>
<li><p>执行时使用的平均或最大buffer entries (i.e., scheduler queue entries)</p>
</li>
<li><p>AMD Jaguar</p>
</li>
<li><pre><code>  JALU01 - A scheduler for ALU instructions.
  JFPU01 - A scheduler floating point operations.
  JLSAGU - A scheduler for address generation.
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. Retire Control Unit</span><br><span class="line">   1. 在一个周期里有多少指令retired的占比(好吧，感觉有语病)</span><br><span class="line">6. A re-order buffer (ROB) 的使用情况</span><br><span class="line">7. Register File statistics</span><br><span class="line">   1. physical register file (PRF)</span><br><span class="line">   2. floating-point registers (JFpuPRF)</span><br><span class="line">   3. integer registers (JIntegerPRF)</span><br><span class="line"></span><br><span class="line">## Instruction Flow</span><br><span class="line"></span><br><span class="line">llvm-mca 假设指令在模拟开始之前已经全部解码并放入队列中。因此，指令提取和解码阶段没有被计算。未考虑前端的性能瓶颈。此外，llvm-mca 不模拟分支预测。</span><br><span class="line"></span><br><span class="line">### Instruction Dispatch</span><br><span class="line"></span><br><span class="line">处理器的默认 dispatch width值等于LLVM’s scheduling model里的IssueWidth值。</span><br><span class="line"></span><br><span class="line">An instruction can be dispatched if:</span><br><span class="line"></span><br><span class="line">* The size of the **dispatch group** is smaller than processor’s dispatch width.</span><br><span class="line">* There are enough entries in the **reorder buffer**.</span><br><span class="line">* There are enough **physical registers** to do register renaming.</span><br><span class="line">* The schedulers are **not full**.</span><br><span class="line"></span><br><span class="line">reorder buffer负责跟踪命令，使之按照程序顺序retired结束。其默认值为 MicroOpBufferSize 。</span><br><span class="line"></span><br><span class="line">各种Buffered resources 被视作scheduler resources.</span><br><span class="line"></span><br><span class="line">### Instruction Issue</span><br><span class="line"></span><br><span class="line">每个处理器调度器实现一个指令缓冲区。指令必须在调度程序的缓冲区中等待，直到输入寄存器操作数可用。只有在那个时候，指令才符合执行的条件，并且可能会被发出（可能是乱序的）以供执行。 llvm-mca 在调度模型的帮助下计算指令延迟。</span><br><span class="line"></span><br><span class="line">llvm-mca 的调度器旨在模拟多处理器调度器。调度器负责跟踪数据依赖关系，并动态选择指令消耗哪些处理器资源。它将处理器资源单元和资源组的管理委托给资源管​​理器。资源管理器负责选择指令消耗的资源单元。例如，如果一条指令消耗了一个资源组的1cy，则资源管理器从该组中选择一个可用单元；默认情况下，资源管理器使用循环选择器来保证资源使用在组的所有单元之间均匀分配。</span><br><span class="line"></span><br><span class="line">llvm-mca’s scheduler internally groups instructions into three sets:</span><br><span class="line"></span><br><span class="line">* WaitSet: a set of instructions whose operands are not ready.</span><br><span class="line">* ReadySet: a set of instructions ready to execute.</span><br><span class="line">* IssuedSet: a set of instructions executing.</span><br><span class="line"></span><br><span class="line">### Write-Back and Retire Stage</span><br><span class="line"></span><br><span class="line"> retire control unit</span><br><span class="line"></span><br><span class="line">1. When instructions are executed,the flags the instruction as “ready to retire.”</span><br><span class="line">2. Instructions are retired in program order</span><br><span class="line">3. free the physical registers</span><br><span class="line"></span><br><span class="line">### Load/Store Unit and Memory Consistency Model</span><br><span class="line"></span><br><span class="line">load/store unit (LSUnit)用来模拟乱序memory操作</span><br><span class="line"></span><br><span class="line">The rules are:</span><br><span class="line"></span><br><span class="line">1. A younger load is allowed to pass an older load only if there are no intervening stores or barriers between the two loads.</span><br><span class="line">2. A younger load is allowed to pass an older store provided that the load does not alias with the store.</span><br><span class="line">3. A younger store is not allowed to pass an older store.不能交换顺序的意思</span><br><span class="line">4. A younger store is not allowed to pass an older load.</span><br><span class="line"></span><br><span class="line">假设 loads do not alias (-noalias=true) store operations.Under this assumption, younger loads are always allowed to pass older stores. ???</span><br><span class="line"></span><br><span class="line">LSUnit不打算跑alias analysis来预测何时load与store不相互alias???</span><br><span class="line"></span><br><span class="line">in the case of write-combining memory, rule 3 could be relaxed to allow reordering of non-aliasing store operations.???</span><br><span class="line"></span><br><span class="line">LSUnit不管的其余三点：</span><br><span class="line"></span><br><span class="line">1. The LSUnit does not know when store-to-load forwarding may occur.</span><br><span class="line">2. The LSUnit does not know anything about cache hierarchy and memory types.</span><br><span class="line">3. The LSUnit does not know how to identify serializing operations and memory fences.</span><br><span class="line">4. The LSUnit does not attempt to predict if a load or store hits or misses the L1 cache(不考虑cache命中，默认是命中L1,产生the load-to-use latency的最乐观开销)</span><br><span class="line"></span><br><span class="line">llvm-mca 不知道序列化操作或内存屏障之类的指令。 LSUnit 保守地假设同时具有“MayLoad”和未建模副作用的指令的行为类似于“软”load-barrier。这意味着，它在不强制刷新load队列的情况下序列化加载。类似地，“MayStore”和具有未建模副作用的指令被视为store障碍。完整的memory-barrier是具有未建模副作用的“MayLoad”和“MayStore”指令。LLVM的实现是不准确的，但这是我们目前使用 LLVM 中可用的当前信息所能做的最好的事情。</span><br><span class="line"></span><br><span class="line">load/store barrier会占用在load/store 队列里占用一项。</span><br><span class="line">当load/store barrier是其队列里oldest项时，其会被执行</span><br><span class="line"></span><br><span class="line">![](https://pic.shaojiemike.top/img/440472FD7AB14BC3C1F29BD2D565ACDF.png)</span><br><span class="line"></span><br><span class="line">### In-order Issue and Execute</span><br><span class="line"></span><br><span class="line">有序处理器被建模为单个 InOrderIssueStage 阶段。它绕过 Dispatch、Scheduler 和 Load/Store 单元。一旦它们的操作数寄存器可用并且满足资源要求，就会发出指令。根据LLVM的调度模型中IssueWidth参数的值，可以在一个周期内发出多条指令。一旦发出，指令就会被移到 IssuedInst 集，直到它准备好retire。 llvm-mca 确保按顺序提交写入。但是，如果 RetireOOO 属性for at least one of its writes为真，则允许指令提交写入并无序retire???</span><br><span class="line"></span><br><span class="line">## Custom Behaviour 自定义行为</span><br><span class="line"></span><br><span class="line">某些指令在该模型中并不能被准确的模拟。为了几条指令而修改模型不是个好的选择，一般通过**CustomBehaviour**类对某些指令进行特殊建模：自定义数据依赖，以及规避、单独处理特殊情况。</span><br><span class="line"></span><br><span class="line">为此，llvm-mca设置了一个通用的以及多个特殊的**CustomBehaviour**类。下面两种情况下会使用通用类：</span><br><span class="line"></span><br><span class="line">1. 开启了`-disable-cb`选项</span><br><span class="line">2. 不存在针对某目标的特殊类(通用类也做不了什么，我什么也做不到😥)</span><br><span class="line"></span><br><span class="line">但是注意目前只有in-order流水线实现了**CustomBehaviour**类，out-order流水线将来也会支持。</span><br><span class="line"></span><br><span class="line">该类主要通过`checkCustomHazard()`函数来实现，通过当前指令和真正流水线中执行的指令，来判断当前指令需要等待几个周期才能发射。</span><br><span class="line"></span><br><span class="line">如果想对没有实现的目标添加**CustomBehaviour**类，可以参考已有的实现，比如在`/llvm/lib/Target/AMDGPU/MCA/`目录下。</span><br><span class="line"></span><br><span class="line">## Custom Views 自定义视图</span><br><span class="line"></span><br><span class="line">关于自定义的视图的添加路径，如果**没有输出**从未在MC layer classes (MCSubtargetInfo, MCInstrInfo, etc.)里出现过的**新后端值**，请把实现加入`/tools/llvm-mca/View/`。相反，请加入`/lib/Target/&lt;TargetName&gt;/MCA/`目录。</span><br><span class="line"></span><br><span class="line">关于Custom Views所需内容，需要写特殊的**CustomBehaviour**类来覆写`CustomBehaviour::getViews()`函数，根据位置的不同还有三种实现`getStartViews(), getPostInstrInfoViews(),getEndViews()`。</span><br><span class="line"></span><br><span class="line">## 影响准确性的因素</span><br><span class="line"></span><br><span class="line">调度模型不仅用于计算指令延迟和吞吐量，还用于了解可用的处理器资源以及如何模拟它们。</span><br><span class="line"></span><br><span class="line">llvm mca进行分析的质量不可避免地受到**llvm中调度模型质量**的影响。</span><br><span class="line"></span><br><span class="line">## 功能（能估计的值</span><br><span class="line"></span><br><span class="line">1. IPC</span><br><span class="line">2. 硬件资源压力resource-pressure</span><br><span class="line">3. 一些额外Info？</span><br><span class="line">   1.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 register-file-stats
 -dispatch-stats
 -scheduler-stats
 -retire-stats
 -instruction-info
 instruction-tables
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 吞吐量瓶颈？</span><br><span class="line"></span><br><span class="line">### 支持对特定代码块的分析</span><br><span class="line"></span><br><span class="line">1. 汇编代码，支持命名和嵌套</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h1 id="LLVM-MCA-BEGIN-block-name"><a href="#LLVM-MCA-BEGIN-block-name" class="headerlink" title="LLVM-MCA-BEGIN block-name"></a>LLVM-MCA-BEGIN block-name</h1><p> add %eax, %eax</p>
<h1 id="LLVM-MCA-END"><a href="#LLVM-MCA-END" class="headerlink" title="LLVM-MCA-END"></a>LLVM-MCA-END</h1> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 高级语言，通过内联汇编实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> int foo(int a, int b) {<br>     __asm volatile(“# LLVM-MCA-BEGIN foo”);<br>     a +&#x3D; 42;<br>     __asm volatile(“# LLVM-MCA-END”);<br>     a *&#x3D; b;<br>     return a;<br> }</p>
<pre><code>
但是，这会干扰循环矢量化等优化，并可能对生成的代码产生影响。具体影响请对比汇编代码。
</code></pre>
</li>
</ol>
<h2 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h2><p>Google学术搜llvm-mca，一堆论文。但是不急着看，因为没有预备知识，没有问题的去看论文。效率和收获很低的，而且会看不懂。</p>
<h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><h3 id="mc-ruler"><a href="#mc-ruler" class="headerlink" title="mc-ruler"></a>mc-ruler</h3><p><a target="_blank" rel="noopener" href="https://github.com/jeremyong/mc_ruler#">mc-ruler</a>是整合了llvm-mca的cmake,可以打印指定部分的代码分析信息。如果之后要测试可能用得上。</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><ol>
<li>具体功能</li>
<li>llvm如何实现的，要看代码。</li>
</ol>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li>(llvm-mca detects Intel syntax by the presence of an <strong>.intel_syntax</strong> directive at the beginning of the input. By default its output syntax matches that of its input.)</li>
<li>？？？的地方</li>
<li>大概看了一下功能，但是性能怎么对比呢。准确值是多少呢？<ol>
<li>arm kunpeng pmu-tools 实现</li>
</ol>
</li>
<li>每次的估计值会波动吗？</li>
</ol>
<p>如何和大神交流呢+提问的艺术</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-30T16:00:00.000Z" title="5/30/2023, 4:00:00 PM">2023-05-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.190Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Architecture/">Architecture</a></span><span class="level-item">11 minutes read (About 1699 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/30/Work/Programming/4-compile/llvmBackend/">llvm Backend</a></p><div class="content"><h2 id="llvm-后端-概述"><a href="#llvm-后端-概述" class="headerlink" title="llvm 后端 概述"></a>llvm 后端 概述</h2><ul>
<li>后端（backend）由一套<strong>分析</strong>和<strong>转换</strong>Pass组成，它们的任务是代码生成，即将LLVM中间表示（IR）变换为目标代码（或者汇编）。</li>
<li>LLVM支持广泛的目标：ARM，AArch64，Hexagon，MSP430，MIPS，Nvidia PTX，PowerPC，R600，SPARC，SystemZ，X86，和XCore。</li>
<li>所有这些后端共享一套共用的接口，它是目标无关代码生成器的一部分，以通用API的方法抽象化后端任务。每个目标必须特殊化代码生成通用类，以实现目标特定的行为。</li>
</ul>
<h3 id="后端的基本流程"><a href="#后端的基本流程" class="headerlink" title="后端的基本流程"></a>后端的基本流程</h3><ul>
<li>下图给出了将LLVM IR转换为目标汇编代码必需的步骤</li>
</ul>
<p><img src="https://pic.shaojiemike.top/img/20230523160158.png" alt="Backend"></p>
<ul>
<li>浅灰色的中间框，也叫super pass，是必需的，它们是后端的核心部分。</li>
<li>白色框所指示的，可以执行非必需的优化Pass以进一步改进翻译的质量。对于提高所生成的代码的效率更重要。<ul>
<li>比如<code>-O3</code>的优化，而且其顺序对结果也有影响。</li>
</ul>
</li>
</ul>
<p>详细解释各阶段：</p>
<ol>
<li>指令选择（Instruction Selection）：将三地址结构的LLVM IR变换为DAG（Directed Acyclic Graph）<ul>
<li>每个DAG能够表示单一基本块的计算。DAG内节点表示机器指令，边表示数据依赖关系。</li>
</ul>
</li>
<li>第1次指令调度（Instruction Scheduling），也称为前寄存器分配（RA）调度，对指令排序，同时尝试发现尽可能多的指令层次的并行。然后这些指令被变换为MachineInstr三地址表示。</li>
<li>寄存器分配（Register Allocation），它将无限的虚拟寄存器的引用转换为有限的目标特定的寄存器集，寄存器不够时挤出（spill）到内存。</li>
<li>第2次指令调度，也称为后寄存器分配（RA）调度。因为此时在这个点可获得真实的寄存器信息，某些类型寄存器存在额外的风险和延迟，它们可被用以改进指令顺序。</li>
<li>代码输出（Code Emission）阶段将指令从MachineInstr表示变换为MCInst实例。这种新的表示更适合汇编器和链接器，它有两种选择：输出汇编代码或者输出二进制块（blob）到一种特定的目标代码格式。</li>
</ol>
<h3 id="后端代码结构"><a href="#后端代码结构" class="headerlink" title="后端代码结构"></a>后端代码结构</h3><p>后端的实现分散在LLVM源代码树的不同目录中。代码生成背后的主要程序库位于lib目录和它的子文件夹CodeGen、MC、TableGen、和Target中， 具体参考<a target="_blank" rel="noopener" href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch06.html#id4">文档</a></p>
<p>Tablegen位置在类似 <code>llvm/lib/Target/X86/X86.td</code>的地方</p>
<h2 id="llvm-编译优化"><a href="#llvm-编译优化" class="headerlink" title="llvm 编译优化"></a>llvm 编译优化</h2><ul>
<li>通过llvm的分析和转换Pass相结合实现的。</li>
<li>首先，通过分析Pass获取程序的一些特性和数据流等信息，例如控制流分析、数据流分析、依赖分析等。</li>
<li>然后，根据所得到的分析信息，llvm会执行转换Pass，对程序进行一系列的重构、优化和变换，例如常量传播、死代码消除、内联函数、循环展开等。</li>
</ul>
<h3 id="举例：O3优化实现"><a href="#举例：O3优化实现" class="headerlink" title="举例：O3优化实现"></a>举例：O3优化实现</h3><p>程序优化选项 -O3 是通过启用 LLVM Pass Manager 并按照顺序执行包含多个具体优化 Pass 的过程实现的。包括：</p>
<ol>
<li>函数内部优化 Pass，如内联、函数内联、无用函数清理、控制流扁平化；</li>
<li>函数间优化 Pass，如基于静态单走边分析的间接调用目标推导、函数每次调用的参数的重复计算消除、通过符号解析执行的函数简介化等。</li>
<li>模块优化 Pass，如死代码消除、全局优化、常量传播、数值宽化和窄化、整除优化等；</li>
<li>特定于架构的优化 Pass，包括指令调度和寄存器分配等。</li>
</ol>
<p>这些 Pass 的执行范围涵盖 LLVM IR 与 LLVM 后端。</p>
<h2 id="TableGen"><a href="#TableGen" class="headerlink" title="TableGen"></a>TableGen</h2><ul>
<li>LLVM的TableGen是一种表格驱动代码生成工具，主要用于生成汇编器、反汇编器、指令选择器、调度器等代码。</li>
<li>它使用基于LLVM IR的DSL(Domain-Specific Language)来描述目标指令集的特性和规则，然后将这些信息转换为C++代码。</li>
<li>使用TableGen可以将目标指令集的实现与源代码分离，从而提高代码的可读性和可维护性。</li>
</ul>
<p>TableGen的输入文件使用扩展名“<code>.td</code>”（TableGen的缩写），它们可以描述如下内容：</p>
<ol>
<li>Instruction Set Architecture (ISA) - 描述目标机的指令集特性，例如指令集架构、寄存器、寄存器类、操作数类型、地址模型、端对齐性等。</li>
<li>Selection DAG - 描述了如何将LLVM IR节点映射到目标机指令集的指令，例如指令的操作码、操作数、调用约定、指令延迟等。</li>
<li>Pattern Matching - 对匹配到的指令模板做出生成想要的IR节点的选择。</li>
<li>Instruction Scheduling - 描述调度器行为、指令之间的时间关系，以及如何将指令插入到调度图中的规则等。</li>
</ol>
<ul>
<li>TableGen自动化了目标机指令集的大部分工作，同时也使得自定义目标机变得相对容易。</li>
<li>该工具支持针对多种平台和编译器的后端代码生成。</li>
<li>对于嵌入式系统和非标准指令集架构等领域，TableGen有着广泛的应用。</li>
</ul>
<h3 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h3><ul>
<li>目标描述语言（Target Description Language，TDL）来定义目标架构特定的指令和寄存器。其中，TDL可用于目标架构中指令定义和寄存器定义的映射关系和动态生成机器指令的规则。</li>
</ul>
<h2 id="实践：llvm-IR-后端"><a href="#实践：llvm-IR-后端" class="headerlink" title="实践：llvm IR 后端"></a>实践：llvm IR 后端</h2><p>实现一个简单的LLVM IR后端，将LLVM IR转换为x86汇编代码，能line by line的输出。</p>
<p>参考LLVM官方文档中的“Writing an LLVM Backend”以及“TableGen Backends”</p>
<!-- 下面回答部分**来自ChatGPT-3.5**，暂时没有校验其可靠性(看上去貌似说得通)。 -->

<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch06.html#id2">https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch06.html#id2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-25T09:42:44.000Z" title="5/25/2023, 9:42:44 AM">2023-05-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-12T03:54:05.106Z" title="10/12/2024, 3:54:05 AM">2024-10-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Thinking/">Thinking</a></span><span class="level-item">8 minutes read (About 1173 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/25/Thinking/2-courage2move/PIM/OOTD/">OOTD: outfit of the day</a></p><div class="content"><article class="message is-info">
        <div class="message-header"><p><i class="fa-solid fa-clipboard mr-2"></i>导言</p>
</div>
        <div class="message-body">
            <p>个人形象管理的第一部分，也是最简单的部分，外貌部分的穿搭。</p>

        </div>
    </article></div><a class="article-more button is-small is-size-7" href="/2023/05/25/Thinking/2-courage2move/PIM/OOTD/#more">Read more</a></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/24/">Previous</a></div><div class="pagination-next"><a href="/page/26/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/24/">24</a></li><li><a class="pagination-link is-current" href="/page/25/">25</a></li><li><a class="pagination-link" href="/page/26/">26</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/43/">43</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="Shaojie Tan"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shaojie Tan</p><p class="is-size-6 is-block">𝘊𝘰𝘮𝘱𝘶𝘵𝘦𝘳 𝘈𝘳𝘤𝘩𝘪𝘵𝘦𝘤𝘵𝘶𝘳𝘦 &amp; 𝘏𝘗𝘊</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Anhui, Hefei, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">425</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">515</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Kirrito-k423" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Kirrito-k423"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithms/"><span class="level-start"><span class="level-item">Algorithms</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/Architecture/"><span class="level-start"><span class="level-item">Architecture</span></span><span class="level-end"><span class="level-item tag">41</span></span></a></li><li><a class="level is-mobile" href="/categories/Artificial-Intelligence/"><span class="level-start"><span class="level-item">Artificial Intelligence</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Camp/"><span class="level-start"><span class="level-item">Camp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Databases/"><span class="level-start"><span class="level-item">Databases</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/HPC/"><span class="level-start"><span class="level-item">HPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/OOW/"><span class="level-start"><span class="level-item">OOW</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/Operating-system/"><span class="level-start"><span class="level-item">Operating system</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Overview/"><span class="level-start"><span class="level-item">Overview</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/ProjectRecord/"><span class="level-start"><span class="level-item">ProjectRecord</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Software/"><span class="level-start"><span class="level-item">Software</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Thinking/"><span class="level-start"><span class="level-item">Thinking</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Tips/"><span class="level-start"><span class="level-item">Tips</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Treasure/"><span class="level-start"><span class="level-item">Treasure</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tutorials/"><span class="level-start"><span class="level-item">Tutorials</span></span><span class="level-end"><span class="level-item tag">116</span></span></a></li><li><a class="level is-mobile" href="/categories/Values/"><span class="level-start"><span class="level-item">Values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/architecture/"><span class="level-start"><span class="level-item">architecture</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/diary/"><span class="level-start"><span class="level-item">diary</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/english/"><span class="level-start"><span class="level-item">english</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/hardware/"><span class="level-start"><span class="level-item">hardware</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/love/"><span class="level-start"><span class="level-item">love</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/math/"><span class="level-start"><span class="level-item">math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/operating-system/"><span class="level-start"><span class="level-item">operating system</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/programming/"><span class="level-start"><span class="level-item">programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/security/"><span class="level-start"><span class="level-item">security</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/software/"><span class="level-start"><span class="level-item">software</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/thinking/"><span class="level-start"><span class="level-item">thinking</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/thinking/OOW/"><span class="level-start"><span class="level-item">OOW</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/toLearn/"><span class="level-start"><span class="level-item">toLearn</span></span><span class="level-end"><span class="level-item tag">55</span></span></a></li><li><a class="level is-mobile" href="/categories/values/"><span class="level-start"><span class="level-item">values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://ibug.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ibugs</span></span><span class="level-right"><span class="level-item tag">ibug.io</span></span></a></li><li><a class="level is-mobile" href="https://jia.je/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">jiegec</span></span><span class="level-right"><span class="level-item tag">jia.je</span></span></a></li><li><a class="level is-mobile" href="https://leimao.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">leimao</span></span><span class="level-right"><span class="level-item tag">leimao.github.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-11T03:04:55.000Z">2024-10-11</time></p><p class="title"><a href="/2024/10/11/Work/Programming/DebugProfile/DebugProfilePTA/">Debug/Profile Tools of PTA</a></p><p class="categories"><a href="/categories/toLearn/">toLearn</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-22T09:19:48.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/Work/software/simulator/PC/VirtualBox/">VirtualBox</a></p><p class="categories"><a href="/categories/software/">software</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-13T07:08:55.000Z">2024-09-13</time></p><p class="title"><a href="/2024/09/13/Work/software/PC/macbook/">Macbook Config</a></p><p class="categories"><a href="/categories/software/">software</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-13T00:47:35.000Z">2024-09-13</time></p><p class="title"><a href="/2024/09/13/Work/Programming/2-languageGrammar/c/Types/">[C++ Basic] Types</a></p><p class="categories"><a href="/categories/toLearn/">toLearn</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-12T14:41:50.000Z">2024-09-12</time></p><p class="title"><a href="/2024/09/12/Work/Programming/2-languageGrammar/c/Class/">[C++ Basic] User-Defined Types: Class</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">August 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">July 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">November 2023</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">October 2023</span></span><span class="level-end"><span class="level-item tag">57</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">September 2023</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">April 2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">March 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">September 2021</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/5G/"><span class="tag">5G</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/64bits-vs-32bits/"><span class="tag">64bits vs 32bits</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMAT/"><span class="tag">AMAT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMD/"><span class="tag">AMD</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ASPLOS/"><span class="tag">ASPLOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ATI/"><span class="tag">ATI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AVX/"><span class="tag">AVX</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Alpha/"><span class="tag">Alpha</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Analysis/"><span class="tag">Analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Apt/"><span class="tag">Apt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BFS/"><span class="tag">BFS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BHive/"><span class="tag">BHive</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BT/"><span class="tag">BT</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BTL/"><span class="tag">BTL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Baka-Mitai/"><span class="tag">Baka Mitai</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Big-Endian/"><span class="tag">Big-Endian</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a><p class="is-size-7"><span>&copy; 2024 Shaojie Tan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>