<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SHAOJIE&#039;S BOOK</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SHAOJIE&#039;S BOOK"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SHAOJIE&#039;S BOOK"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="SHAOJIE&#039;S BOOK"><meta property="og:url" content="http://icarus.shaojiemike.top/"><meta property="og:site_name" content="SHAOJIE&#039;S BOOK"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://icarus.shaojiemike.top/img/og_image.png"><meta property="article:author" content="Shaojie Tan"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://icarus.shaojiemike.top/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://icarus.shaojiemike.top"},"headline":"SHAOJIE'S BOOK","image":["http://icarus.shaojiemike.top/img/og_image.png"],"author":{"@type":"Person","name":"Shaojie Tan"},"publisher":{"@type":"Organization","name":"SHAOJIE'S BOOK","logo":{"@type":"ImageObject","url":"http://icarus.shaojiemike.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-24T16:00:00.000Z" title="9/24/2023, 4:00:00 PM">2023-09-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.043Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">an hour read (About 13078 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/24/Work/Programming/2-languageGrammar/c/CplusDataStructure/">C++ : stdlib DataStructure</a></p><div class="content"><h2 id="基础杂项"><a href="#基础杂项" class="headerlink" title="基础杂项"></a>基础杂项</h2><h3 id="auto的使用"><a href="#auto的使用" class="headerlink" title="auto的使用"></a>auto的使用</h3><ul>
<li>当你想要拷贝range的元素时，使用 <code>for(auto x : range).</code></li>
<li>当你想要修改range的元素时，使用 <code>for(auto &amp;&amp; x : range)</code></li>
<li>当你想要只读range的元素时，使用 <code>for(const auto &amp; x : range)</code>.</li>
</ul>
<h3 id="容器间的转换-begin-end"><a href="#容器间的转换-begin-end" class="headerlink" title="容器间的转换 begin end"></a>容器间的转换 begin end</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; nums1</span></span><br><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h3 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h3><ul>
<li>建议使用<code>rbegin</code> <code>rend</code>。注意<code>++it</code>而不是<code>--it</code>。<ul>
<li><code>rbegin</code>指向最后一个元素</li>
<li><code>rend</code> 指向reverse遍历的后一个元素。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = collection.<span class="built_in">rbegin</span>(); it != collection.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;, &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>错误的原始写法, 错误原因<code>showedPositive.begin()==(--showedPositive.begin()</code>。<ul>
<li>std设计了一个循环。</li>
<li>同样的设计在<code>showedPositive.rend()==(++showedPositive.rend())</code></li>
<li>但是<code>showedPositive.rbegin() != (--showedPositive.rbegin())</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=--showedPositive.<span class="built_in">end</span>(); it!=--showedPositive.<span class="built_in">begin</span>(); it--)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>bitset类型存储二进制数位。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;16&gt; foo;</span><br><span class="line"><span class="function">std::bitset&lt;16&gt; <span class="title">bar</span> <span class="params">(<span class="number">0xfa2</span>)</span></span>;</span><br><span class="line"><span class="function">std::bitset&lt;16&gt; <span class="title">baz</span> <span class="params">(std::string(<span class="string">&quot;0101111001&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foo: 0000000000000000</span></span><br><span class="line"><span class="comment">//bar: 0000111110100010</span></span><br><span class="line"><span class="comment">//baz: 0000000101111001</span></span><br></pre></td></tr></table></figure>

<h3 id="将数转化为其二进制的字符串表示"><a href="#将数转化为其二进制的字符串表示" class="headerlink" title="将数转化为其二进制的字符串表示"></a>将数转化为其二进制的字符串表示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">string bin = <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(i).<span class="built_in">to_string</span>(); <span class="comment">//bin = &quot;0000000000000011&quot;</span></span><br><span class="line">bin = bin.<span class="built_in">substr</span>(bin.<span class="built_in">find</span>(<span class="string">&#x27;1&#x27;</span>));        <span class="comment">//bin = &quot;11&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="char-与-字符串"><a href="#char-与-字符串" class="headerlink" title="char 与 字符串"></a>char 与 字符串</h2><h3 id="元音与index的相互映射"><a href="#元音与index的相互映射" class="headerlink" title="元音与index的相互映射"></a>元音与index的相互映射</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string vowel = <span class="string">&quot;AEIOUaeiou&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> vowel.<span class="built_in">find</span>(c) != std::string::npos;</span><br><span class="line"></span><br><span class="line">voewl[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="读取空格分割的"><a href="#读取空格分割的" class="headerlink" title="读取空格分割的"></a>读取空格分割的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stringstream <span class="title">txt</span><span class="params">(s)</span></span>;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(txt&gt;&gt;word)&#123;</span><br><span class="line">    <span class="comment">// to do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp; x : s)</span><br></pre></td></tr></table></figure>

<h3 id="打印string"><a href="#打印string" class="headerlink" title="打印string"></a>打印string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, your_string.<span class="built_in">c_str</span>()); <span class="comment">//不推荐</span></span><br><span class="line">cout &lt;&lt; your_string;</span><br></pre></td></tr></table></figure>

<p>string不同于C语言的char来存储字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制</span></span><br><span class="line">str3 = str1;    len = str3.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//连接</span></span><br><span class="line">str1 = str1 + str2;  <span class="built_in">strcat</span>( str1, str2);</span><br><span class="line"><span class="comment">//总长度</span></span><br><span class="line">len = str3.<span class="built_in">size</span>();  <span class="built_in">strlen</span>(s1);</span><br></pre></td></tr></table></figure>

<p>C++ string 成员函数 length() 等同于 size()，但是和 C 库函数 strlen() 有着本质区别</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/K346K346/article/details/79546919">https://blog.csdn.net/K346K346/article/details/79546919</a></p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">s0</span> <span class="params">(<span class="string">&quot;Initial string&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">std::string s1;</span><br><span class="line"><span class="function">std::string <span class="title">s2</span> <span class="params">(s0)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s3</span> <span class="params">(s0, <span class="number">8</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s4</span> <span class="params">(<span class="string">&quot;A character sequence&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s5</span> <span class="params">(<span class="string">&quot;Another character sequence&quot;</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s6a</span> <span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">s6b</span> <span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;      <span class="comment">// 42 is the ASCII code for &#x27;*&#x27;</span></span><br><span class="line"><span class="function">std::string <span class="title">s7</span> <span class="params">(s0.begin(), s0.begin()+<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\ns2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\ns3: &quot;</span> &lt;&lt; s3;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\ns4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="string">&quot;\ns5: &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="string">&quot;\ns6a: &quot;</span> &lt;&lt; s6a;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\ns6b: &quot;</span> &lt;&lt; s6b &lt;&lt; <span class="string">&quot;\ns7: &quot;</span> &lt;&lt; s7 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">s1: </span><br><span class="line">s2: Initial string</span><br><span class="line">s3: str</span><br><span class="line">s4: A character sequence</span><br><span class="line">s5: Another <span class="type">char</span></span><br><span class="line">s6a: xxxxxxxxxx</span><br><span class="line">s6b: **********</span><br><span class="line">s7: Initial</span><br></pre></td></tr></table></figure>

<h3 id="插入insert"><a href="#插入insert" class="headerlink" title="插入insert"></a>插入insert</h3><p>在指向位置的<strong>右边</strong>插入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inserting into a string</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string str=<span class="string">&quot;to be question&quot;</span>;</span><br><span class="line">  std::string str2=<span class="string">&quot;the &quot;</span>;</span><br><span class="line">  std::string str3=<span class="string">&quot;or not to be&quot;</span>;</span><br><span class="line">  std::string::iterator it;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// used in the same order as described above:</span></span><br><span class="line">  str.<span class="built_in">insert</span>(<span class="number">6</span>,str2);                 <span class="comment">// to be (the )question</span></span><br><span class="line">  str.<span class="built_in">insert</span>(<span class="number">6</span>,str3,<span class="number">3</span>,<span class="number">4</span>);             <span class="comment">// to be (not )the question</span></span><br><span class="line">  str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="string">&quot;that is cool&quot;</span>,<span class="number">8</span>);    <span class="comment">// to be not (that is )the question</span></span><br><span class="line">  str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="string">&quot;to be &quot;</span>);            <span class="comment">// to be not (to be )that is the question</span></span><br><span class="line">  str.<span class="built_in">insert</span>(<span class="number">15</span>,<span class="number">1</span>,<span class="string">&#x27;:&#x27;</span>);               <span class="comment">// to be not to be(:) that is the question</span></span><br><span class="line">  it = str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&#x27;,&#x27;</span>); <span class="comment">// to be(,) not to be: that is the question</span></span><br><span class="line">  str.<span class="built_in">insert</span> (str.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="string">&#x27;.&#x27;</span>);       <span class="comment">// to be, not to be: that is the question(...)</span></span><br><span class="line">  str.<span class="built_in">insert</span> (it+<span class="number">2</span>,str3.<span class="built_in">begin</span>(),str3.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">// (or )</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="尾部插入char"><a href="#尾部插入char" class="headerlink" title="尾部插入char"></a>尾部插入char</h3><p>不同的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;C+&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push_back</span>(ch);</span><br><span class="line">s += ch; <span class="comment">//string::operator+=, which is overloaded for chars and internally calls to the push_back() function.</span></span><br><span class="line">s.<span class="built_in">append</span>(<span class="number">1</span>, ch); <span class="comment">//1*ch个字符</span></span><br><span class="line">s.<span class="built_in">append</span>(<span class="string">&quot;abcd&quot;</span>); <span class="comment">//后面添加abcd字符串</span></span><br><span class="line"></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; s &lt;&lt; ch;</span><br><span class="line">ss &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">length</span>(), <span class="number">1</span>, ch);</span><br></pre></td></tr></table></figure>

<h3 id="截取string"><a href="#截取string" class="headerlink" title="截取string"></a>截取string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy three characters of s1 (starting</span></span><br><span class="line"><span class="comment">// from position 1)</span></span><br><span class="line"><span class="comment">//第一个参数是要截取的字符串，第二个参数是截取的开始位置，第三个参数是截取长度（可选）1。如果没有指定长度，则子字符串将延续到源字符串的结尾。</span></span><br><span class="line">string r = s1.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take any string</span></span><br><span class="line">string s = <span class="string">&quot;dog:cat&quot;</span>;</span><br><span class="line"><span class="comment">// Find position of &#x27;:&#x27; using find()</span></span><br><span class="line"><span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="comment">// Copy substring after pos(include pos)</span></span><br><span class="line">string sub = s.<span class="built_in">substr</span>(pos);</span><br><span class="line"><span class="comment">// Copy substring before pos(not include pos)</span></span><br><span class="line">string sub = s.<span class="built_in">substr</span>(<span class="number">0</span> , pos);</span><br></pre></td></tr></table></figure>

<h3 id="反转reverse-string"><a href="#反转reverse-string" class="headerlink" title="反转reverse string"></a>反转reverse string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(greeting.<span class="built_in">begin</span>(),greeting.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h3 id="寻找子元素位置"><a href="#寻找子元素位置" class="headerlink" title="寻找子元素位置"></a>寻找子元素位置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log1 中找空格</span></span><br><span class="line"><span class="type">int</span> pos1 = log1.<span class="built_in">find_first_of</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数字</span></span><br><span class="line"><span class="type">bool</span> isDigit1 = <span class="built_in">isdigit</span>(log1[pos1 + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否找到</span></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(goal) != string::npos)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>npos是一个常数，表示size_t的最大值（Maximum value for size_t）。许多容器都提供这个东西，用来表示不存在的位置，类型一般是std::container_type::size_type。</p>
<h3 id="string-erase"><a href="#string-erase" class="headerlink" title="string erase"></a>string erase</h3><p>三种情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string::erase</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;This is an example sentence.&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                                           <span class="comment">// &quot;This is an example sentence.&quot;</span></span><br><span class="line">  str.<span class="built_in">erase</span> (<span class="number">10</span>,<span class="number">8</span>);                        <span class="comment">//            ^^^^^^^^</span></span><br><span class="line">  <span class="comment">//去除index=10的连续8个元素</span></span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                                           <span class="comment">// &quot;This is an sentence.&quot;</span></span><br><span class="line">  str.<span class="built_in">erase</span> (str.<span class="built_in">begin</span>()+<span class="number">9</span>);               <span class="comment">//           ^</span></span><br><span class="line">  <span class="comment">//去除itr指向的元素</span></span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                                           <span class="comment">// &quot;This is a sentence.&quot;</span></span><br><span class="line">  str.<span class="built_in">erase</span> (str.<span class="built_in">begin</span>()+<span class="number">5</span>, str.<span class="built_in">end</span>()<span class="number">-9</span>);  <span class="comment">//       ^^^^^</span></span><br><span class="line">  <span class="comment">//去除[first,last).的元素</span></span><br><span class="line">  std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                                           <span class="comment">// &quot;This sentence.&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除最后一个元素"><a href="#删除最后一个元素" class="headerlink" title="删除最后一个元素"></a>删除最后一个元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;C,C++,Java,&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"> s.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"> s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"> s.<span class="built_in">erase</span>(std::<span class="built_in">prev</span>(s.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"> s.<span class="built_in">erase</span>(s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>STL 提供了 3 种<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6967.html">容器适配器</a>，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。</p>
<p><img src="https://pic.shaojiemike.top/img/20230217093111.png"></p>
<h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; minStack;</span><br><span class="line">minStack = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持初始化，但是注意将整个数组元素推入堆栈，堆栈的顶部元素top将是数组的第一个元素。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; elements = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; <span class="title function_">myStack</span><span class="params">(elements.begin(), elements.end())</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!minStack.empty()</span><br><span class="line">minStack.pop(); <span class="comment">//该函数仅用于从堆栈中删除元素，并且没有返回值。因此，我们可以说该函数的返回类型为void。</span></span><br><span class="line">minStack.push();</span><br><span class="line">minStack.top();</span><br></pre></td></tr></table></figure>

<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>注意pop仅用于从堆栈中删除元素，并且没有返回值, 一般用法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top_value = stIn.<span class="built_in">top</span>();</span><br><span class="line">stIn.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure>

<p>堆栈，先进先出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">empty 该函数用于测试堆栈是否为空。如果堆栈为空，则该函数返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">size 该函数返回堆栈容器的大小，该大小是堆栈中存储的元素数量的度量。</span><br><span class="line">top 该函数用于访问堆栈的顶部元素。该元素起着非常重要的作用，因为所有插入和删除操作都是在顶部元素上执行的。</span><br><span class="line">push 该函数用于在堆栈顶部插入新元素。</span><br><span class="line">pop 该函数用于删除元素，堆栈中的元素从顶部删除。</span><br><span class="line">emplace 该函数用于在当前顶部元素上方的堆栈中插入新元素。</span><br><span class="line">swap 该函数用于交换引用的两个容器的内容。</span><br></pre></td></tr></table></figure>

<h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><p>stack不支持clear, 除开一个个pop</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"><span class="comment">// 添加元素到 myStack</span></span><br><span class="line"></span><br><span class="line">myStack = std::<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// 清空 myStack, 丢弃原有对象</span></span><br><span class="line"></span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; emptyStack;</span><br><span class="line">myStack.<span class="built_in">swap</span>(emptyStack); <span class="comment">// 清空 myStack</span></span><br></pre></td></tr></table></figure>

<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">empty() 如果 queue 中没有元素的话，返回 true。</span><br><span class="line">size() 返回 queue 中元素的个数。</span><br><span class="line"></span><br><span class="line">front() 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span><br><span class="line">back() 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span><br><span class="line"></span><br><span class="line">push(const T&amp; obj) 在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</span><br><span class="line">emplace() 在 queue 的尾部直接添加一个元素。</span><br><span class="line">push(T&amp;&amp; obj) 以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</span><br><span class="line">pop() 删除 queue 中的第一个元素。</span><br><span class="line">swap(queue&lt;T&gt; &amp;other_queue) 将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</span><br></pre></td></tr></table></figure>

<h2 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6860.html">deque 容器</a>也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">begin() 返回指向容器中第一个元素的迭代器。</span><br><span class="line">end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</span><br><span class="line">rbegin() 返回指向最后一个元素的迭代器。</span><br><span class="line">rend() 返回指向第一个元素所在位置前一个位置的迭代器。</span><br><span class="line">cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span><br><span class="line">cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span><br><span class="line">crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span><br><span class="line">crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span><br><span class="line"></span><br><span class="line">size() 返回实际元素个数。</span><br><span class="line">max_size() 返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。</span><br><span class="line">resize() 改变实际元素的个数。</span><br><span class="line">empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</span><br><span class="line">shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。</span><br><span class="line"></span><br><span class="line">at() 使用经过边界检查的索引访问元素。</span><br><span class="line"></span><br><span class="line">front() 返回第一个元素的引用。</span><br><span class="line">back() 返回最后一个元素的引用。</span><br><span class="line">assign() 用新元素替换原有内容。</span><br><span class="line">push_back() 在序列的尾部添加一个元素。</span><br><span class="line">push_front() 在序列的头部添加一个元素。</span><br><span class="line">pop_back() 移除容器尾部的元素。</span><br><span class="line">pop_front() 移除容器头部的元素。</span><br><span class="line"></span><br><span class="line">insert() 在指定的位置插入一个或多个元素。</span><br><span class="line">erase() 移除一个元素或一段元素。</span><br><span class="line">clear() 移出所有的元素，容器大小变为 0。</span><br><span class="line">swap() 交换两个容器的所有元素。</span><br><span class="line">emplace() 在指定的位置直接生成一个元素。</span><br><span class="line">emplace_front() 在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</span><br><span class="line">emplace_back() 在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</span><br></pre></td></tr></table></figure>

<p><code>emplace_back()</code> not support <code>&lt;brace-enclosed initializer list&gt;</code> for <a target="_blank" rel="noopener" href="https://www.cnblogs.com/azureology/p/16250861.html">this</a></p>
<h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue(优先队列)"></a>priority_queue(优先队列)</h2><p>自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br></pre></td></tr></table></figure>

<h3 id="优先级排序原理"><a href="#优先级排序原理" class="headerlink" title="优先级排序原理"></a>优先级排序原理</h3><p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;Type, Container, Functional&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义降序1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">c</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line"> <span class="type">bool</span> <span class="title function_">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;p, <span class="type">const</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;q)</span> <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.first &lt; q.first;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, _c&gt; pq;</span><br><span class="line"><span class="comment">//自定义降序2</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;a, <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;b)&#123;<span class="keyword">return</span> a.second&lt;=b.second;&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, decltype(cmp)&gt; q(cmp);</span><br><span class="line"><span class="comment">//升序队列</span></span><br><span class="line"><span class="built_in">priority_queue</span> &lt;<span class="type">int</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line"><span class="built_in">priority_queue</span> &lt;<span class="type">int</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认排序是less，但是在priority_queue是降序。在其余数据结构里都是升序</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; answer;</span><br><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; busy;</span><br></pre></td></tr></table></figure>

<ol>
<li>Type 就是数据类型，</li>
<li>Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），</li>
<li>Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size() 返回优先队列的大小。</span><br><span class="line">empty() 它验证队列是否为空。基于验证，它返回队列的状态。</span><br><span class="line"></span><br><span class="line">top() 此函数用于寻址优先队列的最顶层元素。</span><br><span class="line"></span><br><span class="line">emplace() 它在优先队列的顶部插入一个新元素。</span><br><span class="line">push() 它将新元素插入优先队列。</span><br><span class="line">pop() 它将优先级最高的元素从队列中删除。</span><br><span class="line">swap() 它将优先队列的元素与具有相同类型和大小的另一个队列交换。</span><br></pre></td></tr></table></figure>

<h2 id="顺序容器与关联容器"><a href="#顺序容器与关联容器" class="headerlink" title="顺序容器与关联容器"></a>顺序容器与关联容器</h2><p>顺序容器包括vector、deque、list、forward_list、array、string，所有顺序容器都提供了快速<strong>顺序访问元素</strong>的能力。</p>
<p>关联容器包括set、map</p>
<p>关联容器和顺序容器有着根本的不同：关联容器中的元素是<strong>按关键字来保存和访问的</strong>。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>关联容器不支持顺序容器的位置相关的操作。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值得操作。</p>
<p>关联容器支持高效的关键字查找和访问。</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>链表，或者数组(如果父节点的数组下标是 i，那么它的左孩子就是 <code>i * 2 + 1</code>，右孩子就是 <code>i * 2 + 2</code>。)</p>
<p>链式结构如下，注意左右孩子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* a = new TreeNode();</span><br><span class="line">a-&gt;val = 9;</span><br><span class="line">a-&gt;left = NULL;</span><br><span class="line">a-&gt;right = NULL;</span><br></pre></td></tr></table></figure>

<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>深度遍历： 前&#x2F;中&#x2F;后序遍历。</p>
<p>注意：这里前中后，其实指的就是<strong>中间节点&#x2F;根节点</strong>的遍历顺序</p>
<h2 id="heap-堆"><a href="#heap-堆" class="headerlink" title="heap 堆"></a>heap 堆</h2><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称。</p>
<p>堆通常是一个可以被看做一棵<strong>完全二叉树</strong>的数组对象。</p>
<p>堆满足下列性质：</p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值。<ul>
<li>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；</li>
<li>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</li>
</ul>
</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
<h3 id="STL操作"><a href="#STL操作" class="headerlink" title="STL操作"></a>STL操作</h3><ul>
<li><code>make_heap()</code>​​将区间内的元素转化为heap.</li>
<li><code>​push_heap()</code>​​对heap增加一个元素.</li>
<li><code>​​pop_heap()</code>​​对heap取出下一个元素.</li>
<li><code>​sort_heap()</code>​​对heap转化为一个已排序群集.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int myints[] = &#123;10,20,30,5,15&#125;;</span><br><span class="line">vector&lt;int&gt; v(myints,myints+5);</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">make_heap (v.begin(),v.end());//male_heap就是构造一棵树，使得每个父结点均大于等于其子女结点</span><br><span class="line">cout &lt;&lt; &quot;initial max heap   : &quot; &lt;&lt; v.front() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">pop_heap (v.begin(),v.end());//pop_heap不是删除某个元素而是把第一个和最后一个元素对调后[first,end-1]进行构树，最后一个不进行构树</span><br><span class="line">v.pop_back();//删除最后一个的结点</span><br><span class="line">cout &lt;&lt; &quot;max heap after pop : &quot; &lt;&lt; v.front() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.push_back(99);//在最后增加一个结点</span><br><span class="line">push_heap (v.begin(),v.end());//重新构树</span><br><span class="line">cout &lt;&lt; &quot;max heap after push: &quot; &lt;&lt; v.front() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">sort_heap (v.begin(),v.end());//把树的结点的权值进行排序，排序后，序列将失去堆的特性</span><br><span class="line">//请在使用这个函数前，确定序列符合堆的特性，否则会报错！</span><br></pre></td></tr></table></figure>

<h2 id="hash-map-VS-unordered-map"><a href="#hash-map-VS-unordered-map" class="headerlink" title="hash_map VS unordered_map"></a>hash_map VS unordered_map</h2><p>由于在C++标准库中没有定义散列表hash_map，标准库的不同实现者将提供一个通常名为hash_map的非标准散列表。因为这些实现不是遵循标准编写的，所以它们在功能和性能保证上都有微妙的差别。</p>
<p>从C++11开始，哈希表实现已添加到C++标准库标准。决定对类使用备用名称，以防止与这些非标准实现的冲突，并防止在其代码中有hash_table的开发人员无意中使用新类。</p>
<p>所选择的备用名称是unordered_map，它更具描述性，因为它暗示了类的映射接口和其元素的无序性质。</p>
<p>可见hash_map ， unordered_map本质是一样的，只不过 <strong>unordered_map被纳入了C++标准库标准</strong>。</p>
<h3 id="map-vs-unordered-map"><a href="#map-vs-unordered-map" class="headerlink" title="map vs unordered_map"></a>map vs unordered_map</h3><ol>
<li>map<ol>
<li>内部数据的组织，基于<strong>红黑树</strong>实现，红黑树具有自动排序的功能，因此map内部所有的数据，在任何时候，都是有序的。其中每个键都是唯一的，可以插入或删除，但不能更改。但是与键关联的值可以更改。</li>
<li>红黑树是一种含有红黑结点并能自平衡的<strong>二叉查找&#x2F;搜索树</strong>, 别称平衡二叉B树（symmetric binary B-trees）</li>
</ol>
</li>
<li>unordered_map(hash_map)<ol>
<li>基于<strong>哈希表</strong>，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</li>
<li>标准库的unordered_map，底层实现是基于hashtable的，其避免冲突的方法是使用开链（seperate chaining）法，这种做法是在每一个表格元素中维护一个list，每个表格元素称之为buket（桶）<img src="https://pic.shaojiemike.top/img/20220914082637.png"></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">                       | map              | unordered_map</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">element ordering       | strict weak      | n/a </span><br><span class="line">                       |                  |</span><br><span class="line">common implementation  | balanced tree    | hash table</span><br><span class="line">                       | or red-black tree|  </span><br><span class="line">                       |                  |</span><br><span class="line">search time            | log(n)           | O(1) if there are no hash collisions</span><br><span class="line">                       |                  | Up to O(n) if there are hash collisions </span><br><span class="line">                       |                  | O(n) when hash is the same for any key</span><br><span class="line">                       |                  |     </span><br><span class="line">Insertion time         | log(n)+rebalance | Same as search</span><br><span class="line">                       |                  | </span><br><span class="line">Deletion time          | log(n)+rebalance | Same as search</span><br><span class="line">                       |                  | </span><br><span class="line">needs comparators      | only operator &lt;  | only operator ==</span><br><span class="line">                       |                  |</span><br><span class="line">needs hash function    | no               | yes</span><br><span class="line">                       |                  |</span><br><span class="line">common use case        | when good hash is| In most other cases. </span><br><span class="line">                       | not possible or  | </span><br><span class="line">                       | too slow. Or when|</span><br><span class="line">                       | order is required| </span><br></pre></td></tr></table></figure>

<h3 id="map初始化"><a href="#map初始化" class="headerlink" title="map初始化"></a>map初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++11以上</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="type">int</span>&gt; m3 = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;string&quot;</span>,<span class="number">1</span>&#125;, &#123;<span class="string">&quot;sec&quot;</span>,<span class="number">2</span>&#125;, &#123;<span class="string">&quot;trd&quot;</span>,<span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; m4 = &#123;</span><br><span class="line">&#123;<span class="string">&quot;first&quot;</span>,<span class="string">&quot;second&quot;</span>&#125;, &#123;<span class="string">&quot;third&quot;</span>,<span class="string">&quot;fourth&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;fifth&quot;</span>,<span class="string">&quot;sixth&quot;</span>&#125;, &#123;<span class="string">&quot;begin&quot;</span>,<span class="string">&quot;end&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="unordered-map-哈希表"><a href="#unordered-map-哈希表" class="headerlink" title="unordered_map 哈希表"></a>unordered_map 哈希表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int, int&gt; umap;</span><br><span class="line">umap[a + b]++;</span><br></pre></td></tr></table></figure>

<p>map的value是int，默认为0。可以直接++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">++cnt[num];</span><br><span class="line"><span class="comment">// c++17 支持</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[num, c] : cnt) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = cnt.<span class="built_in">begin</span>(); it != cnt.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; key = it-&gt;first;</span><br><span class="line">    <span class="keyword">auto</span>&amp; value = it-&gt;second;</span><br><span class="line">    <span class="comment">// 使用 key 和 i 进行操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, _] : cnt) &#123;</span><br><span class="line">    <span class="comment">//sth</span></span><br><span class="line">&#125;</span><br><span class="line">cnt.<span class="built_in">at</span>(num) <span class="comment">//unordered_map 类模板中，还提供有 at() 成员方法，和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出out_of_range异常。</span></span><br></pre></td></tr></table></figure>

<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// insert 不能覆盖元素，已经存在会失败</span><br><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br><span class="line">// 数组方式可以覆盖</span><br><span class="line">mapStudent[1] = &quot;student_one&quot;;  </span><br></pre></td></tr></table></figure>

<p>可以用pair来获得是否insert成功，程序如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair;</span><br><span class="line"></span><br><span class="line">Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</span><br></pre></td></tr></table></figure>

<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p>
<h3 id="查找是否存在-count"><a href="#查找是否存在-count" class="headerlink" title="查找是否存在 count"></a>查找是否存在 count</h3><p>用count函数来判定关键字是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了</p>
<h3 id="查找是否存在-find"><a href="#查找是否存在-find" class="headerlink" title="查找是否存在 find"></a>查找是否存在 find</h3><p>通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：</p>
<ol>
<li>当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；</li>
<li>当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查找成功</span><br><span class="line">unordered_map&lt;string, string&gt;::iterator iter = umap.find(&quot;Python教程&quot;);</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">//查找失败</span><br><span class="line">unordered_map&lt;string, string&gt;::iterator iter2 = umap.find(&quot;GO教程&quot;);</span><br><span class="line">if (iter2 == umap.end()) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;当前容器中没有以\&quot;GO教程\&quot;为键的键值对&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.erase (&#x27;c&#x27;);               // erasing by key</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ol>
<li>按关键字有序保存元素：<ol>
<li>set(关键字即值，即只保存关键字的容器)；</li>
<li>multiset(关键字可重复出现的set)；</li>
</ol>
</li>
<li>无序集合：<ol>
<li>unordered_set(用哈希函数组织的set)；</li>
<li>unordered_multiset(哈希组织的set，关键字可以重复出现)。</li>
</ol>
</li>
</ol>
<p>set就是关键字的简单集合。当只是想知道<strong>一个值是否存在</strong>时，set是最有用的。</p>
<p>在set中每个元素的值都<strong>唯一</strong>，而且系统能根据元素的值自动进行排序。set中元素的值<strong>不能直接被改变</strong>。set内部采用的是一种非常高效的平衡检索二叉树：红黑树，也称为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树。</p>
<p>set具备的两个特点：</p>
<ul>
<li>set中的元素都是排序好的</li>
<li>set中的元素都是唯一的，没有重复的</li>
</ul>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>定义的参数compare可见，为了确定唯一性，需要有个值唯一表示存储的复杂类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class T,                             // set::key_type/value_type</span><br><span class="line">           class Compare = less&lt;T&gt;,        // set::key_compare/value_compare</span><br><span class="line">           class Alloc = allocator&lt;T&gt;         // set::allocator_type</span><br><span class="line">           &gt; class set;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">set&lt;char&gt; vowel &#123;&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">insert()–在集合中插入元素</span><br><span class="line">emplace() 最大的作用是避免产生不必要的临时变量</span><br><span class="line">erase()–删除集合中的元素</span><br><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line">size_type <span class="title function_">erase</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span>;</span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line">iterator  <span class="title function_">erase</span> <span class="params">(const_iterator position)</span>;</span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line">iterator  <span class="title function_">erase</span> <span class="params">(const_iterator first, const_iterator last)</span>;</span><br><span class="line"><span class="comment">//第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；</span></span><br><span class="line"><span class="comment">//后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。</span></span><br><span class="line"></span><br><span class="line">find()–返回一个指向被查找到元素的迭代器。返回值：该函数返回一个迭代器，该迭代器指向在集合容器中搜索的元素。如果找不到该元素，则迭代器将指向集合中最后一个元素之后的位置end</span><br><span class="line"><span class="title function_">count</span><span class="params">()</span>- 查找的<span class="type">bool</span>结果</span><br><span class="line"><span class="title function_">size</span><span class="params">()</span>–集合中元素的数目</span><br><span class="line"></span><br><span class="line"><span class="title function_">begin</span><span class="params">()</span>;            <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">end();              <span class="comment">// 返回指向迭代器的最末尾处（即最后一个元素的下一个位置）</span></span><br><span class="line">clear();            <span class="comment">// 清除所有元素</span></span><br><span class="line">count();            <span class="comment">// 返回某个值元素的个数</span></span><br><span class="line"></span><br><span class="line">swap()–交换两个集合变量</span><br><span class="line"></span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">  <span class="type">bool</span> operator== ( <span class="type">const</span> <span class="built_in">set</span>&lt;T,Compare,Alloc&gt;&amp; lhs,</span><br><span class="line">                    <span class="type">const</span> <span class="built_in">set</span>&lt;T,Compare,Alloc&gt;&amp; rhs ); <span class="comment">// 和map类似的，重载相等判断</span></span><br></pre></td></tr></table></figure>

<h3 id="set-lower-bound-key"><a href="#set-lower-bound-key" class="headerlink" title="set::lower_bound(key)"></a>set::lower_bound(key)</h3><p>參數：該函數接受單個強製性參數鍵，該鍵指定要返回其lower_bound的元素。</p>
<p>返回值：該函數返回一個指向容器中元素的迭代器，該迭代器等效於在參數中傳遞的k。如果set容器中不存在k，則該函數返回一個迭代器，該迭代器指向剛好大於k的下一個元素。如果參數中傳遞的鍵超過了容器中的最大值，則返回的迭代器等效於s.end()(特殊的迭代器指向最後一個元素)。</p>
<h3 id="find-example"><a href="#find-example" class="headerlink" title="find example"></a>find example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//set.find(key)!=set.end() 的判断一般会比count快</span><br><span class="line">auto p = points.find(&#123;x, y&#125;);</span><br><span class="line">if (p != points.end()) &#123;</span><br><span class="line"> points.erase(p);</span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查键30是否存在</span><br><span class="line">if (mp.count(30))</span><br><span class="line"> cout &lt;&lt; &quot;键30存在\n&quot;;</span><br><span class="line">else</span><br><span class="line"> cout &lt;&lt; &quot;键30不存在\n&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto hash_p = [](const pair&lt;int, int&gt; &amp;p) -&gt; size_t &#123;</span><br><span class="line">  static hash&lt;long long&gt; hash_ll;</span><br><span class="line">  return hash_ll(p.first + (static_cast&lt;long long&gt;(p.second) &lt;&lt; 32));</span><br><span class="line"> &#125;;</span><br><span class="line">unordered_set&lt;pair&lt;int, int&gt;, decltype(hash_p)&gt; points(0, hash_p); //(0,hash_p)分别为迭代器的开始和结束的标记（数组多为数据源）</span><br><span class="line">//多用于数组 set&lt;int&gt; iset(arr,arr+sizeof(arr)/sizeof(*arr));</span><br></pre></td></tr></table></figure>

<p>类似的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto hash = [](const std::pair&lt;int, int&gt;&amp; p)&#123; return p.first * 31 + p.second; &#125;;</span><br><span class="line">std::unordered_set&lt;std::pair&lt;int, int&gt;, decltype(hash)&gt; u_edge_(8, hash);</span><br></pre></td></tr></table></figure>

<p>上面的不是用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">lambda expression</a>隐函数，而是定义函数的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct pair_hash &#123;</span><br><span class="line">    inline std::size_t operator()(const std::pair&lt;int,int&gt; &amp; v) const &#123;</span><br><span class="line">        return v.first*31+v.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::unordered_set&lt; std::pair&lt;int, int&gt;,  pair_hash&gt; u_edge_;</span><br></pre></td></tr></table></figure>

<h3 id="How-to-use-unordered-set-with-custom-types"><a href="#How-to-use-unordered-set-with-custom-types" class="headerlink" title="How to use unordered_set with custom types?"></a>How to use unordered_set with custom types?</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9729390/how-to-use-unordered-set-with-custom-types/9729747#9729747">https://stackoverflow.com/questions/9729390/how-to-use-unordered-set-with-custom-types/9729747#9729747</a></p>
<h3 id="set-map-的区别"><a href="#set-map-的区别" class="headerlink" title="set map 的区别"></a>set map 的区别</h3><p>map和set都是C++的关联容器，其底层实现都是<strong>红黑树</strong>（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。<br>map和set区别在于：</p>
<p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，<strong>set中每个元素只包含一个关键字</strong>。</p>
<p>（2）<strong>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key</strong>其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）<strong>map支持下标操作，set不支持下标操作</strong>。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h3 id="map和multimap的区别"><a href="#map和multimap的区别" class="headerlink" title="map和multimap的区别"></a>map和multimap的区别</h3><p>map不允许相同key值存在，multimap则允许相同的key值存在。</p>
<p><img src="https://pic.shaojiemike.top/img/20220904180625.png"></p>
<h3 id="set-map-后insert-先输出"><a href="#set-map-后insert-先输出" class="headerlink" title="set&#x2F;map 后insert 先输出"></a>set&#x2F;map 后insert 先输出</h3><p>由于是有序的，对于int这种能比大小的，默认是<a target="_blank" rel="noopener" href="https://blog.csdn.net/carbon06/article/details/78450927">输出是从小到大</a>，可以改变。</p>
<ul>
<li>set中存放的为数（整数，浮点数……），在set中会按从小到大排列这些数<ul>
<li>存放指针，都会按照地址排序</li>
</ul>
</li>
<li>set 中存放的为string，存入的string会按字母表顺序排列</li>
<li>至于存放类的话，还可以自己定义排列规则</li>
<li>存放结构体？没定义大小关系的类？<ul>
<li><code>*it</code> 递增的顺序，存储的是指向某元素的指针，则是指针地址递增的顺序。</li>
</ul>
</li>
</ul>
<h2 id="并差集"><a href="#并差集" class="headerlink" title="并差集"></a>并差集</h2><p>核心是</p>
<ol>
<li>同一个并查集内的元素会指向同一个parent</li>
<li>可以维护并查集总个数Rank</li>
<li>和每个并查集的子集合元素个数</li>
<li>数据结构用数组和map都行</li>
</ol>
<p>例子是LeetCode 1020</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化未union的数组</span></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp; grid) &#123;<span class="comment">//初始化遍历</span></span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m * n);</span><br><span class="line">        <span class="comment">//this-&gt;onEdge = vector&lt;bool&gt;(m * n, false);</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;rank = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m * n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> index = i * n + j;</span><br><span class="line">                    parent[index] = index;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//onEdge[index] = true;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原始版本</span></span><br><span class="line">        <span class="keyword">return</span> (parent[i] == i)? i : <span class="built_in">find</span>(parent[i]);</span><br><span class="line">        <span class="comment">// “路径压缩”。在执行Find的过程中，将路径上的所有节点都直接连接到根节点上。</span></span><br><span class="line">        <span class="keyword">return</span> (parent[i] == i)? i : (parent[i] = <span class="built_in">find</span>(parent[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootx = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rooty = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            <span class="comment">// &quot;按秩合并&quot;。实际上就是在合并两棵树时，将高度较小的树合并到高度较大的树上。</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                parent[rootx] = rooty;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">                rank[rootx]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank;  </span><br><span class="line">    <span class="comment">// 如果带合并的元素表示有负数表示，或者不是连续表示的。可以使用map</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; parent;<span class="comment">//定义一个并查集</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ranks;<span class="comment">//定义树的深</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于不确定元素个数来初始化的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    std::unordered_map&lt;BBLID, BBLID&gt; parent;</span><br><span class="line"></span><br><span class="line">    <span class="function">BBLID <span class="title">Find</span><span class="params">(BBLID l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = parent.<span class="built_in">find</span>(l);</span><br><span class="line">        <span class="keyword">if</span> (it == parent.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            parent[l] = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[l] != l) &#123;</span><br><span class="line">                <span class="comment">// 路径压缩部分</span></span><br><span class="line">                parent[l] = parent[parent[l]];</span><br><span class="line">                l = parent[l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(BBLID m, BBLID n)</span> </span>&#123;</span><br><span class="line">        BBLID x = <span class="built_in">Find</span>(m);</span><br><span class="line">        BBLID y = <span class="built_in">Find</span>(n);</span><br><span class="line">        parent[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="emplace-VS-push"><a href="#emplace-VS-push" class="headerlink" title="emplace VS push"></a>emplace VS push</h3><p><code>push()</code> adds a copy of an already constructed object into the queue as a parameter, it takes an object of the queue’s element type.</p>
<p><code>emplace()</code> constructs a new object in-place at the end of the queue. It takes as parameters the parameters that the queue’s element types constructor takes.</p>
<p>If your usage pattern is one where you create a new object and add it to the container, you <strong>shortcut a few steps</strong>(creation of a temporary object and copying it) by using <code>emplace()</code>.</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int array[2][3] = &#123;</span><br><span class="line">  &#123;0, 1, 2&#125;,</span><br><span class="line">  &#123;3, 4, 5&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数组初始化为0"><a href="#数组初始化为0" class="headerlink" title="数组初始化为0"></a>数组初始化为0</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接初始化为0</span></span><br><span class="line"><span class="type">int</span> a[SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[SIZE];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">1000</span>);<span class="comment">//这里的1000是数组大小，需要多少替换下就可以了。 </span></span><br></pre></td></tr></table></figure>

<p>注意 memset是按照字节进行赋值，即对每一个字节赋相同值。除开0和-1，其他值都是不安全的，不会赋值期望的值。比如int是四个字节。</p>
<ul>
<li><code>memset（a，127，sizeof（a））</code>，全部初始化为int的较大值，即2139062143(int 最大值为2147483647)；</li>
<li><code>memset（a，128，sizeof（a））</code>，全部初始化为一个很小的数，比int最小值略大，为-2139062144。</li>
</ul>
<p>calloc &amp; malloc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区分</span></span><br><span class="line"><span class="comment">//calloc() 函数是动态申请内存函数之一，相当于用malloc函数申请并且初始化一样，calloc函数会将申请的内存全部初始化为0。</span></span><br><span class="line"><span class="type">int</span> *res = (<span class="type">int</span>*)<span class="built_in">calloc</span>(numsSize, <span class="built_in">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="type">int</span> *res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(numsSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(res, <span class="number">0</span>, numsSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//错误写法： memset(res, 0, sizeof(res)); res是指针变量，不管 res 指向什么类型的变量，sizeof( res ) 的值都是 4。</span></span><br></pre></td></tr></table></figure>

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>();<span class="comment">//此时p指向内存的单变量被初始化为0</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">5</span>);<span class="comment">//此时p指向内存的单变量被初始化为5</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]()<span class="comment">//此时p指向数组首元素，且数组元素被初始化为0</span></span><br><span class="line"><span class="comment">//c++11 允许列表初始化，因此也有了以下几种形式形式</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>&#123;&#125;<span class="comment">//p指向的单变量被初始化为0</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">8</span>&#125;<span class="comment">//p指向变量被初始化为8</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]&#123;&#125;<span class="comment">//p指向的数组被初始化为0</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//p指向数组的前三个元素被初始化为1，2，3，后边97个元素初始化为0；</span></span><br></pre></td></tr></table></figure>

<h3 id="new-三维数组"><a href="#new-三维数组" class="headerlink" title="new 三维数组"></a>new 三维数组</h3><p>建议老实用vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ***array;</span><br><span class="line"><span class="comment">// 假定数组第一维为 m， 第二维为 n， 第三维为h</span></span><br><span class="line"><span class="comment">// 动态分配空间</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="type">int</span> **[m];</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="type">int</span> *[n];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        array[i][j] = <span class="keyword">new</span> <span class="type">int</span> [h];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] array[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode-support-VLA"><a href="#Leetcode-support-VLA" class="headerlink" title="Leetcode support VLA"></a>Leetcode support VLA</h3><ul>
<li>The C++ standard does not officially support <strong>Variable Length Arrays (VLA)</strong>, but some compilers, such as g++ and Clang++, may accept it as valid syntax as an extension to the language.</li>
<li>leetcode uses g++ 5.4.0 compiler for C++ compilation. It supports variable length array definitions. After ISO C99 specification, arrays with variable length declarations are <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">allowed.</a><ul>
<li>The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits.</li>
</ul>
</li>
<li>And <a target="_blank" rel="noopener" href="https://leetcode.com/discuss/general-discussion/1507754/three-methods-declare-2d-array-in-cpp-whose-memory-consumption-differ-significantly">memory consumption differ significantly.</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeConcatenatedLength</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f[n][<span class="number">26</span>][<span class="number">26</span>];</span><br></pre></td></tr></table></figure>

<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;            <span class="comment">//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p1</span><span class="params">(v1, v2)</span></span>;    <span class="comment">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);          <span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line">p1 &lt; p2;                    <span class="comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span></span><br><span class="line">p1 == p2；                  <span class="comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span></span><br><span class="line">p1.first;                   <span class="comment">// 返回对象p1中名为first的公有数据成员</span></span><br><span class="line">p1.second;                 <span class="comment">// 返回对象p1中名为second的公有数据成员</span></span><br></pre></td></tr></table></figure>

<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>array也位于名称空间std中,与数组同样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,所以其效率与数组相同,但更方便,更安全.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array&lt;typeName, nElem&gt; arr;</span><br><span class="line"></span><br><span class="line"># include &lt;array&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">array&lt;int, 5&gt; ai;</span><br><span class="line">array&lt;double, 4&gt; ad = &#123;1.1,1.2,1.2,1.3&#125;;</span><br><span class="line"></span><br><span class="line">//通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</span><br><span class="line">std::array&lt;double, 10&gt; values &#123;&#125;;</span><br><span class="line">//使用该语句，容器中所有的元素都会被初始化为 0.0。</span><br><span class="line"></span><br><span class="line">//二维</span><br><span class="line">std::array&lt;std::array&lt;int, 2&gt;, 3&gt; m = &#123; &#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.shaojiemike.top/img/20220206093630.png"></p>
<h2 id="单链表-（自定义）"><a href="#单链表-（自定义）" class="headerlink" title="单链表 （自定义）"></a>单链表 （自定义）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 单链表</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;  // 节点上存储的元素</span><br><span class="line">    ListNode *next;  // 指向下一个节点的指针</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListNode* head = new ListNode(5);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">ListNode* head = new ListNode();</span><br><span class="line">head-&gt;val = 5;</span><br><span class="line"></span><br><span class="line">while(result != nullptr &amp;&amp; result-&gt;val == val)&#123;</span><br><span class="line"> //多使用nullptr </span><br><span class="line"> ListNode* tmp_free = result;</span><br><span class="line"> result = result-&gt;next;</span><br><span class="line"> delete tmp_free; // 注意释放空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nullptr是一个关键字，可以在所有期望为NULL的地方使用。</p>
<ul>
<li>与NULL一样，可与任何指针类型相比较。</li>
<li>与NULL不同，只能被赋值给指针类型，它不能隐式转换，也不能与整型相比较。与NULL通常被定义为整数0的宏定义 之间来区分。</li>
</ul>
<h2 id="list-双向链表"><a href="#list-双向链表" class="headerlink" title="list 双向链表"></a>list 双向链表</h2><p>STL list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。</p>
<p><img src="https://pic.shaojiemike.top/img/20230204090102.png"></p>
<ul>
<li>特点：<ul>
<li>可以看到，list 容器中各个元素的前后顺序是靠指针来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</li>
<li>vector是连续的容器，而list是非连续的容器，即vector将元素存储在连续的存储器中，而list存储在不连续的存储器中。</li>
</ul>
</li>
<li>优点<ul>
<li>list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，</li>
<li>可以在序列已知的任何位置快速插入或删除元素（时间复杂度为O(1)）。</li>
<li>并且在 list 容器中移动元素，也比其它容器的效率高。</li>
</ul>
</li>
<li>缺点<ul>
<li>不能像 array 和 vector 那样，通过位置直接访问元素。<ul>
<li>举个例子，如果要访问 list 容器中的第 6 个元素，它不支持容器对象名[6]这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</li>
</ul>
</li>
</ul>
</li>
<li>应用场景：需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="type">int</span>&gt;&gt; lst;</span><br><span class="line">unordered_map&lt;string, list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="type">int</span>&gt;&gt;::iterator&gt; nodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cur = nodes[key], nxt = <span class="built_in">next</span>(cur); <span class="comment">//对迭代器使用next</span></span><br><span class="line">nodes[key] = lst.<span class="built_in">emplace</span>(nxt, s, cur-&gt;second + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">*lst.<span class="built_in">rbegin</span>()-&gt;first.<span class="built_in">begin</span>(); <span class="comment">//链表最后元素的first也就是unordered_set&lt;string&gt;的第一个</span></span><br></pre></td></tr></table></figure>

<h3 id="emplace-emplace-front"><a href="#emplace-emplace-front" class="headerlink" title="emplace &amp; emplace_front"></a>emplace &amp; emplace_front</h3><p>C ++ List emplace()函数在指定位置插入新元素，并且列表的大小增加一。</p>
<p>语法<br><code>iterator emplace(iterator pos, value_type val);</code><br>参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pos：它定义了要插入新元素的位置。</span><br><span class="line"></span><br><span class="line">val：要在指定位置插入的新值。</span><br></pre></td></tr></table></figure>

<p>返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它返回指向新构造元素的迭代器。</span><br></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize)   <span class="comment">//创建一个vector,元素个数为nSize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定值初始化，ilist5被初始化为包含7个值为3的int</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize,<span class="type">const</span> t&amp; t)<span class="comment">//创建一个vector，元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ilist5</span><span class="params">(<span class="number">7</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">//区分列表初始化, 包含7 和 3两个元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ilist5&#123;<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变大小</span></span><br><span class="line">vals.<span class="built_in">reserve</span>(cnt.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p>二维vector, 两个维度的长度都未知时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">name</span> (xSize, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(ySize, <span class="literal">false</span>));</span><br><span class="line"><span class="comment">//leetcode假如写在函数外，class public下，第二维度为空</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; alphaIndexList&#123;<span class="number">26</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>)&#125;; </span><br><span class="line"><span class="comment">//指针使用</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* todo;</span><br><span class="line">todo= &amp;alphaIndexList[i];</span><br><span class="line"><span class="type">int</span> n = todo-&gt;<span class="built_in">size</span>(); <span class="comment">// (*todo).size();</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: *todo)</span><br></pre></td></tr></table></figure>

<p>二维vector, 已知某一个维度的大小:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alphaIndexList[<span class="number">26</span>];</span><br><span class="line">alphaIndexList[i].<span class="built_in">push_back</span>(x);</span><br></pre></td></tr></table></figure>

<h3 id="返回表示"><a href="#返回表示" class="headerlink" title="返回表示"></a>返回表示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sth</span></span><br><span class="line">    <span class="keyword">return</span> &#123;it-&gt;second, i&#125;; <span class="comment">//no []</span></span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h3><p>如果需要元素有序，考虑<code>stable_sort</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是从低到高，加入std::greater&lt;int&gt;() 变成从高到低排序</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector of pair</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; arr = &#123;&#123;a, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="string">&#x27;c&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++14 </span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> &amp;left, <span class="keyword">auto</span> &amp;right) &#123;</span><br><span class="line">    <span class="keyword">return</span> left.second &lt; right.second;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11 using lambdas</span></span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), </span><br><span class="line"> [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &amp; p2) &#123;</span><br><span class="line">  <span class="keyword">return</span> p1.first &gt; p2.first;</span><br><span class="line"> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//origin </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sort_pred</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;left, <span class="type">const</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.second &lt; right.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">sort_pred</span>());</span><br></pre></td></tr></table></figure>

<h3 id="增加函数"><a href="#增加函数" class="headerlink" title="增加函数"></a>增加函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span>      :向量尾部增加一个元素X</span></span><br><span class="line"><span class="function">void emplace_back(const T&amp; x)</span></span><br><span class="line"><span class="function">iterator insert(iterator it,const T&amp; x)   :向量中迭代器指向元素前增加一个元素x</span></span><br><span class="line"><span class="function">result.insert(result.begin()+p,x);</span>     :在result的index为p的位置插入元素</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> :向量中迭代器指向元素前增加n个相同的元素x</span></span><br><span class="line"><span class="function">iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</span></span><br></pre></td></tr></table></figure>

<h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span>     :删除向量中迭代器指向元素</span></span><br><span class="line"><span class="function">iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</span></span><br><span class="line"><span class="function">void pop_back()        :删除向量中最后一个元素</span></span><br><span class="line"><span class="function">void clear()        :清空向量中所有元素</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历查找函数"><a href="#遍历查找函数" class="headerlink" title="遍历查找函数"></a>遍历查找函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(<span class="type">int</span> pos)</span>  :返回pos位置元素的引用</span></span><br><span class="line"><span class="function">reference front()   :返回首元素的引用</span></span><br><span class="line"><span class="function">reference back()   :返回尾元素的引用</span></span><br><span class="line"><span class="function">iterator begin()   :返回向量头指针，指向第一个元素</span></span><br><span class="line"><span class="function">iterator end()    :返回向量尾指针，指向向量最后一个元素的下一个位置</span></span><br><span class="line"><span class="function">reverse_iterator rbegin() :反向迭代器，指向最后一个元素</span></span><br><span class="line"><span class="function">reverse_iterator rend()  :反向迭代器，指向第一个元素之前的位置</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">upper_bound(prefix_sum.begin(),prefix_sum.end(),a) : 查找满足prefix_sum[i]&lt;=</span>a的最大i</span><br></pre></td></tr></table></figure>

<h3 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span>   :判断向量是否为空，若为空，则向量中无元素</span></span><br></pre></td></tr></table></figure>

<h3 id="大小函数"><a href="#大小函数" class="headerlink" title="大小函数"></a>大小函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span>  :返回向量中元素的个数</span></span><br><span class="line"><span class="function">int capacity() const :返回当前向量所能容纳的最大元素值</span></span><br><span class="line"><span class="function">int max_size() const :返回最大可允许的vector元素数量值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#include &lt;algorithm&gt; </span></span><br><span class="line"><span class="function">// C++ vector 容器裡使用 std::max_element 找最大值（或者min_element）的範例，std::max_element 會回傳一個迭代器，這個迭代器會指向該容器範圍內最大值的元素，</span></span><br><span class="line"><span class="function">vector&lt;int&gt;::iterator result =</span> std::<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> index = result - v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> value = (*result)</span><br></pre></td></tr></table></figure>

<h3 id="片段的截取"><a href="#片段的截取" class="headerlink" title="片段的截取"></a>片段的截取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; Arrs &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">// 假设有这么个数组,要截取中间第二个元素到第四个元素：2，3，4</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator First = Arrs.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 找到第二个迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator Second = Arrs.<span class="built_in">begin</span>() + <span class="number">3</span>; <span class="comment">// 找到第三个迭代器</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Arrs2</span><span class="params">(First, Second)</span></span>; <span class="comment">// 将值直接初始化到Arrs2</span></span><br></pre></td></tr></table></figure>

<p>迭代器是指可在容器对象上遍访的对象</p>
<p>或者assign()功能函数实现截取</p>
<p>assign() 功能函数是vector容器的成员函数。原型：</p>
<p>1:<code>void assign(const_iterator first,const_iterator last);</code>&#x2F;&#x2F;两个指针，分别指向开始和结束的地方<br>2:<code>void assign(size_type n,const T&amp; x = T());</code> &#x2F;&#x2F;n指要构造的vector成员的个数， x指成员的数值，他的类型必须与vector类型一致！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; Arrs &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">// 假设有这么个数组,要截取中间第二个元素到第四个元素：2，3，4</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator First = Arrs.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 找到第二个迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator Second = Arrs.<span class="built_in">begin</span>() + <span class="number">3</span>; <span class="comment">// 找到第三个迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Arr2;</span><br><span class="line">Arr2.<span class="built_in">assign</span>(First,Second); <span class="comment">//使用assign() 成员函数将Arrs对应位置的值存入Arrs2数组中</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="type">double</span> max = *<span class="built_in">max_element</span>(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>());</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Max value: &quot;</span>&lt;&lt;max&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line"><span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) &#123;  <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">    *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator j = v.<span class="built_in">rbegin</span>(); j != v.<span class="built_in">rend</span>(); ++j)</span><br><span class="line">    cout &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>迭代器之间的减法是被允许的，两个迭代器相减返回是它们之间的距离，这个距离是一个符号类整型（signed），意味着两个迭代器之间相减可能是正数、零或者负数。</p>
<h3 id="其他赋值函数"><a href="#其他赋值函数" class="headerlink" title="其他赋值函数"></a>其他赋值函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="built_in">vector</span>&amp;)</span>    :交换两个同类型向量的数据</span><br><span class="line"><span class="type">void</span> <span class="title function_">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">const</span> T&amp; x)</span> :设置向量中前n个元素的值为x</span><br><span class="line"><span class="type">void</span> <span class="title function_">assign</span><span class="params">(const_iterator first,const_iterator last)</span>:向量中[first,last)中元素设置成当前向量元素</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//或者#include &lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="title function_">reverse</span><span class="params">(a.begin(), a.end())</span>;</span><br><span class="line"><span class="built_in">std</span>::reverse(a,a+<span class="number">5</span>);  <span class="comment">//转换0～5下标的元素</span></span><br><span class="line"></span><br><span class="line">fill(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value) <span class="comment">//fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(first,last,val);//first为容器的首迭代器，last为容器的末迭代器，val为将要替换的值。</span></span><br><span class="line">fill_n(OutputIt first, Size count, <span class="type">const</span> T&amp; value) <span class="comment">//fill_n函数的作用是：给你一个起始点，然后再给你一个数值count和val。把从起始点开始依次赋予count个元素val的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="vector具体实现"><a href="#vector具体实现" class="headerlink" title="vector具体实现"></a>vector具体实现</h3><p>（1）扩容</p>
<p>vector的底层数据结构是数组。</p>
<p>当vector中的可用空间耗尽时，就要动态第扩大内部数组的容量。直接在原有物理空间的基础上追加空间？这不现实。数组特定的地址方式要求，物理空间必须地址连续，而我们无法保证其尾部总是预留了足够空间可供拓展。一种方法是，申请一个容量更大的数组，并将原数组中的成员都搬迁至新空间，再在其后方进行插入操作。新数组的地址由OS分配，与原数据区没有直接的关系。新数组的容量总是取作原数组的两倍。</p>
<p>（2）插入和删除</p>
<p>插入给定值的过程是，先找到要插入的位置，然后将这个位置（包括这个位置）的元素向后整体移动一位，然后将该位置的元素复制为给定值。删除过程则是将该位置以后的所有元素整体前移一位。</p>
<p>（2）vector的size和capacity</p>
<p>size指vector容器当前拥有的元素个数，capacity指容器在必须分配新存储空间之前可以存储的元素总数，capacity总是大于或等于size的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size() – 返回目前存在的元素数。即： 元素个数</span><br><span class="line">capacity() – 返回容器能存储 数据的个数。 即：容器容量</span><br><span class="line">reserve() --设置 capacity 大小</span><br><span class="line">resize() --设置 size ，重新指定有效元素的个数 ，区别与reserve()指定 容量的大小</span><br><span class="line">clear() --清空所有元素，把size设置成0，capacity不变</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.shaojiemike.top/img/20220916145145.png"></p>
<p>针对capacity这个属性，STL中的其他容器，如list map set deque，由于这些容器的内存是散列分布的，因此不会发生类似realloc()的调用情况，因此我们可以认为capacity属性针对这些容器是没有意义的，因此设计时这些容器没有该属性。</p>
<p>在STL中，拥有capacity属性的容器只有vector和string。</p>
<h3 id="为何map和set的插入删除效率比用其他序列容器高？"><a href="#为何map和set的插入删除效率比用其他序列容器高？" class="headerlink" title="为何map和set的插入删除效率比用其他序列容器高？"></a>为何map和set的插入删除效率比用其他序列容器高？</h3><p>因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。map和set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。</p>
<p><strong>插入</strong>的时候只需要稍做变换，把节点的指针指向新的节点就可以了。<strong>删除</strong>的时候类似，稍做变换后把指向删除节点的指针指向其他节点就OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p>
<h3 id="std-map的优势-内存池的管理"><a href="#std-map的优势-内存池的管理" class="headerlink" title="std::map的优势: 内存池的管理"></a>std::map的优势: 内存池的管理</h3><p>自己实现的map需要自己去new一些节点，当节点特别多， 而且进行频繁的删除和插入的时候，内存碎片就会存在，而STL采用自己的Allocator分配内存，以内存池的方式来管理这些内存，会大大减少内存碎片，从而会提升系统的整体性能。</p>
<h3 id="为什么有时unordered-map-性能比map差"><a href="#为什么有时unordered-map-性能比map差" class="headerlink" title="为什么有时unordered_map, 性能比map差"></a>为什么有时unordered_map, 性能比map差</h3><p>注意到很多代码使用 std::unordered_map 因为“哈希表更快”。但是对于小map，具有很高的内存开销。</p>
<p>网上<a target="_blank" rel="noopener" href="https://blog.csdn.net/whizchen/article/details/9286557">有许多map和unorderd_map的比较</a>，但是都是大例子。</p>
<p>下载一个，比较N比较小时的速度。前面是插入，后面是读取时间。编译<code>g++ -std=c++11 -O3 map.cpp -o main</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">insert N=15,cost=               9e-06 sec</span><br><span class="line">[] N=15,cost=                   5e-06 sec</span><br><span class="line">insert N=15,cost=               3e-06 sec</span><br><span class="line">getall find not N=15,cost=      1.2e-05 sec</span><br><span class="line">getall find N=15,cost=          1.4e-05 sec</span><br><span class="line">getall find not N=15,cost=      1e-05 sec</span><br><span class="line">getall cout N=15,cost=          1.3e-05 sec</span><br><span class="line">getall cout not N=15,cost=      1.3e-05 sec</span><br><span class="line"></span><br><span class="line">insert N=15,cost=               6e-06 sec</span><br><span class="line">[] N=15,cost=                   2e-06 sec</span><br><span class="line">insert N=15,cost=               3e-06 sec</span><br><span class="line">getall find not N=15,cost=      1.9e-05 sec</span><br><span class="line">getall find N=15,cost=          2e-05 sec</span><br><span class="line">getall find not N=15,cost=      1.9e-05 sec</span><br><span class="line">getall cout N=15,cost=          3.7e-05 sec</span><br><span class="line">getall cout not N=15,cost=      2e-05 sec</span><br><span class="line"></span><br><span class="line">insert N=15,cost=               3e-06 sec</span><br><span class="line">[] N=15,cost=                   2e-06 sec</span><br><span class="line">insert N=15,cost=               1e-06 sec</span><br><span class="line">getall find not N=15,cost=      2e-05 sec</span><br><span class="line">getall find N=15,cost=          1.8e-05 sec</span><br><span class="line">getall find not N=15,cost=      1.9e-05 sec</span><br><span class="line">getall cout N=15,cost=          1.8e-05 sec</span><br><span class="line">getall cout not N=15,cost=      1.9e-05 sec</span><br><span class="line"></span><br><span class="line">insert N=15,cost=               5e-06 sec</span><br><span class="line">[] N=15,cost=                   1e-06 sec</span><br><span class="line">insert N=15,cost=               2e-06 sec</span><br><span class="line">getall find not N=15,cost=      7e-06 sec</span><br><span class="line">getall find N=15,cost=          8e-06 sec</span><br><span class="line">getall find not N=15,cost=      7e-06 sec</span><br><span class="line">getall cout N=15,cost=          8e-06 sec</span><br><span class="line">getall cout not N=15,cost=      1e-05 sec</span><br></pre></td></tr></table></figure>

<p>可见创建 unorderd_map快于map。</p>
<p>map find没命中会很快，差不多unorderd_map。</p>
<p>但是map命中会慢很多。1.2e-05 &gt;&gt; 2e-06</p>
<h2 id="array-vector与数组的区别"><a href="#array-vector与数组的区别" class="headerlink" title="array,vector与数组的区别"></a>array,vector与数组的区别</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>（1.）都和数组相似，都可以使用标准数组的表示方法来访问每个元素（array和vector都对下标运算符[ ]进行了重载）</p>
<p>（2.）三者的存储都是连续的，可以进行随机访问</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>（0.）数组是不安全的，array和vector是比较安全的（有效的避免越界等问题）</p>
<p>（1.）array对象和数组存储在相同的内存区域（<strong>栈</strong>）中，vector对象存储在自由存储区（<strong>堆</strong>）malloc和new的空间也是在堆上，原因是栈的空间在编译代码的时候就要确定好，堆空间可以运行时分配。</p>
<p>（2.）array可以将一个对象赋值给另一个array对象，但是数组不行</p>
<p>（3.）vector属于变长的容器，即可以根据数据的插入和删除重新构造容器容量；但是array和数组属于定长容器</p>
<p>（4.）vector和array提供了更好的数据访问机制，即可以使用front()和back()以及at()（at()可以避免a[-1]访问越界的问题）访问方式，使得访问更加安全。而数组只能通过下标访问，在写程序中很容易出现越界的错误</p>
<p>（5.）vector和array提供了更好的遍历机制，即有正向迭代器和反向迭代器</p>
<p>（6.）vector和array提供了size()和Empty()，而数组只能通过sizeof()&#x2F;strlen()以及遍历计数来获取大小和是否为空</p>
<p>（7.）vector和array提供了两个容器对象的内容交换，即swap()的机制，而数组对于交换只能通过遍历的方式逐个交换元素</p>
<p>（8.）array提供了初始化所有成员的方法fill（）</p>
<p>（9.）由于vector的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否有效问题</p>
<p>（10.）vector和array在声明变量后，在声明周期完成后，会自动地释放其所占用的内存。对于数组如果用new[ ]&#x2F;malloc申请的空间，必须用对应的delete[ ]和free来释放内存</p>
<h2 id="vector-存储可变大小类型"><a href="#vector-存储可变大小类型" class="headerlink" title="vector 存储可变大小类型"></a>vector 存储可变大小类型</h2><p><img src="https://pic.shaojiemike.top/img/20230702085935.png"></p>
<ul>
<li>vector是变长的连续存储，<ul>
<li>对于简单的类型，是直接存储</li>
<li>对于复杂的类，存储的是，该元素的信息（比如新构造元素的begin地址,end地址,capacity信息)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v2d</span>(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));      <span class="comment">// 间隔 6 个int</span></span><br><span class="line"><span class="comment">// vector&lt;set&lt;int&gt;&gt; v2d(3);                     // 间隔 12 个int </span></span><br><span class="line"><span class="comment">// vector&lt;unordered_set&lt;int&gt;&gt; v2d(3);           // 间隔 14 个int </span></span><br><span class="line"><span class="comment">// vector&lt;map&lt;int,int&gt;&gt; v2d(3);                 // 间隔 12 个int </span></span><br><span class="line"><span class="comment">// vector&lt;unordered_map&lt;int,int&gt;&gt; v2d(3);       // 间隔 14 个int </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> STEP = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;v2d.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;v2d[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;STEP; j++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hex &lt;&lt; *(<span class="type">int</span> *)((<span class="type">void</span> *)(&amp;v2d[i])+j*<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add elements to v2d[0]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ADDNUM = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;ADDNUM; i++)&#123;</span><br><span class="line">    v2d[<span class="number">0</span>].<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// v2d[0].insert(i);</span></span><br><span class="line">    <span class="comment">// v2d[0][i]=i*i;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check the space change</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Ele[0] size : &quot;</span> &lt;&lt; v2d[<span class="number">0</span>].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;v2d.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;v2d[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check ele[0] location</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;ADDNUM; i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;v2d[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>哈希</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;functional&gt; </span><br><span class="line">auto hash_p = [](const pair&lt;int, int&gt; &amp;p) -&gt; size_t &#123;</span><br><span class="line">            static hash&lt;long long&gt; hash_ll;</span><br><span class="line">            return hash_ll(p.first + (static_cast&lt;long long&gt;(p.second) &lt;&lt; 32));//64位高低一半存储x和y</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>static_cast 用于良性<strong>类型转换</strong>，一般不会导致意外发生，风险很低。</p>
<p>hash <code>&lt;K&gt;</code> 模板专用的算法取决于实现，但是如果它们遵循 C++14 标准的话，需要满足一些具体的要求。这些要求如下：</p>
<ul>
<li>不能拋出异常</li>
<li>对于相等的键必须产生相等的哈希值</li>
<li>对于不相等的键产生碰撞的可能性必须最小接近 size_t 最大值的倒数</li>
</ul>
<h2 id="C-11技巧"><a href="#C-11技巧" class="headerlink" title="C++11技巧"></a>C++11技巧</h2><p><a target="_blank" rel="noopener" href="https://shaojiemike.notion.site/C-11-a94be53ca5a94d34b8c6972339e7538a">https://shaojiemike.notion.site/C-11-a94be53ca5a94d34b8c6972339e7538a</a></p>
<h3 id="map-VS-unordered-map-时间比较"><a href="#map-VS-unordered-map-时间比较" class="headerlink" title="map VS unordered_map 时间比较"></a>map VS unordered_map 时间比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">比较map、hash_map和unordered_map的执行效率以及内存占用情况</span><br><span class="line">**/</span><br><span class="line">#include &quot;parallel-hashmap/parallel_hashmap/phmap.h&quot;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt; </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">// #include &lt;ext/hash_map&gt;</span><br><span class="line">#include &lt;tr1/unordered_map&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// using namespace __gnu_cxx;</span><br><span class="line"> </span><br><span class="line">using namespace std::tr1;</span><br><span class="line"> </span><br><span class="line">#define N 15  //分别测试N=100,000、N=1,000,000、N=10,000,000以及N=100,000,000</span><br><span class="line">#define LOOP 50</span><br><span class="line"> </span><br><span class="line">//分别定义MapKey=map&lt;int,int&gt;、hash_map&lt;int,int&gt;、unordered_map&lt;int,int&gt;</span><br><span class="line">typedef map&lt;int,int&gt; MapKey;          //采用map</span><br><span class="line">//typedef hash_map&lt;int,int&gt; MapKey;     //采用hash_map</span><br><span class="line">typedef std::unordered_map&lt;int,int&gt; MapKey1;  //采用unordered_map</span><br><span class="line">typedef tr1::unordered_map&lt;int,int&gt; MapKey2;  //采用unordered_map</span><br><span class="line">typedef phmap::flat_hash_map&lt;int,int&gt; MapKey3;  //采用unordered_map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int GetPidMem(pid_t pid,string&amp; memsize)</span><br><span class="line">&#123;</span><br><span class="line"> char filename[1024];</span><br><span class="line"> </span><br><span class="line"> snprintf(filename,sizeof(filename),&quot;/proc/%d/status&quot;,pid);</span><br><span class="line"> </span><br><span class="line"> ifstream fin;</span><br><span class="line"> </span><br><span class="line"> fin.open(filename,ios::in);</span><br><span class="line"> if (! fin.is_open())</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;&quot;open &quot;&lt;&lt;filename&lt;&lt;&quot; error!&quot;&lt;&lt;endl;</span><br><span class="line">  return (-1);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> char buf[1024];</span><br><span class="line"> char size[100];</span><br><span class="line"> char unit[100];</span><br><span class="line"> </span><br><span class="line"> while(fin.getline(buf,sizeof(buf)-1))</span><br><span class="line"> &#123;</span><br><span class="line">  if (0 != strncmp(buf,&quot;VmRSS:&quot;,6))</span><br><span class="line">   continue;</span><br><span class="line">  </span><br><span class="line">  sscanf(buf+6,&quot;%s%s&quot;,size,unit);</span><br><span class="line">  </span><br><span class="line">  memsize = string(size)+string(unit);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> fin.close();</span><br><span class="line"> </span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void testMap(T MyMap)&#123;</span><br><span class="line"> struct timeval begin;</span><br><span class="line"> </span><br><span class="line"> struct timeval end;</span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"> </span><br><span class="line"> for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">  MyMap.insert(make_pair(i,i));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;insert N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> MyMap.clear();</span><br><span class="line"></span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"> </span><br><span class="line"> for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">  MyMap[i]=i;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;[] N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t\t\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> MyMap.clear();</span><br><span class="line"></span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"> </span><br><span class="line"> for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">  MyMap.insert(make_pair(i,i));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;insert N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"></span><br><span class="line"> for(int t=0; t&lt;LOOP; t++)</span><br><span class="line"> for(int i=N;i&lt;2*N;++i)&#123;</span><br><span class="line">  MyMap.find(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;getall find not N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"></span><br><span class="line"> for(int t=0; t&lt;LOOP; t++)</span><br><span class="line"> for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">  MyMap.find(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;getall find N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"></span><br><span class="line"> for(int t=0; t&lt;LOOP; t++)</span><br><span class="line"> for(int i=N;i&lt;2*N;++i)&#123;</span><br><span class="line">  MyMap.find(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;getall find not N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"></span><br><span class="line"> for(int t=0; t&lt;LOOP; t++)</span><br><span class="line"> for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">  MyMap.count(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;getall cout N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> gettimeofday(&amp;begin,NULL);</span><br><span class="line"></span><br><span class="line"> for(int t=0; t&lt;LOOP; t++)</span><br><span class="line"> for(int i=N;i&lt;2*N;++i)&#123;</span><br><span class="line">  MyMap.count(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> gettimeofday(&amp;end,NULL);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;&quot;getall cout not N=&quot;&lt;&lt;N&lt;&lt;&quot;,cost=\t&quot;&lt;&lt;end.tv_sec-begin.tv_sec + float(end.tv_usec-begin.tv_usec)/1000000&lt;&lt;&quot; sec&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> MapKey map;</span><br><span class="line"> MapKey1 map1;</span><br><span class="line"> MapKey2 map2;</span><br><span class="line"></span><br><span class="line"> MapKey3 map3;</span><br><span class="line"></span><br><span class="line"> testMap&lt;MapKey&gt;(map);</span><br><span class="line"> testMap&lt;MapKey1&gt;(map1);</span><br><span class="line"> testMap&lt;MapKey2&gt;(map2);</span><br><span class="line"> testMap&lt;MapKey3&gt;(map3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> string memsize;</span><br><span class="line"> </span><br><span class="line"> GetPidMem(getpid(),memsize);</span><br><span class="line"> </span><br><span class="line"> cout&lt;&lt;memsize&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p>
<p>【C++容器】数组和vector、array三者区别和联系<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/liangchaoxi/4056308">https://blog.51cto.com/liangchaoxi/4056308</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y601500359/article/details/105297918">https://blog.csdn.net/y601500359/article/details/105297918</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「stitching」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40250056/article/details/114681940">https://blog.csdn.net/qq_40250056/article/details/114681940</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「FishBear_move_on」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/haluoluo211/article/details/80877558">https://blog.csdn.net/haluoluo211/article/details/80877558</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「SOC罗三炮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/luolaihua2018/article/details/109406092">https://blog.csdn.net/luolaihua2018/article/details/109406092</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「鱼思故渊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yusiguyuan/article/details/40950735">https://blog.csdn.net/yusiguyuan/article/details/40950735</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-23T16:00:00.000Z" title="9/23/2023, 4:00:00 PM">2023-09-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.039Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">31 minutes read (About 4674 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/23/Work/HPC/MPI_OMP/MPI/">MPI</a></p><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Message Passing Interface (消息传递接口 MPI) is a standardized and portable message-passing standard designed to function on parallel computing architectures.[1]</li>
<li>The MPI standard defines the syntax 语法 and semantics 语意 of library routines that are useful to a wide range of users writing portable message-passing programs in C, C++, and Fortran.</li>
<li>There are several open-source MPI implementations （MPICH，Open MPI）, which fostered the development of a parallel software industry, and encouraged development of portable and scalable large-scale parallel applications.</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul>
<li>1994.6 MPI-1<ul>
<li>主要的MPI-1模型没有共享内存的概念，</li>
<li>point-to-point send&#x2F;recieve, gather&#x2F;reduce, synchronous, asynchronous,</li>
</ul>
</li>
<li>MPI-2只有一个有限的分布式共享内存的概念。尽管如此，MPI程序通常在共享内存计算机上运行，MPICH和Open MPI都可以使用共享内存进行消息传输（如果可用的话）。</li>
<li>围绕MPI模型（与显式共享内存模型相反）设计程序在NUMA体系结构上运行时具有优势，因为MPI鼓励内存局部性。显式共享内存编程是在MPI-3中引入的。</li>
</ul>
<h3 id="实现原理简介"><a href="#实现原理简介" class="headerlink" title="实现原理简介"></a>实现原理简介</h3><p>虽然MPI属于OSI参考模型的第5层和更高层，但实现可以覆盖大多数层，其中在传输层中使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_socket">套接字</a>和传输控制协议（TCP）。</p>
<h3 id="与RDMA的区别"><a href="#与RDMA的区别" class="headerlink" title="与RDMA的区别"></a>与RDMA的区别</h3><p>MPI hardware research focuses on implementing MPI directly in hardware, for example via processor-in-memory, building MPI operations into the microcircuitry of the RAM chips in each node. By implication, this approach is independent of language, operating system, and CPU, but cannot be readily updated or removed.<br>MPI硬件研究的重点是直接在硬件中实现MPI，例如通过内存处理器，将MPI操作构建到每个节点中的RAM芯片的微电路中。通过暗示，这种方法独立于语言、操作系统和CPU，但是不能容易地更新或删除。</p>
<p>Another approach has been to add hardware acceleration to one or more parts of the operation, including hardware processing of MPI queues and using <strong>RDMA</strong> to directly transfer data between memory and the <strong>network interface controller（NIC 网卡）</strong> without CPU or OS kernel intervention.<br>另一种方法是将硬件加速添加到操作的一个或多个部分，包括MPI队列的硬件处理以及使用RDMA在存储器和网络接口控制器之间直接传输数据，而无需CPU或OS内核干预。</p>
<h3 id="与管道的区别"><a href="#与管道的区别" class="headerlink" title="与管道的区别"></a>与管道的区别</h3><p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93">进程间通信</a>都是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inter-process_communication">Inter-process communication（IPC）</a>的一种。常见有如下几种：</p>
<ol>
<li>文件，进程写文件到磁盘，其余进程能并行读取。<ol>
<li>Memory-mapped file 存储在内存里的文件</li>
</ol>
</li>
<li>signal，多为控制信号</li>
<li>信号量(计数器)</li>
<li>Network Socket</li>
<li>Message queue 消息队列（没用过</li>
<li>管道<ol>
<li>Anonymous pipe 匿名管道（命令行的结果传递<code>|</code><ol>
<li>可用于单向进程间通信（IPC）的单FIFO通信通道</li>
<li>A unidirectional data channel using standard input and output.</li>
</ol>
</li>
<li>named pipe 有名管道<ol>
<li>持久化，<code>mkfifo</code>,具有p的文件属性</li>
<li>cat tail的例子说明，不建立写读连接会阻塞。</li>
</ol>
</li>
</ol>
</li>
<li>Shared memory 共享内存（OpenMP</li>
<li>Message passing 消息传递（类似MPI</li>
</ol>
<h3 id="与OpenMP的关系"><a href="#与OpenMP的关系" class="headerlink" title="与OpenMP的关系"></a>与OpenMP的关系</h3><p>线程共享存储器编程模型（如Pthreads和OpenMP）和消息传递编程（MPI&#x2F;PVM）可以被认为是互补的，并且有时在具有多个大型共享存储器节点的服务器中一起使用。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>后四个是MPI-2独有的</p>
<ol>
<li>Communicator 进程组</li>
<li>Point-to-point basics 点对点同步异步通信</li>
<li>Collective basics 集体通信（eg. alltoall</li>
<li>Derived data types 派生数据类型（自定义传输数据结构</li>
<li>One-sided communication <ol>
<li>MPI-2定义了三个单边通信操作，分别是对远程存储器的<strong>写入</strong>、从远程存储器的<strong>读取</strong>以及跨多个任务对同一存储器的<strong>归约</strong>操作。</li>
</ol>
</li>
<li>Dynamic process management 类似进程池？没用过</li>
<li>并行文件IO</li>
</ol>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="C-查看在哪个节点"><a href="#C-查看在哪个节点" class="headerlink" title="C++ 查看在哪个节点"></a>C++ 查看在哪个节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">char hostname[100];</span><br><span class="line">gethostname(hostname,sizeof(hostname));</span><br><span class="line">printf( &quot;Hello world from process %d of %d: host: %s\n&quot;, rank, size, hostname);</span><br></pre></td></tr></table></figure>
<h2 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h2><p>输出X个当前机器hostname<br><img src="https://pic.shaojiemike.top/img/20210818143208.png"></p>
<p>mpirun -np 6 -machinefile .&#x2F;machinelist .&#x2F;a.out 即可多节点执行。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>MPI_Finalize()之后 ,MPI_Init()之前<br><a target="_blank" rel="noopener" href="https://www.open-mpi.org/doc/v4.0/man3/MPI_Init.3.php">https://www.open-mpi.org/doc/v4.0/man3/MPI_Init.3.php</a></p>
<p>不同的进程是怎么处理串行的部分的？都执行（重复执行？）。执行if(rank&#x3D;num),那岂不是还要同步MPI_Barrier()。</p>
<p>而且写同一个文件怎么办？</p>
<h2 id="对等模式和主从模式"><a href="#对等模式和主从模式" class="headerlink" title="对等模式和主从模式"></a>对等模式和主从模式</h2><p>MPI的两种最基本的并行程序设计模式 即对等模式和主从模式。 </p>
<p>　　对等模式：各个部分地位相同，功能和代码基本一致，只不过是处理的数据或对象不同，也容易用同样的程序来实现。 </p>
<p>　　主从模式：分为主进程和从进程，程序通信进程之间的一种主从或依赖关系 。MPI程序包括两套代码，主进程运行其中一套代码，从进程运行另一套代码。</p>
<h2 id="程序并行可行性分析"><a href="#程序并行可行性分析" class="headerlink" title="程序并行可行性分析"></a>程序并行可行性分析</h2><p><img src="https://pic.shaojiemike.top/img/20220108204219.png"><br>圈收缩(cycle shrinking)－此变换技术一般用于<strong>依赖距离大于1</strong>的循环中，它将一个串行循环分成两个紧嵌套循环，其中外层依然串行执行，而内层则是并行执行（一般粒度较小）</p>
<p><a target="_blank" rel="noopener" href="https://shaojiemike.notion.site/41b9f62c4b054a2bb379316f27da5836">https://shaojiemike.notion.site/41b9f62c4b054a2bb379316f27da5836</a></p>
<h2 id="MPI消息"><a href="#MPI消息" class="headerlink" title="MPI消息"></a>MPI消息</h2><p><img src="https://pic.shaojiemike.top/img/20220107191148.png"></p>
<h3 id="预定义类型消息——特殊MPI-PACKED"><a href="#预定义类型消息——特殊MPI-PACKED" class="headerlink" title="预定义类型消息——特殊MPI_PACKED"></a>预定义类型消息——特殊MPI_PACKED</h3><p>MPI_PACKED预定义数据类型被用来实现传输地址空间不连续的数据项 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Pack(const void *inbuf,</span><br><span class="line">             int incount,</span><br><span class="line">             MPI_Datatype datatype, void *outbuf, int outsize, int *position, MPI_Comm comm)</span><br><span class="line">int MPI_Unpack(const void *inbuf, int insize, int *position,</span><br><span class="line">               void *outbuf, int outcount, MPI_Datatype datatype, MPI_Comm comm)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.shaojiemike.top/img/20220107150149.png"><br>The <strong>input</strong> value of position is the <strong>first</strong> location in the <strong>output</strong> buffer to be used for packing. position is incremented by the size of the packed message, </p>
<p>and the <strong>output</strong> value of position is the first location in the <strong>output</strong> buffer <strong>following the locations occupied by the packed message</strong>. The comm argument is the communicator that will be subsequently used for sending the packed message.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Returns the upper bound on the amount of space needed to pack a message</span><br><span class="line">int MPI_Pack_size(int incount, MPI_Datatype datatype, MPI_Comm comm, int *size)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.shaojiemike.top/img/20220107150622.png"><br>例子：<br><img src="https://pic.shaojiemike.top/img/20220107151318.png"><br>这里的<code>A+i*j</code>应该写成<code>A+i*2</code>吧？？？</p>
<h3 id="派生数据类型-Derived-Data-Type"><a href="#派生数据类型-Derived-Data-Type" class="headerlink" title="派生数据类型(Derived Data Type)"></a>派生数据类型(Derived Data Type)</h3><p>来定义由数据类型不同且地址空间不连续的数据项组成的消息。<br><img src="https://pic.shaojiemike.top/img/20220107151628.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//启用与弃用数据类型</span><br><span class="line">int MPI_Type_commit(MPI_Datatype * datatype)</span><br><span class="line">int MPI_Type_free(MPI_Datatype * datatype)</span><br><span class="line">//相同数据类型</span><br><span class="line">int MPI_Type_contiguous(int count, MPI_Datatype oldtype, MPI_Datatype * newtype)</span><br><span class="line">//成块的相同元素组成的类型，块之间具有相同间隔</span><br><span class="line">int MPI_Type_vector(int count,</span><br><span class="line">                    int blocklength, int stride, MPI_Datatype oldtype, MPI_Datatype * newtype)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.shaojiemike.top/img/20220108172617.png"></p>
<p><img src="https://pic.shaojiemike.top/img/20220107154805.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//成块的相同元素组成的类型，块长度和偏移由参数指定</span><br><span class="line">int MPI_Type_indexed(int count,</span><br><span class="line">                     const int *array_of_blocklengths,</span><br><span class="line">                     const int *array_of_displacements,</span><br><span class="line">                     MPI_Datatype oldtype, MPI_Datatype * newtype)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.shaojiemike.top/img/20220108172552.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//由不同数据类型的元素组成的类型, 块长度和偏移(肯定也不一样)由参数指定</span><br><span class="line">int MPI_Type_struct(int count,</span><br><span class="line">                    int *array_of_blocklengths,</span><br><span class="line">                    MPI_Aint * array_of_displacements,</span><br><span class="line">                    MPI_Datatype * array_of_types, MPI_Datatype * newtype)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.shaojiemike.top/img/20220108172532.png"></p>
<h2 id="通讯域映射为网格表示"><a href="#通讯域映射为网格表示" class="headerlink" title="通讯域映射为网格表示"></a>通讯域映射为网格表示</h2><p>MPI_Cart_create<br>确定了虚拟网络每一维度的大小后，需要为这种拓扑建立通信域。组函数MPI_Cart_create可以完成此任务，其声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Makes a new communicator to which topology拓扑 information has been attached</span><br><span class="line">int MPI_Cart_create(</span><br><span class="line">    MPI_Comm old_comm,//旧的通信域。这个通讯域中的所有进程都要调用该函数</span><br><span class="line">    int dims,//网格维数 number of dimensions of cartesian grid (integer)</span><br><span class="line">    int* size,//长度为dims的数组，size[j]是第j维的进程数, integer array of size ndims specifying the number of processes in each dimension</span><br><span class="line">    int* periodic,//长度为dims的数组，如果第j维有周期性，那么periodic[j]=1，否则为0</span><br><span class="line">    int reorder,//进程是否能重新被编号，如果为0则进程在新的通信域中仍保留在旧通信域的标号</span><br><span class="line">    MPI_Comm* cart_comm//该函数返回后，此变量将指向新的笛卡尔通信域</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">int MPI_Cart_rank(MPI_Comm comm, const int coords[], int *rank)</span><br><span class="line">//Determines process rank in communicator given Cartesian location</span><br><span class="line">//该函数的作用是通过进程在网格中的坐标获得它的进程号</span><br><span class="line"></span><br><span class="line">int MPI_Cart_coords(MPI_Comm comm, int rank, int maxdims, int coords[])</span><br><span class="line">//Determines process coords in cartesian topology given rank in group</span><br><span class="line">//该函数的作用是确定某个线程在虚拟网格中的坐标</span><br></pre></td></tr></table></figure>
<h2 id="通信域划分"><a href="#通信域划分" class="headerlink" title="通信域划分"></a>通信域划分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Comm_create(MPI_Comm comm, MPI_Group group, MPI_Comm * newcomm)</span><br><span class="line">//Creates a new communicator</span><br><span class="line"></span><br><span class="line">int MPI_Comm_split(MPI_Comm comm, int color, int key, MPI_Comm * newcomm)</span><br><span class="line">将某个通信域进一步划分为几组</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.shaojiemike.top/img/20220106204011.png"></p>
<h3 id="组间通信域"><a href="#组间通信域" class="headerlink" title="组间通信域"></a>组间通信域</h3><p><img src="https://pic.shaojiemike.top/img/20220110102453.png"></p>
<h2 id="点对点通信"><a href="#点对点通信" class="headerlink" title="点对点通信"></a>点对点通信</h2><p><img src="https://pic.shaojiemike.top/img/20151123153719314.png"><br><img src="https://pic.shaojiemike.top/img/20220107160344.png"><br>特殊的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Sendrecv(const void *sendbuf, int sendcount, MPI_Datatype sendtype,</span><br><span class="line">                 int dest, int sendtag,</span><br><span class="line">                 void *recvbuf, int recvcount, MPI_Datatype recvtype,</span><br><span class="line">                 int source, int recvtag, MPI_Comm comm, MPI_Status * status)</span><br><span class="line">int MPI_Sendrecv_replace(void *buf, int count, MPI_Datatype datatype,</span><br><span class="line">                         int dest, int sendtag, int source, int recvtag,</span><br><span class="line">                         MPI_Comm comm, MPI_Status * status)</span><br></pre></td></tr></table></figure>
<p>特别适用于在进程链（环）中进行“移位”操作，而避免在通讯为阻塞方式时出现死锁。</p>
<p>There is also another error. The MPI standard requires that the <code>send</code> and the <code>receive</code> buffers be disjoint不相交 (i.e. they should not overlap重叠), which is not the case with your code. Your send and receive buffers not only overlap but they are one and the same buffer. If you want to perform the swap in the same buffer, MPI provides the <code>MPI_Sendrecv_replace</code> operation.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//MPI标准阻塞通信函数,没发出去就不会结束该命令。</span><br><span class="line">MPI_Send(sb, buf_size, MPI_INT, other, 1, MPI_COMM_WORLD);</span><br><span class="line">                /*其中sb为发送缓冲区首地址, </span><br><span class="line">                  buf_size为发送数据量, </span><br><span class="line">                  MPI_INT 为发送数据的类型,</span><br><span class="line">                  other为发送目标进程,(发送给other)</span><br><span class="line">                  1的位置为tag,</span><br><span class="line">                  MPI_COMM_WORLD为通信子*/</span><br><span class="line">MPI_Recv(rb, buf_size, MPI_INT, other, 1, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">                /*与发送类似,从other接收消息,status见下面*/</span><br></pre></td></tr></table></figure>
<h3 id="是否会导致死锁"><a href="#是否会导致死锁" class="headerlink" title="是否会导致死锁"></a>是否会导致死锁</h3><p><img src="https://pic.shaojiemike.top/img/20211006122528.png"></p>
<p>可能大家会想到这会死锁，如下图：<img src="https://pic.shaojiemike.top/img/20211006122608.png"></p>
<p>但是实际情况可能并不会死锁，这<strong>与调用的MPI库的底层实现有关</strong>。</p>
<p><img src="https://pic.shaojiemike.top/img/20220110102737.png"></p>
<p>MPI_Send将阻塞，直到发送方可以重用发送方缓冲区为止。当缓冲区已发送到较低的通信层时，某些实现将返回给调用方。当另一端有匹配的MPI_Recv()时，其他一些将返回到呼叫者。</p>
<p>但是为了避免这种情况，可以<strong>调换Send与Recv的顺序</strong>，或者**使用MPI_Isend()或MPI_Issend()**代替非阻塞发送，从而避免死锁。</p>
<h3 id="梯形积分"><a href="#梯形积分" class="headerlink" title="梯形积分"></a>梯形积分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        梯形积分法，计算y=sin x 在[0,pi]上的积分</span><br><span class="line">        @ trap 梯形积分串行程序</span><br><span class="line">        @total_inte 最终积分结果</span><br><span class="line">        */</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &quot;mpi.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double a = 0.0;</span><br><span class="line">const double b = 3.1415926;</span><br><span class="line">int n = 100;</span><br><span class="line">double h = (b - a) / n;</span><br><span class="line"></span><br><span class="line">double trap(double a, double b, int n, double h)</span><br><span class="line">&#123;</span><br><span class="line">    double*x = new double[n + 1];</span><br><span class="line">    double*f = new double[n + 1];</span><br><span class="line">    double inte = (sin(a) + sin(b)) / 2;</span><br><span class="line">    for (int i = 1; i&lt;n + 1; i++) &#123;</span><br><span class="line">        x[i] = x[i - 1] + h;   /*x_0=a,x_n=b*/</span><br><span class="line">        f[i] = sin(x[i]);</span><br><span class="line">        inte += f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    inte = inte*h;    /* inte=h*[f(a)/2+f(x_1)+...f(x_&#123;n-1&#125;)+f(b)/2]*/</span><br><span class="line">    return inte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int myid, nprocs;</span><br><span class="line">    int local_n;</span><br><span class="line">    double local_a;</span><br><span class="line">    double local_b;</span><br><span class="line">    double total_inte;</span><br><span class="line"></span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);   /* get current process id */</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs); /* get number of processes */</span><br><span class="line"></span><br><span class="line">    local_n = n / nprocs; //任务划分</span><br><span class="line">    local_a = a + myid*local_n*h;</span><br><span class="line">    local_b = local_a + local_n*h;</span><br><span class="line">    double local_inte = trap(local_a, local_b, local_n, h);</span><br><span class="line"></span><br><span class="line">    if (myid != 0) //通信结果</span><br><span class="line">    &#123;</span><br><span class="line">        MPI_Send(&amp;local_inte, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        total_inte = local_inte;</span><br><span class="line">        for (int i = 1; i&lt;nprocs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            MPI_Recv(&amp;local_inte, 1, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">            total_inte += local_inte;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (myid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;integral output is %d&quot;, total_inte);</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Finalize();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="群集通讯"><a href="#群集通讯" class="headerlink" title="群集通讯"></a>群集通讯</h2><p>一个进程组中的<strong>所有进程都参加</strong>的全局通信操作。 </p>
<p>实现三个功能：通信、聚集和同步。 </p>
<ol>
<li>通信功能主要完成组内数据的传输 </li>
<li>聚集功能在通信的基础上对给定的数据完成一定的操作 </li>
<li>同步功能实现组内所有进程在执行进度上取得一致</li>
</ol>
<p><img src="https://pic.shaojiemike.top/img/20220107161601.png"></p>
<h3 id="常见的通讯"><a href="#常见的通讯" class="headerlink" title="常见的通讯"></a>常见的通讯</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将一个进程中得数据发送到所有进程中的广播函数</span><br><span class="line">MPI_Bcast(void* data_p,int count,MPI_Datatype datatype, int scr_process,MPI_Comm comm);</span><br></pre></td></tr></table></figure>
<p>注意data_p在root 或者scr_process进程里是发送缓存也是接收缓存，但是在其余进程里是接收缓存。<br>MPI_Scatter?</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>MPI_Scatter与MPI_Bcast非常相似，都是一对多的通信方式，不同的是后者的0号进程将<strong>相同的信息</strong>发送给所有的进程，而前者则是将<strong>一段array的不同部分</strong>发送给所有的进程，其区别可以用下图概括：<ol>
<li><img src="https://pic.shaojiemike.top/img/broadcastvsscatter.png"></li>
</ol>
</li>
<li>MPI_Gather，作用是从所有的进程中将每个进程的数据集中到根进程中，同样根据进程的编号对array元素排序，<ol>
<li><img src="https://pic.shaojiemike.top/img/gather.png"></li>
<li>接收缓冲由三元组&lt;RecvAddress, RecvCount, RecvDatatype&gt;标识，发送缓冲由三元组&lt;SendAddress, SendCount, SendDatatype&gt;标识，所有非Root进程忽略接收缓冲。</li>
</ol>
</li>
<li>MPI_Allgather 当数据分布在所有的进程中时，MPI_Allgather将所有的数据聚合到每个进程中。<ol>
<li><img src="https://pic.shaojiemike.top/img/allgather.png">  </li>
<li>Allgather操作相当于每个进程都作为ROOT进程执行了一次Gather调用，即每一个进程都按照Gather的方式收集来自所有进程(包括自己)的数据。 </li>
<li>MPI_GATHERV扩展了功能,提供新的参数disp,是一个整数数组，包含存放从每个进程接收的数据相对于recvbuf的偏移地址</li>
</ol>
</li>
<li>MPI_alltoall()<ol>
<li><img src="https://pic.shaojiemike.top/img/20220107162942.png"></li>
<li>等价于每个进程作为Root进程执行了一次MPI_Scatter散播操作。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Allgather(void * sendbuff, int sendcount, MPI_Datatype sendtype, </span><br><span class="line">                  void * recvbuf, int recvcount, MPI_Datatype recvtype, </span><br><span class="line">                  MPI_Comm comm)</span><br><span class="line">int MPI_Allgatherv(void * sendbuff, int sendcount, MPI_Datatype sendtype, </span><br><span class="line">                   void * recvbuf, int * recvcounts, int * displs, </span><br><span class="line">                   MPI_Datatype recvtype, MPI_Comm comm)</span><br></pre></td></tr></table></figure>
<strong>recvcount</strong> gather和allgather是一样的</li>
</ol>
</li>
</ol>
<p>number of elements received from any process (integer)<br><img src="https://pic.shaojiemike.top/img/20220108172744.png"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>通信域中的所有进程必须调用群集通信函数。如果只有通信域中的一部分成员调用了群集通信函数而其它没有调用，则是错误的。</li>
<li>除MPI_Barrier以外，每个群集通信函数使用类似于点对点通信中的标准、阻塞的通信模式。也就是说，一个进程一旦结束了它所参与的群集操作就从群集函数中返回，但是<strong>并不保证</strong>其它进程执行该群集函数已经<strong>完成</strong>。</li>
<li>一个群集通信操作是不是同步操作取决于实现。MPI要求用户负责保证他的代码无论实现是否同步都必须是正确的。 ???与后面矛盾了 mpich官网说明的。</li>
<li>关于同步最后一个要注意的地方是：始终记得每一个你调用的集体通信方法都是同步的。<ol>
<li><a target="_blank" rel="noopener" href="https://mpitutorial.com/tutorials/mpi-broadcast-and-collective-communication/zh_cn/">https://mpitutorial.com/tutorials/mpi-broadcast-and-collective-communication/zh_cn/</a></li>
</ol>
</li>
<li>在MPI-3.0之前MPI中的所有集合操作都是阻塞的,这意味着在返回之后使用传递给它们的所有缓冲区是安全的.特别是,这意味着当其中一个函数返回时,会收到所有数据.(但是,它并不意味着所有数据都已发送!)因此,如果所有缓冲区都已有效,则在集合操作之前&#x2F;之后MPI_Barrier不是必需的(或非常有用).</li>
<li>对用户的建议:为保证程序正确性而依赖于集合操作中同步的副作用是很危险的作法.例如,即便一个特定的实现策略可以提供一个带有同步副作用的广播通信例程, 但标准却不支持它,因此依赖于此副作用的程序将不可移植.从另一方面讲,一个正确的、可移植的程序必须能容忍集合操作可能带来同步这样 一个事实.尽管一个程序可以丝毫不依赖于这种同步的副作用,编程时也必须这样做.这个问题在4.12节中还将进一步讨论(对用户的建议结尾) <a target="_blank" rel="noopener" href="https://scc.ustc.edu.cn/zlsc/cxyy/200910/MPICH/mpi41.htm">https://scc.ustc.edu.cn/zlsc/cxyy/200910/MPICH/mpi41.htm</a></li>
<li>关于不同的进程运行同一句Bcast的效果<ol>
<li>当根节点(在我们的例子是节点0)调用 MPI_Bcast 函数的时候，data 变量里的值会被发送到其他的节点上。当其他的节点调用 MPI_Bcast 的时候，data 变量会被赋值成从根节点接受到的数据。</li>
<li>所以如果有进程无法到达该语句Bcast，同步的性质会导致到达Bcast的命令需要等待。</li>
</ol>
</li>
</ol>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>MPI聚合的功能分三步实现</p>
<ul>
<li>首先是通信的功能，即消息根据要求发送到目标进程，目标进程也已经收到了各自需要的消息；</li>
<li>然后是对消息的处理，即执行计算功能；</li>
<li>最后把处理结果放入指定的接收缓冲区。</li>
</ul>
<p>MPI提供了两种类型的聚合操作: 归约和扫描。 </p>
<h3 id="聚合——归约"><a href="#聚合——归约" class="headerlink" title="聚合——归约"></a>聚合——归约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Reduce(</span><br><span class="line">    void *input_data, /*指向发送消息的内存块的指针 */</span><br><span class="line">    void *output_data, /*指向接收（输出）消息的内存块的指针 */</span><br><span class="line">    int count，/*数据量*/</span><br><span class="line">    MPI_Datatype datatype,/*数据类型*/</span><br><span class="line">    MPI_Op operator,/*规约操作*/</span><br><span class="line">    int dest，/*要接收（输出）消息的进程的进程号*/</span><br><span class="line">    MPI_Comm comm);/*通信器，指定通信范围*/</span><br><span class="line">// operator可以有：求最大值 MPI_MAX 最小值 求累加和 累乘积 逻辑操作  </span><br><span class="line"></span><br><span class="line">// 求和语句</span><br><span class="line">MPI_Reduce(&amp;local_int,&amp;total_int,1,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">//另外有时候需要将得到的结果放入所有的线程中</span><br><span class="line">MPI_Allreduce(void* input_data_p,void*output_data_p, int count,MPI_Datatype datatype,MPI_Op operator, MPI_Comm comm);</span><br><span class="line"></span><br><span class="line">//每一个进程都对排在它前面的进程进行归约操作。</span><br><span class="line">MPI_scan(SendAddress, RecvAddress, Count, Datatype, Op, Comm)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.shaojiemike.top/img/20220107164107.png"><br><img src="https://pic.shaojiemike.top/img/20220107165321.png"><br><img src="https://pic.shaojiemike.top/img/20220107164130.png"></p>
<h3 id="自定义归约操作"><a href="#自定义归约操作" class="headerlink" title="自定义归约操作"></a>自定义归约操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Op_create(MPI_User_function *function, int commute, MPI_Op *op)</span><br><span class="line"></span><br><span class="line">//function    用户自定义的函数(函数)</span><br><span class="line">//commute   如果commute=ture， 则此操作同时也是可交换的。如果commute=false,则此操作不满足交换律。</span><br><span class="line">            else 按进程号升序进行Op操作</span><br><span class="line">//op              自定义归约操作名</span><br><span class="line"></span><br><span class="line">int  MPI_Op_free(MPI_Op *op) //将用户自定义的归约操作撤销， 将op设置成MPI_OP_NULL。</span><br></pre></td></tr></table></figure>
<p>用户自定义函数 function<br><code>typedef void MPI_User_function(void *invec, void *inoutvec, int *len, MPI_Datatype *datatype)</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;*len;i++)  &#123;</span><br><span class="line">    *inoutvec = *invec USER_OP *inoutvec;</span><br><span class="line">    inoutvec++;  invec++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须具备四个参数：</p>
<ol>
<li>invec 和 inoutvec 分别指出将要被归约的数据所在的缓冲区的首地址，</li>
<li>len指出将要归约的元素的个数, datatype 指出归约对象的数据类型</li>
</ol>
<p>也可以认为invec和inoutvec 是函数中长度为len的数组， 归约的结果重写了inoutvec 的值。</p>
<h4 id="梯形积分-MPI-Reduce"><a href="#梯形积分-MPI-Reduce" class="headerlink" title="梯形积分(MPI_Reduce)"></a>梯形积分(MPI_Reduce)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line">@local_inte：send buffer;</span><br><span class="line">@total_inte:receive buffer;</span><br><span class="line">@MPI_SUM:MPI_Op;</span><br><span class="line">@dest=0,rank of the process obtaining the result.</span><br><span class="line">*/ 中间改成这个</span><br><span class="line"></span><br><span class="line">MPI_Reduce(&amp;local_inte, &amp;total_inte, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>除了#include “mpi.h”<ol>
<li><img src="https://pic.shaojiemike.top/img/20210817222713.png"></li>
</ol>
</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>MPI_Group <a target="_blank" rel="noopener" href="https://www.rookiehpc.com/mpi/docs/mpi_group.php">https://www.rookiehpc.com/mpi/docs/mpi_group.php</a></p>
<p>并行IO文件</p>
<p>1997年推出了MPI的最新版本MPI-2</p>
<p>MPI-2加入了许多新特性，主要包括</p>
<ul>
<li>动态进程(Dynamic Process)</li>
<li>远程存储访问(Remote Memory Access)</li>
<li>并行I&#x2F;O访问(Parallel I&#x2F;O Access)<ul>
<li>MPI-1没有对并行文件I&#x2F;O给出任何定义，原因在于并行I&#x2F;O过于复杂，很难找到一个统一的标准。<br>more</li>
</ul>
</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>数据发送和收集<br><img src="https://pic.shaojiemike.top/img/20220110110907.png"><br><img src="https://pic.shaojiemike.top/img/20220110110919.png"></p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/susan_wang1/article/details/50033823">https://blog.csdn.net/susan_wang1/article/details/50033823</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012417189/article/details/25798705">https://blog.csdn.net/u012417189/article/details/25798705</a></p>
<p>是否死锁： <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20448283/deadlock-with-mpi">https://stackoverflow.com/questions/20448283/deadlock-with-mpi</a></p>
<p><a target="_blank" rel="noopener" href="https://mpitutorial.com/tutorials/">https://mpitutorial.com/tutorials/</a></p>
<p><a target="_blank" rel="noopener" href="http://staff.ustc.edu.cn/~qlzheng/pp11/">http://staff.ustc.edu.cn/~qlzheng/pp11/</a> 第5讲写得特别详细</p>
<p><a target="_blank" rel="noopener" href="https://www.mpich.org/static/docs/latest/www3/">https://www.mpich.org/static/docs/latest/www3/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-23T11:25:32.000Z" title="9/23/2023, 11:25:32 AM">2023-09-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.031Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tips/">Tips</a></span><span class="level-item">a minute read (About 214 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/23/OutOfWork/5-VideoEntertainment/5-URLs/">URLs</a></p><div class="content"><p>!!! abstract “导言”</p>
<pre><code>frequently-used out-of-work urls
</code></pre></div><a class="article-more button is-small is-size-7" href="/2023/09/23/OutOfWork/5-VideoEntertainment/5-URLs/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-23T02:58:16.000Z" title="9/23/2023, 2:58:16 AM">2023-09-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.027Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Treasure/">Treasure</a></span><span class="level-item">3 minutes read (About 389 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/23/OutOfWork/1-lifeAndCareer/1-BigDate/">Important Date</a></p><div class="content"><p>!!! abstract “导言”</p>
<pre><code>Summary your life and work in the anniversary to step into a better cycle.
</code></pre></div><a class="article-more button is-small is-size-7" href="/2023/09/23/OutOfWork/1-lifeAndCareer/1-BigDate/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-22T16:00:00.000Z" title="9/22/2023, 4:00:00 PM">2023-09-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.051Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/network/">network</a></span><span class="level-item">15 minutes read (About 2304 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/22/Work/network/vpn/VPN/">VPN</a></p><div class="content"><h2 id="VPN原理"><a href="#VPN原理" class="headerlink" title="VPN原理"></a>VPN原理</h2><p>vpn：英文全称是“Virtual Private Network”，翻译过来就是“虚拟专用网络”。vpn通常拿来做2个事情:</p>
<ul>
<li>一个是可以让世界上任意2台机器进入一个虚拟的局域网中（当然这个局域网的数据通讯是加密的，很安全，用起来和一个家庭局域网没有区别），</li>
<li>一个是可以用来翻墙。</li>
</ul>
<h3 id="VPN与SS的区别"><a href="#VPN与SS的区别" class="headerlink" title="VPN与SS的区别"></a>VPN与SS的区别</h3><ul>
<li>SS全称shadowsocks，SSR全称shadowsocks-R</li>
<li>VPN是为了保证通信的安全性、私密性，不是专门为“科学上网”制定的技术</li>
<li>而SS&#x2F;SSR则是为了转发客户端流量，绕过防火墙的检测，从而达到“科学上网”的真实意图，但是没有保证数据传输的安全性。</li>
<li>vpn比ss更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发。<ul>
<li>这和任何一个代理的实现思路都差不多，应用层并不知道网卡是虚拟的，这样vpn虚拟网卡将以中间人的身份对数据进行加工，从而实现各种神奇的效果。具体来说，vpn是通过编写一套网卡驱动并注册到操作系统实现的虚拟网卡，这样数据只要经过网卡收发就可以进行拦截处理。</li>
</ul>
</li>
</ul>
<p>一句话，vpn在IP层工作，而ss在TCP层工作。</p>
<h3 id="内网访问举例"><a href="#内网访问举例" class="headerlink" title="内网访问举例"></a>内网访问举例</h3><ul>
<li>普通用户无法访问公司内网服务器</li>
<li>开启VPN以后，如果他想打开公司ERP，他的电脑就不再直接连接公司ERP网站，而是去连接VPN服务器，并给VPN服务器发一条指令——“我要访问公司ERP”。<ul>
<li>VPN服务器接到指令后，VPN服务器自己去访问公司ERP，收到公司ERP网页的内容，再把内容回传给员工，这样使用VPN的员工最终就能看到公司ERP网站的内容了。</li>
</ul>
</li>
<li>也就是说，使用VPN时，这个员工的所有网上访问都通过VPN服务器代理完成的。</li>
</ul>
<p><img src="https://pic.shaojiemike.top/PicGo2.jpg"></p>
<h3 id="IP-packet-如何被传输"><a href="#IP-packet-如何被传输" class="headerlink" title="IP packet 如何被传输"></a>IP packet 如何被传输</h3><p>理解 VPN 路由（以及任何网络路由）配置的关键是认识到一个 IP packet 如何被传输，以下描述的是极度简化后的单向传输过程：</p>
<ol>
<li>机器 A (192.168.0.2) 发送了一个目标地址为 172.29.1.4 的 IP packet.</li>
<li>根据本地路由规则，172.29.1.0&#x2F;24 的下一跳是虚拟网卡 tun0, 由 VPN 客户端接管。</li>
<li>VPN 客户端将这个 packet 的来源地址从 192.168.0.2 改为 10.8.0.123, 转发给 VPN 服务端。</li>
<li>VPN 服务端收到 packet. 根据本地路由规则，172.29.1.0&#x2F;24 的下一跳是默认网关 172.29.1.1.</li>
<li>默认网关找到在同一个局域网内的机器 B (172.29.1.4).</li>
</ol>
<h2 id="客户端-内网"><a href="#客户端-内网" class="headerlink" title="客户端 -&gt; 内网"></a>客户端 -&gt; 内网</h2><p>为什么机器 A 的本地路由表里会有 172.29.1.0&#x2F;24 这个网段的路由规则？通常情况下，这是 OpenVPN 服务端推送给客户端，由客户端在建立 VPN 连接时自动添加的。也可以由服务端自定义，比如wireguard</p>
<h2 id="内网-客户端"><a href="#内网-客户端" class="headerlink" title="内网 -&gt; 客户端"></a>内网 -&gt; 客户端</h2><p>这个时候，如果机器 B 想要回复 A（比如发个 ACK），就会出问题，因为 packet 的来源地址还是 10.8.0.123, 而 10.8.0.0&#x2F;24 网段并不属于当前局域网，是 VPN 服务端私有的——机器 B 往 10.8.0.123 发送的 ACK 会在某个位置（比如默认网关）遇到 “host unreachable” 而被丢弃。对于机器 A 来说，表面现象可能是连接超时或 ping 不通。</p>
<p>解决方法是，在 packet 离开 VPN 服务端时，将其「伪装」成来自 172.29.0.3（举例VPN 服务端的局域网地址），这样机器 B 发送的 ACK 就能顺利回到 VPN 服务端，然后发给机器 A. 这就是所谓的 SNAT。</p>
<ul>
<li>SNAT: Source Network Address Translation，是修改网络包源ip地址的。</li>
<li>DNAT: Destination Network Address Translation,是修改网络包目的ip地址的。</li>
</ul>
<p>在 Linux 系统中由 iptables 来管理，具体命令是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE.</span><br></pre></td></tr></table></figure>

<h2 id="客户端-另一个客户端的内网"><a href="#客户端-另一个客户端的内网" class="headerlink" title="客户端 -&gt; 另一个客户端的内网"></a>客户端 -&gt; 另一个客户端的内网</h2><p>连接 OpenVPN 的两个 client 之间可以互相通信，这是因为服务端推送的路由里包含了对应的网段。但是想从 Client A 到达 Client B 所在局域网的其他机器，还需要额外的配置。因为 OpenVPN 服务端缺少 Client B 局域网相关的路由规则。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server.conf</span></span><br><span class="line">push &quot;route 172.29.0.0 255.255.0.0&quot; # client -&gt; Client B 给客户端推送 172.29.0.0/16 网段的路由(即这个网段的IP的信息都经过VPN)</span><br><span class="line"></span><br><span class="line">route 172.29.0.0 255.255.0.0 #在 OpenVPN Server 上添加 172.29.0.0/16 网段的路由，具体下一跳是哪里，由 client-config 里的 iroute 指定</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 client-config, 目录里的文件名对应 client.crt 的 Common Name</span></span><br><span class="line">client-config-dir /etc/openvpn/ccd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/openvpn/ccd/client-b</span></span><br><span class="line">iroute 172.29.0.0 255.255.0.0 # 告诉 OpenVPN Server, 172.29.0.0/16 的下一跳应该是 client-b (根据名字来)</span><br></pre></td></tr></table></figure>

<h2 id="内网与内网互访"><a href="#内网与内网互访" class="headerlink" title="内网与内网互访"></a>内网与内网互访</h2><p>在前两节所给的配置基础上，只需要再加一点配置，就能实现 OpenVPN 服务端所在局域网与客户端所在局域网的互访。配置内容是，在各自局域网的默认网关上添加路由，将对方局域网网段的下一跳设为 OpenVPN 服务端 &#x2F; 客户端所在机器，同时用 iptables 配置相应的 SNAT 规则。</p>
<h2 id="机场购买链接推荐"><a href="#机场购买链接推荐" class="headerlink" title="机场购买链接推荐"></a>机场购买链接推荐</h2><p>Based on the info in <a target="_blank" rel="noopener" href="https://clashios.com/">clashio</a>, we select some cheap vpns to try.</p>
<!-- <div class="annotate" markdown> -->
<table>
<thead>
<tr>
<th>name</th>
<th>每月价格(￥&#x2F;GB&#x2F;off on holiday)</th>
<th>每月单价(GB&#x2F;￥)</th>
<th>每年单价(GB&#x2F;￥)</th>
<th>节点数与稳定性</th>
<th>使用速度感觉</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://v02.fl-aff.com/auth/register?code=rotu">fastlink 2019</a></td>
<td>20&#x2F;100&#x2F;-30%</td>
<td>5</td>
<td></td>
<td>100+, 节点速度高达5Gbps</td>
<td>峰值 5Gbps (1)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://webcf0120231018.lmspeedapp.com/">totoro 2023</a></td>
<td>15&#x2F;100&#x2F;-20%(2)</td>
<td>6.6</td>
<td></td>
<td>???</td>
<td>???</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://b.msclm.net/#/register?code=AAUF1Efg">冲浪猫 2022</a></td>
<td>16&#x2F;200&#x2F;-12%(3)</td>
<td>12.5</td>
<td></td>
<td>???</td>
<td>峰值 1Gbps</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.v2ny.top/#/register?code=gL7mHyh9">奈云机场 2021</a></td>
<td>10.6&#x2F;168&#x2F;-30%(4)</td>
<td>15.8</td>
<td></td>
<td>230624购买，240109几天全面掉线</td>
<td>峰值 5Gbps (6)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://dug4i1ug26axm.cloudfront.net/">Tomato Cloud 2018</a></td>
<td>4.4&#x2F;98&#x2F;-11%(5)</td>
<td>22.3</td>
<td></td>
<td>???</td>
<td>峰值 0.1 Gbps</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://fccfweb20231204.fatcatcf.com/#/register?code=5HTLQUUE">FatCat 2023</a></td>
<td>6&#x2F;60&#x2F;-20%</td>
<td>10</td>
<td></td>
<td>???</td>
<td>峰值 xx Gbps</td>
</tr>
</tbody></table>
<!-- </div> -->

<p>!!! info “detail info in table”</p>
<pre><code>1. up to 6MB/s off-peak period 
2. 年付8折 + 优惠码8折 $15*12*0.8*0.8=115.2$
3. 年付 `150￥*0.88`
4. 年付+优惠码 128*0.7 = 89.6￥
5. 年费+优惠码 128G每月，：46.99￥/128G or 76.36￥/256G。单价最低时间最短买法：256G,按季度买
6. 新注册用户运行一周内测试5GB:  up to 6MB/s in real download 
</code></pre>
<p>!!! question annotate “My Choice: 单价，大小，速度，优惠码有效期”</p>
<pre><code>1. 优惠码(春节 中秋 双十一)
1. [fastlink](https://v02.fl-aff.com/auth/register?code=rotu) 用了两年了，还是x3很快的。但是相当于一个月只有30GB, 不够用。
2. Tomato Cloud 最便宜。但是0.1Gbps 太慢了。最多是备用
3. [奈云机场](https://www.v2ny.top/#/register?code=gL7mHyh9)(可靠性暂时不行)，[冲浪猫](https://b.msclm.net/#/register?code=AAUF1Efg) 平衡比较好。

现在组合：奈云机场(2) + fastlink。 等fastlink过期了(1)，看要不要转成 冲浪猫。
</code></pre>
<ol>
<li>240624</li>
<li>241105 配置：复制订阅，订阅地址后面加 <code>&amp;flag=clash</code>下载<code>config.yaml</code></li>
</ol>
<p>??? failure “slow and expensive I had try”</p>
<pre><code>Nyacloud 喵云：只有10个节点 `8￥/40GB/0.03Gbps` or `17￥/128GB/0.2Gbps` 平均 `5GB/￥`
</code></pre>
<p>??? note “BGP: Border Gateway Protocol”</p>
<pre><code>边界网关协议（Border Gateway Protocol，BGP）就是互联网的邮政服务。当有人把一封信投进邮筒时，邮政服务就会处理这封邮件，并选择一条快速、高效的路线将这封信投递给收件人。同样地，当有人通过互联网提交数据时，BGP 负责寻找数据能传播的所有可用路径，并选择最佳的路由，这通常意味着在自治系统之间跳跃。[^1]

BGP不仅能够解决速度问题，还可以解决绕过线路故障: ![](https://pic.shaojiemike.top/shaojiemike/2023/11/a3082cc64736ee0f1df57b30ba0be919.png)
</code></pre>
<p>??? note “IPLC: International Private Leased Circuit”</p>
<pre><code>中文翻译是国际私用出租线路，是指用户专用的跨国的数据、话音等综合信息业务的通信线路。通俗地说，也就是指传统的跨境专线。

延迟更低40ms、速度更快, 但是价格贵1 元 / GB。
</code></pre>
<p>??? note “Anycast”</p>
<pre><code>Anycast 是一种网络寻址和路由方法，可以将传入请求路由到各种不同的位置或“节点”。在 CDN 的上下文中，Anycast 通常会将传入的流量路由到距离最近并且能够有效处理请求的数据中心。选择性路由使 Anycast 网络能够应对高流量、网络拥塞和 DDoS 攻击。
</code></pre>
<h3 id="SJF-稳定翻墙VPS"><a href="#SJF-稳定翻墙VPS" class="headerlink" title="SJF 稳定翻墙VPS"></a>SJF 稳定翻墙VPS</h3><p><a target="_blank" rel="noopener" href="https://github.com/txthinking/brook">brook vpn</a>+ <a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/lightsail/?nc1=h_ls">Amazon American node</a></p>
<h2 id="各种设备翻墙"><a href="#各种设备翻墙" class="headerlink" title="各种设备翻墙"></a>各种设备翻墙</h2><p><a target="_blank" rel="noopener" href="https://github.com/bannedbook/fanqiang">教程</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://limbo.moe/posts/2018/openvpn-routes">OpenVPN 路由详解</a></p>
<p>[^1]: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25433049">BGP 漫谈</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-20T16:00:00.000Z" title="9/20/2023, 4:00:00 PM">2023-09-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.043Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a></span><span class="level-item">4 minutes read (About 536 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/20/Work/Programming/2-languageGrammar/java/">Java</a></p><div class="content"><h2 id="java运行的特点"><a href="#java运行的特点" class="headerlink" title="java运行的特点"></a>java运行的特点</h2><p><img src="https://pic.shaojiemike.top/img/20220208205057.png"></p>
<h3 id="JVM-java虚拟机"><a href="#JVM-java虚拟机" class="headerlink" title="JVM(java虚拟机)"></a>JVM(java虚拟机)</h3><p><img src="https://pic.shaojiemike.top/img/20220208205338.png"></p>
<h2 id="Just-In-Time-JIT-编译器"><a href="#Just-In-Time-JIT-编译器" class="headerlink" title="Just-In-Time (JIT) 编译器"></a>Just-In-Time (JIT) 编译器</h2><p><img src="https://pic.shaojiemike.top/img/20220208205801.png"></p>
<ul>
<li>JIT编译器是一种动态编译技术，它将程序的一部分或者全部源代码或更常见的字节码在运行时编译成机器码，然后将编译后的代码替换原来的代码。<ul>
<li>字节码（英语：Bytecode）通常指的是已经经过编译，但<strong>与特定机器代码无关</strong>，需要解释器转译后才能成为机器代码的中间代码(多为虚拟机代码)。典型应用为Java虚拟机里的Java bytecode。</li>
</ul>
</li>
<li><strong>主要优点</strong>是可以在运行时根据程序的运行情况进行优化，从而提高程序的执行效率。<ul>
<li>字节码编译是跨平台的，便于移植的。</li>
</ul>
</li>
<li><strong>主要缺点</strong>是编译字节码导致的延迟和空间开销较大，因此只有在程序运行时间较长的情况下才能体现出优势。</li>
<li>是提前编译（AOT）和字节码解释器(python的实现)的结合体，它的执行效率介于两者之间。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><strong>Java Virtual Machine (JVM)</strong> is an abstract computing machine.</li>
<li><strong>Java Runtime Environment (JRE)</strong> is an implementation of the JVM.</li>
<li><strong>Java Development Kit (JDK)</strong> contains JRE along with various development tools like Java libraries, Java source compilers, Java debuggers, bundling and deployment tools.<ol>
<li><strong>Java SE</strong>: Java™ Platform Standard Edition 21 Development Kit - JDK™ 21</li>
</ol>
</li>
<li><strong>Just In Time compiler (JIT)</strong> is runs after the program has started executing, on the fly. It has access to runtime information and makes optimizations of the code for better performance.<br><img src="https://pic.shaojiemike.top/img/20220208210826.png"></li>
</ol>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><h3 id="Intall-for-topcoder"><a href="#Intall-for-topcoder" class="headerlink" title="Intall for topcoder"></a>Intall for topcoder</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/JunLeon/article/details/122623465">chinese ref</a></p>
<ol>
<li>download from <a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/#java21">website</a><ol>
<li>But the first download choice <code>java 21 SDK</code> seems not contain Java Control Panel (<code>javacpl.exe</code>), you need to install <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/74960831/i-cant-find-the-java-control-panel-on-windows-11">Java SE Development Kit 8u381</a> which include <code>JDK 1.8</code> and <code>JRE 1.8</code></li>
</ol>
</li>
<li>config Java Control Panel, add <code>https://www.topcoder.com</code> to allowed website (Attention: <strong>https</strong>)</li>
<li>open <code>ContestAppletProd.jnlp</code></li>
<li>need <code>127.0.0.1</code> proxy and <code>HTTP TUNE 1</code> to connect to server</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div id='refer-anchor'></div>
无

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-19T12:57:49.000Z" title="9/19/2023, 12:57:49 PM">2023-09-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.027Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">2 minutes read (About 341 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/19/OutOfWork/4-devices/4-DiskC/">Disk C: make room for installation </a></p><div class="content"><h2 id="🏗施工中🏗"><a href="#🏗施工中🏗" class="headerlink" title="🏗施工中🏗"></a>🏗施工中🏗</h2><p>🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧</p>
<p>觉得有意义写，先占个位子。还没写好呢，建议不要看（逻辑内容都没想清楚），不要急~~</p>
<p>🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧🚧</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p><img src="https://pic.shaojiemike.top/img/20230919210159.png"></p>
<p>100GB tiny disk space is occupied half space by <code>Users/Administrator/AppData/local</code> and <code>Users/Administrator/Roaming</code>.</p>
<h2 id="What-happend-if-I-remove"><a href="#What-happend-if-I-remove" class="headerlink" title="What happend if I remove"></a>What happend if I remove</h2><h3 id="AppData"><a href="#AppData" class="headerlink" title="AppData"></a>AppData</h3><p>If you delete the AppData folder, you will reset all related settings and information of your programs and applications. Browsers, for example, will erase your user profile data and settings, while games will erase all your gaming data and settings.</p>
<h2 id="How-to-correct-make-room"><a href="#How-to-correct-make-room" class="headerlink" title="How to correct make room"></a>How to correct make room</h2><p>found out the space-cosuming application, Unload it will auto remove the files under <code>AppData</code> directory.</p>
<h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><ol>
<li>SpaceSniffer        ： <a target="_blank" rel="noopener" href="https://www.fosshub.com/SpaceSniffer.html">https://www.fosshub.com/SpaceSniffer.html</a></li>
<li>磁盘空间</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>C盘没空间了！！！</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>上面回答部分<strong>来自ChatGPT-3.5</strong>，没有进行正确性的交叉校验。</p>
<div id='refer-anchor'></div>

<p>无</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-18T08:13:20.000Z" title="9/18/2023, 8:13:20 AM">2023-09-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.027Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">2 minutes read (About 344 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/18/OutOfWork/4-devices/4-Keyboard/">Keyboard</a></p><div class="content"><p>It’s a fucking crazy thing when you reuse a Bluetooth device, because forget how to make pair.</p>
<h2 id="logitech-K780"><a href="#logitech-K780" class="headerlink" title="logitech K780"></a>logitech K780</h2><p>My <a target="_blank" rel="noopener" href="https://www.logitech.com/content/dam/logitech/en/support/qsg/k780-wireless-keyboard/k780-online-setup-guide.pdf">keyboard</a> encounter Poor contact of keyboard keys, esepeacially the <code>ctrl</code></p>
<h3 id="change-Win-Mac-IOS-configurations"><a href="#change-Win-Mac-IOS-configurations" class="headerlink" title="change Win&#x2F;Mac&#x2F;IOS configurations"></a>change Win&#x2F;Mac&#x2F;IOS configurations</h3><p>iOS fn + i</p>
<p>Mac OS X fn + o</p>
<p>Windows fn + p</p>
<h2 id="LEOPOLO-FC980M"><a href="#LEOPOLO-FC980M" class="headerlink" title="LEOPOLO FC980M"></a>LEOPOLO FC980M</h2><h3 id="Bluetooth-pair"><a href="#Bluetooth-pair" class="headerlink" title="Bluetooth pair"></a>Bluetooth pair</h3><p>Read more: <a target="_blank" rel="noopener" href="https://manuals.plus/leopold/fc900rbt-bluetooth-keyboard-manual#axzz8DeHGvKrh">official ref</a> and <a target="_blank" rel="noopener" href="https://mechanicalkeyboards.com/manuals/FC980M_English_Manual_final.pdf">ref_photo</a></p>
<p>It seems that just</p>
<ol>
<li>Open the battery cover</li>
<li>insert AAA battery and Set the power switch to the ON position.</li>
</ol>
<p>you can Turn on the Bluetooth.</p>
<h3 id="Answer-from-TAOBAO"><a href="#Answer-from-TAOBAO" class="headerlink" title="Answer from TAOBAO"></a>Answer from TAOBAO</h3><p>连接蓝牙方法：（我们键盘没有送蓝牙适配器）需要您电脑有蓝牙功能，</p>
<ol>
<li>第一步背后大开关打到on，</li>
<li>第二步用取卡针捅一下大开关下面的孔、进入配对环节，</li>
<li>第三步打开电脑蓝牙搜蓝牙键盘的型号按提示连接就行。<a target="_blank" rel="noopener" href="https://www.douyin.com/user/MS4wLjABAAAABN0RBdKkCrBXYDkz0MDAY5vkBxHbvbNjyQxEvaYjeek?modal_id=7089373098079816972&showTab=post">参考</a></li>
</ol>
<p>Windows weird option <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/60592245">输入 FC980MBT 的PIN</a>，也可以选择关闭，尤其是鼠标也需要输入时：</p>
<ol>
<li>type <code>00000</code> using original keyboard，click confirm.</li>
<li>type <code>00000</code> using new keyboard, enter.</li>
</ol>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>上面回答部分<strong>来自ChatGPT-3.5</strong>，没有进行正确性的交叉校验。</p>
<div id='refer-anchor'></div>

<p>无</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-17T16:00:00.000Z" title="9/17/2023, 4:00:00 PM">2023-09-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.043Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">17 minutes read (About 2549 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/17/Work/Programming/2-languageGrammar/latex/">Latex</a></p><div class="content"><p><a target="_blank" rel="noopener" href="http://mohu.org/info/symbols/symbols.htm">http://mohu.org/info/symbols/symbols.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dingdangsunny/p/12312966.html">https://www.cnblogs.com/dingdangsunny/p/12312966.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/garfielder007/article/details/51646604">https://blog.csdn.net/garfielder007/article/details/51646604</a></p>
<h2 id="常见设置"><a href="#常见设置" class="headerlink" title="常见设置"></a>常见设置</h2><h3 id="AOE-提交时间"><a href="#AOE-提交时间" class="headerlink" title="AOE 提交时间"></a>AOE 提交时间</h3><p><a target="_blank" rel="noopener" href="https://time.is/zh/Anywhere_on_Earth">始终 比中国慢 20 小时</a></p>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 宏定义</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\jiang</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>&#123;green&#125;&#123;Jiang: <span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\diff</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>&#123;red&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Author-Equal-contribution"><a href="#Author-Equal-contribution" class="headerlink" title="Author Equal contribution"></a>Author Equal contribution</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\IEEEauthorblockN</span>&#123;Qingcai Jiang<span class="built_in">$</span><span class="built_in">^</span>*<span class="built_in">$</span><span class="keyword">\IEEEauthorrefmark</span>&#123;2&#125;, Shaojie Tan<span class="built_in">$</span><span class="built_in">^</span>*<span class="built_in">$</span><span class="keyword">\IEEEauthorrefmark</span>&#123;2&#125;, Junshi Chen<span class="keyword">\IEEEauthorrefmark</span>&#123;3&#125; and Hong An<span class="keyword">\IEEEauthorrefmark</span>&#123;3&#125;&#125;</span><br><span class="line"><span class="keyword">\IEEEauthorblockA</span>&#123;<span class="keyword">\IEEEauthorrefmark</span>&#123;2&#125;<span class="keyword">\IEEEauthorrefmark</span>&#123;3&#125;School of Computer Science and Technology, University of Science and Technology of China, Hefei, China <span class="keyword">\\</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">% \IEEEauthorblockA&#123;\IEEEauthorrefmark&#123;3&#125;Hefei National Laboratory for Physical Sciences at the Microscale, Department of Chemical Physics,\\</span></span><br><span class="line"><span class="comment">% and Synergetic Innovation Center of Quantum Information and Quantum Physics,\\</span></span><br><span class="line"><span class="comment">% University of Science and Technology of China, Hefei, China \\</span></span><br><span class="line"><span class="comment">% &#125;</span></span><br><span class="line"><span class="keyword">\IEEEauthorblockA</span>&#123;Email: <span class="keyword">\IEEEauthorrefmark</span>&#123;2&#125;<span class="keyword">\&#123;</span>jqc, shaojiemike<span class="keyword">\&#125;</span>@mail.ustc.edu.cn, </span><br><span class="line"><span class="keyword">\IEEEauthorrefmark</span>&#123;3&#125;<span class="keyword">\&#123;</span>cjuns, han<span class="keyword">\&#125;</span>@ustc.edu.cn&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line"><span class="comment">% These authors contributed equally to this work.</span></span><br><span class="line"><span class="keyword">\def</span><span class="keyword">\thefootnote</span>&#123;*&#125;<span class="keyword">\footnotetext</span>&#123;Equal contribution. Listing order is random.&#125;<span class="keyword">\def</span><span class="keyword">\thefootnote</span>&#123;<span class="keyword">\arabic</span>&#123;footnote&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>[^1]</p>
<h2 id="颜色-color"><a href="#颜色-color" class="headerlink" title="颜色 color"></a>颜色 color</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64524179">好看的颜色</a></p>
<p><code>magenta</code> and <code>violet</code> and <code>purple</code> and <code>orange</code></p>
<h2 id="字体-font"><a href="#字体-font" class="headerlink" title="字体 font"></a>字体 font</h2><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><ul>
<li>\textbf{ <strong>加粗</strong> }</li>
<li>斜体\emph{斜体}</li>
<li>下划线\underline{下划线}</li>
</ul>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>\fontsize{字体尺寸}{行间距}\selectfont</p>
<ul>
<li>字体尺寸是0.5pt的倍数，向上取0.5倍数。</li>
<li>行间距一般为字体大小的1.2~1.5倍或者使用\baselineskip</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="有序无序list"><a href="#有序无序list" class="headerlink" title="有序无序list"></a>有序无序list</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/z_feng12489/article/details/90600970">https://blog.csdn.net/z_feng12489/article/details/90600970</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/miracle_fans/article/details/78255223">https://blog.csdn.net/miracle_fans/article/details/78255223</a></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">    <span class="keyword">\item</span> 有序</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">    <span class="keyword">\item</span> 无序</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;lstlisting&#125;[caption=&#123;xxx&#125;,language=HTML,label=&#123;lst:fsub&#125;,style=&#123;mystyle&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;lstlisting&#125;</span><br></pre></td></tr></table></figure>

<p>及其格式设置</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\definecolor</span>&#123;codegreen&#125;&#123;rgb&#125;&#123;0,0.6,0&#125;</span><br><span class="line"><span class="keyword">\definecolor</span>&#123;codegray&#125;&#123;rgb&#125;&#123;0.5,0.5,0.5&#125;</span><br><span class="line"><span class="keyword">\definecolor</span>&#123;codepurple&#125;&#123;rgb&#125;&#123;0.58,0,0.82&#125;</span><br><span class="line"><span class="keyword">\definecolor</span>&#123;backcolour&#125;&#123;rgb&#125;&#123;0.95,0.95,0.92&#125;</span><br><span class="line"><span class="keyword">\lstdefinestyle</span>&#123;mystyle&#125;&#123;</span><br><span class="line">    backgroundcolor=<span class="keyword">\color</span>&#123;backcolour&#125;,   </span><br><span class="line">    <span class="comment">% basicstyle=\ttfamily\footnotesize,</span></span><br><span class="line">    basicstyle=<span class="keyword">\fontsize</span>&#123;7&#125;&#123;8.4&#125;<span class="keyword">\selectfont</span><span class="keyword">\ttfamily</span>,</span><br><span class="line">    commentstyle=<span class="keyword">\color</span>&#123;codegreen&#125;,</span><br><span class="line">    stringstyle=<span class="keyword">\color</span>&#123;codepurple&#125;,</span><br><span class="line">    keywordstyle=<span class="keyword">\color</span>&#123;red&#125;, <span class="comment">%根据语言的选择有不同的关键字</span></span><br><span class="line">    <span class="comment">% identifierstyle=\color&#123;red&#125;, %根据语言的选择有不同的标识符 def hello(): # def是关键字，hello是标识符 又如：print(&quot;Hello, world!&quot;) # print是函数名，也是标识符</span></span><br><span class="line"></span><br><span class="line">    numbers=left, <span class="comment">%在左侧显示行数</span></span><br><span class="line">    numbers=right <span class="comment">%在右侧显示行数</span></span><br><span class="line">    numbers=none, <span class="comment">%去掉行数显示</span></span><br><span class="line">    numberstyle=<span class="keyword">\tiny</span><span class="keyword">\color</span>&#123;codegray&#125;, <span class="comment">%行号</span></span><br><span class="line">    stepnumber=2, <span class="comment">%每两行标号一次</span></span><br><span class="line">    numbersep=5pt, <span class="comment">%行号与代码的距离</span></span><br><span class="line"></span><br><span class="line">    breakatwhitespace=false,         <span class="comment">%是否只在空白处换行。空白包括空格、制表符等。如果你设置breakatwhitespace为false，那么代码列表中的过长的行会在任何字符处换行。</span></span><br><span class="line">    breaklines=true,                 <span class="comment">% 允许过长换行</span></span><br><span class="line"></span><br><span class="line">    captionpos=b,                   <span class="comment">%设置代码列表的标题位置。你可以设置captionpos为t或b，分别表示标题在代码列表的上方或下方。</span></span><br><span class="line"></span><br><span class="line">    keepspaces=true,                   <span class="comment">%保留空格。如果你设置keepspaces为true，那么代码列表中的空格会按照原样显示，而不会被忽略或压缩。</span></span><br><span class="line">    showspaces=false,                </span><br><span class="line">    showstringspaces=false, <span class="comment">%去掉空格时产生的下划的空格标志, 设置为true则出现</span></span><br><span class="line">    showtabs=false,                  </span><br><span class="line">    tabsize=2 <span class="comment">%此时一个tab键=2个空格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\lstset</span>&#123;style=mystyle&#125;</span><br></pre></td></tr></table></figure>

<p>可选字体style</p>
<ul>
<li>\tt, %使用teletype字体（一种等宽字体）</li>
<li>\it, %使用罗马斜体</li>
<li>\bfseries, %不改变当前字体的族与形状，但转变成bold加粗序列</li>
<li>\mdseries, %不改变当前字体的族与形状，但转变成中等粗细medium序列</li>
<li>\underbar, %添加下划线</li>
</ul>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[H]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=10cm]&#123;images/image1.png&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;用户兴趣统计图&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig:my<span class="built_in">_</span>label1&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>

<p>这是下面是两栏只占一栏，如果要横框两栏，<code>figure后加*</code></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\def</span><span class="keyword">\hheatmap</span>&#123;0.245&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]   <span class="comment">%设置图片的位置优先级 h（here）图片优先放在代码位置。t（top）b(bottom) p(page) 新开一页。</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">\centering</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">\centerline</span>&#123;<span class="keyword">\includegraphics</span>[width=<span class="keyword">\hheatmap</span><span class="keyword">\linewidth</span>,scale=1.00]&#123;tight.png&#125;&#125;</span><br><span class="line">    <span class="comment">% 或者如下</span></span><br><span class="line">    <span class="keyword">\centerline</span>&#123;<span class="keyword">\includegraphics</span>[width=0.6<span class="keyword">\linewidth</span>]&#123;figures/ooo<span class="built_in">_</span>port.jpg&#125;&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">%[]里面的参数自己可根据需要调整</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">\caption</span>&#123;Please write what you want.&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">\label</span>&#123;FigureOne&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用标题"><a href="#引用标题" class="headerlink" title="引用标题"></a>引用标题</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;Me, myself and I&#125;</span><br><span class="line"><span class="keyword">\label</span>&#123;intro&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\nameref</span>&#123;intro&#125;.</span><br><span class="line"><span class="keyword">\ref</span>&#123;intro&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[colorlinks,linkcolor=blue]&#123;hyperref&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\href</span>&#123;<span class="link">http://v.youku.com/</span>&#125;&#123;Youku video&#125; </span><br></pre></td></tr></table></figure>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;ccc&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">SYMBOL <span class="built_in">&amp;</span> DESCRIPTION<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">U = <span class="keyword">\&#123;</span><span class="built_in">$</span>u<span class="built_in">_</span>i<span class="built_in">$</span><span class="keyword">\&#125;</span> <span class="built_in">&amp;</span>the set of users<span class="keyword">\\</span></span><br><span class="line">G = <span class="keyword">\&#123;</span><span class="built_in">$</span>g<span class="built_in">_</span>k<span class="built_in">$</span><span class="keyword">\&#125;</span> <span class="built_in">&amp;</span>the set of groups<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/winycg/article/details/82633513">三线表</a></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[htbp]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\caption</span>&#123;Source applications of benchmark basic blocks&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;tabular&#125;&#123;ccc&#125;</span><br><span class="line">        <span class="keyword">\toprule</span></span><br><span class="line">        Application <span class="built_in">&amp;</span> Domain <span class="built_in">&amp;</span> <span class="keyword">\#</span> Basic Blocks <span class="keyword">\\</span> </span><br><span class="line">        <span class="keyword">\midrule</span></span><br><span class="line">        Clang <span class="built_in">&amp;</span> Compiler <span class="built_in">&amp;</span> 60000 <span class="keyword">\\</span></span><br><span class="line">        <span class="keyword">\bottomrule</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig:BBtable&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/d5224/article/details/83720899">短横线</a>或者<a target="_blank" rel="noopener" href="https://www.codeleading.com/article/16315399019/">这个</a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line"> <span class="comment">%\textsl&#123;&#125;\setstretch&#123;1.8&#125;</span></span><br><span class="line"> <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\algorithmicrequire</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;Input:&#125;&#125;</span><br><span class="line"> <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\algorithmicensure</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;Output:&#125;&#125;</span><br><span class="line"> <span class="keyword">\caption</span>&#123;Iterative Solution for Training Stage&#125;</span><br><span class="line"> <span class="keyword">\label</span>&#123;alg1&#125;</span><br><span class="line"> <span class="keyword">\begin</span>&#123;algorithmic&#125;[1]</span><br><span class="line">     <span class="keyword">\REQUIRE</span> target user group <span class="built_in">$</span><span class="keyword">\mathbf</span>&#123;U&#125;=<span class="keyword">\left</span><span class="keyword">\&#123;</span>u<span class="built_in">_</span>&#123;i&#125;<span class="keyword">\right</span><span class="keyword">\&#125;</span><span class="built_in">$</span>, group set <span class="built_in">$</span><span class="keyword">\mathbf</span>&#123;G&#125;=<span class="keyword">\left</span><span class="keyword">\&#123;</span>g<span class="built_in">_</span>&#123;k&#125;<span class="keyword">\right</span><span class="keyword">\&#125;</span><span class="built_in">$</span> and attendance records <span class="built_in">$</span><span class="keyword">\left</span><span class="keyword">\&#123;</span>s<span class="built_in">_</span>&#123;i, k&#125;<span class="built_in">^</span>&#123;0&#125;<span class="keyword">\right</span><span class="keyword">\&#125;</span><span class="built_in">$</span></span><br><span class="line">     <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\algorithmicrequire</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;Store:&#125;&#125;</span><br><span class="line">     <span class="keyword">\REQUIRE</span> group attributes <span class="built_in">$</span><span class="keyword">\mathbf</span>&#123;a&#125;<span class="built_in">_</span>&#123;k&#125;<span class="built_in">$</span> for each <span class="built_in">$</span>g<span class="built_in">_</span>&#123;k&#125; <span class="keyword">\in</span> <span class="keyword">\mathbf</span>&#123;G&#125;<span class="built_in">$</span></span><br><span class="line">     <span class="keyword">\ENSURE</span>  users&#x27; profile <span class="built_in">$</span><span class="keyword">\left</span><span class="keyword">\langle</span><span class="keyword">\mathbf</span>&#123;p&#125;<span class="built_in">_</span>&#123;i&#125;, h<span class="built_in">_</span>&#123;i, 0&#125;<span class="keyword">\right</span><span class="keyword">\rangle</span><span class="built_in">$</span> and social strength <span class="built_in">$</span>w<span class="built_in">_</span>&#123;i j&#125;<span class="built_in">$</span></span><br><span class="line">  <span class="keyword">\STATE</span> Iteration = True;</span><br><span class="line">  <span class="keyword">\WHILE</span>&#123;Iteration&#125;</span><br><span class="line">  <span class="keyword">\STATE</span> Iteration <span class="built_in">$</span>=<span class="built_in">$</span> False;</span><br><span class="line">  <span class="keyword">\FOR</span>[comment for FOR] &#123;<span class="built_in">$</span>u<span class="built_in">_</span>&#123;i&#125; <span class="keyword">\in</span> <span class="keyword">\mathbf</span>&#123;U&#125;, g<span class="built_in">_</span>&#123;k&#125; <span class="keyword">\in</span> <span class="keyword">\mathbf</span>&#123;G&#125;<span class="built_in">$</span>&#125;</span><br><span class="line">  <span class="keyword">\STATE</span> update <span class="built_in">$</span><span class="keyword">\left</span><span class="keyword">\langle</span><span class="keyword">\mathbf</span>&#123;p&#125;<span class="built_in">_</span>&#123;i&#125;, h<span class="built_in">_</span>&#123;i, 0&#125;<span class="keyword">\right</span><span class="keyword">\rangle</span><span class="built_in">$</span> and <span class="built_in">$</span><span class="keyword">\left</span><span class="keyword">\&#123;</span>w<span class="built_in">_</span>&#123;i j&#125;<span class="keyword">\right</span><span class="keyword">\&#125;</span><span class="built_in">$</span> until convergence;</span><br><span class="line">  <span class="keyword">\STATE</span> update <span class="built_in">$</span>f<span class="built_in">_</span>&#123;i, k&#125;, h<span class="built_in">_</span>&#123;i, k&#125;<span class="built_in">$</span> based on Equation 2;</span><br><span class="line">  <span class="keyword">\STATE</span> update <span class="built_in">$</span>s<span class="built_in">_</span>&#123;i, k&#125;<span class="built_in">$</span> as <span class="built_in">$</span><span class="keyword">\mathcal</span>&#123;I&#125;<span class="keyword">\left</span>(f<span class="built_in">_</span>&#123;i, k&#125;-h<span class="built_in">_</span>&#123;i, k&#125;<span class="keyword">\right</span>)<span class="built_in">$</span>;</span><br><span class="line">  <span class="keyword">\IF</span>&#123;<span class="built_in">$</span>s<span class="built_in">_</span>&#123;i, k&#125;<span class="built_in">$</span> changed&#125; </span><br><span class="line">  <span class="keyword">\STATE</span> Iteration <span class="built_in">$</span>=<span class="built_in">$</span> True;</span><br><span class="line">  <span class="keyword">\ENDIF</span></span><br><span class="line">  <span class="keyword">\ENDFOR</span></span><br><span class="line">  <span class="keyword">\ENDWHILE</span></span><br><span class="line"> <span class="keyword">\end</span>&#123;algorithmic&#125;  </span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algpseudocode&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;An algorithm with caption&#125;<span class="keyword">\label</span>&#123;alg:cap&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithmic&#125;[1]</span><br><span class="line"><span class="keyword">\Require</span> <span class="built_in">$</span>n <span class="keyword">\geq</span> 0<span class="built_in">$</span></span><br><span class="line"><span class="keyword">\Ensure</span> <span class="built_in">$</span>y = x<span class="built_in">^</span>n<span class="built_in">$</span></span><br><span class="line"><span class="keyword">\State</span> <span class="built_in">$</span>y <span class="keyword">\gets</span> 1<span class="built_in">$</span></span><br><span class="line"><span class="keyword">\State</span> <span class="built_in">$</span>X <span class="keyword">\gets</span> x<span class="built_in">$</span></span><br><span class="line"><span class="keyword">\State</span> <span class="built_in">$</span>N <span class="keyword">\gets</span> n<span class="built_in">$</span></span><br><span class="line"><span class="keyword">\While</span>&#123;<span class="built_in">$</span>N <span class="keyword">\neq</span> 0<span class="built_in">$</span>&#125;</span><br><span class="line"><span class="keyword">\If</span>&#123;<span class="built_in">$</span>N<span class="built_in">$</span> is even&#125;</span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>X <span class="keyword">\gets</span> X <span class="keyword">\times</span> X<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>N <span class="keyword">\gets</span> <span class="keyword">\frac</span>&#123;N&#125;&#123;2&#125;<span class="built_in">$</span>  <span class="keyword">\Comment</span>&#123;This is a comment&#125;</span><br><span class="line"><span class="keyword">\ElsIf</span>&#123;<span class="built_in">$</span>N<span class="built_in">$</span> is odd&#125;</span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>y <span class="keyword">\gets</span> y <span class="keyword">\times</span> X<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\State</span> <span class="built_in">$</span>N <span class="keyword">\gets</span> N - 1<span class="built_in">$</span></span><br><span class="line"><span class="keyword">\EndIf</span></span><br><span class="line"><span class="keyword">\EndWhile</span></span><br><span class="line"><span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;definition&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;definition&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带编号的公式"><a href="#带编号的公式" class="headerlink" title="带编号的公式"></a>带编号的公式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43658047/article/details/107758820">公式溢出调整大小</a>。使用类似<code>\begin&#123;footnotesize&#125;</code>的框起来。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="keyword">\arg</span> <span class="keyword">\min</span> <span class="built_in">_</span>&#123;<span class="keyword">\mathbf</span>&#123;p&#125;, h<span class="built_in">_</span>&#123;0&#125;, w&#125; <span class="keyword">\sum</span><span class="built_in">_</span>&#123;u<span class="built_in">_</span>&#123;i&#125; <span class="keyword">\in</span> U&#125; <span class="keyword">\sum</span><span class="built_in">_</span>&#123;g<span class="built_in">_</span>&#123;k&#125; <span class="keyword">\in</span> G&#125;<span class="keyword">\left</span>[s<span class="built_in">_</span>&#123;i, k&#125;<span class="built_in">^</span>&#123;0&#125;-<span class="keyword">\mathcal</span>&#123;I&#125;<span class="keyword">\left</span>(f<span class="built_in">_</span>&#123;i, k&#125;-h<span class="built_in">_</span>&#123;i, k&#125;<span class="keyword">\right</span>)<span class="keyword">\right</span>]<span class="built_in">^</span>&#123;2&#125;<span class="keyword">\label</span>&#123;4&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对齐等号"><a href="#对齐等号" class="headerlink" title="对齐等号"></a>对齐等号</h3><ul>
<li>aligned就是用来公式对齐的，在中间公式中，</li>
<li><code>\\</code> 表示换行，</li>
<li><code>&amp;</code> 表示对齐。在公式中等号之前加<code>&amp;</code>来对齐。</li>
<li><code>*</code> 代表取消公式编号<code>(1)</code></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align*&#125;</span><br><span class="line"></span><br><span class="line">* <span class="built_in">&amp;</span>= *<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>=* <span class="keyword">\\</span></span><br><span class="line">  <span class="built_in">&amp;</span>= *</span><br><span class="line"><span class="keyword">\end</span>&#123;align*&#125;</span><br></pre></td></tr></table></figure>

<h3 id="换行命令"><a href="#换行命令" class="headerlink" title="换行命令"></a>换行命令</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\\</span>：换行。</span><br><span class="line"><span class="keyword">\\</span>[offset]：换行，并且与下一行的行间距为原来行间距+offset。</span><br><span class="line"><span class="keyword">\newline</span>：与<span class="keyword">\\</span>相同。</span><br><span class="line"><span class="keyword">\linebreak</span>：强制换行，与<span class="keyword">\newline</span>的区别为<span class="keyword">\linebreak</span>的当前行分散对齐。</span><br></pre></td></tr></table></figure>

<h3 id="分段命令"><a href="#分段命令" class="headerlink" title="分段命令"></a>分段命令</h3><p>\par：分段。</p>
<h3 id="分页命令"><a href="#分页命令" class="headerlink" title="分页命令"></a>分页命令</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\newpage</span>：分页命令。</span><br><span class="line"><span class="keyword">\clearpage</span>：和 <span class="keyword">\newpage</span> 类似。我们在使用 CJK 环境时会加入 <span class="keyword">\clearpage</span> 在环境末尾。</span><br></pre></td></tr></table></figure>

<h2 id="各种普通符号"><a href="#各种普通符号" class="headerlink" title="各种普通符号"></a>各种普通符号</h2><h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\cdots</span>是横向的省略号</span><br><span class="line"><span class="keyword">\vdots</span>是竖向的省略号</span><br><span class="line"><span class="keyword">\ddots</span>是对角线方向的省略号</span><br><span class="line"><span class="keyword">\ldots</span> 是跟文本底线对齐的省略号</span><br></pre></td></tr></table></figure>

<h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><p>\rightarrow → \leftarrow ← \Rightarrow ⇒ \Leftarrow ⇐</p>
<p>数学字符上的剪头 \overrightarrow{}</p>
<p>各类箭头符号集锦，原文链接：<a target="_blank" rel="noopener" href="http://www.hijtr.com/latex-arrows/">http://www.hijtr.com/latex-arrows/</a></p>
<h3 id="大小括号"><a href="#大小括号" class="headerlink" title="大小括号"></a>大小括号</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">f(x)=</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">0<span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;x=0&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">1<span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;x!=0&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<h3 id="矩阵符号"><a href="#矩阵符号" class="headerlink" title="矩阵符号"></a>矩阵符号</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\left</span> [ <span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1<span class="built_in">&amp;</span> 3 <span class="keyword">\\</span></span><br><span class="line">2<span class="built_in">&amp;</span> 4 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125; <span class="keyword">\right</span> ]</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>其中 \left 和 \right 表示左右定界符，后面跟着的是左右封闭的符号，可以是 ｜ 或者 [] 或者 {}</p>
<h2 id="各种表格"><a href="#各种表格" class="headerlink" title="各种表格"></a>各种表格</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/JueChenYi/article/details/77116011">https://blog.csdn.net/JueChenYi/article/details/77116011</a></p>
<h2 id="数学特殊符号"><a href="#数学特殊符号" class="headerlink" title="数学特殊符号"></a>数学特殊符号</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/caiandyong/article/details/53351737">其余</a></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\bra</span>&#123;<span class="keyword">\psi</span>&#125;<span class="comment">%左态矢</span></span><br><span class="line"><span class="keyword">\ket</span>&#123;<span class="keyword">\psi</span>&#125;<span class="comment">%右态矢</span></span><br><span class="line"><span class="keyword">\hat</span>&#123;H&#125;<span class="comment">%在H上方加帽子</span></span><br><span class="line"><span class="keyword">\hat</span>&#123;H<span class="built_in">^</span>&#123;<span class="keyword">\dagger</span>&#125;&#125;<span class="comment">%H的转置复共轭</span></span><br><span class="line"><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\langle</span><span class="keyword">\psi</span>|<span class="comment">%左态矢</span></span><br><span class="line">|<span class="keyword">\psi</span><span class="keyword">\rangle</span><span class="comment">%右态矢</span></span><br><span class="line"><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<h2 id="上下左右"><a href="#上下左右" class="headerlink" title="上下左右"></a>上下左右</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\underset</span>&#123;下面&#125;&#123;<span class="keyword">\max</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>\vec{AB}</p>
<h2 id="任意元素，-所有元素"><a href="#任意元素，-所有元素" class="headerlink" title="任意元素， 所有元素"></a>任意元素， 所有元素</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% （1）任意</span></span><br><span class="line"><span class="built_in">$</span> &#123;<span class="keyword">\forall</span>&#125;<span class="built_in">$</span></span><br><span class="line"><span class="comment">% （2）存在</span></span><br><span class="line"><span class="built_in">$</span> &#123;<span class="keyword">\exists</span>&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<h2 id="属于，不属于"><a href="#属于，不属于" class="headerlink" title="属于，不属于"></a>属于，不属于</h2><p>属于： &#x2F;in</p>
<p>不属于：&#x2F;notin</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>点乘：a \cdot b</p>
<p>叉乘：a \times b</p>
<p>除以：a \div b</p>
<p>求和 \sum_{}^{}</p>
<p>开方 \sqrt{}</p>
<p>\le和\leq为小于等于</p>
<p>\ge和\geq为大于等于</p>
<p>\neq为不等于</p>
<p>\equiv 恒等于</p>
<p>\approx 约等于</p>
<h2 id="各种数域"><a href="#各种数域" class="headerlink" title="各种数域"></a>各种数域</h2><p>\usepackage{amsfonts}<br>或则<br>\usepackage{amssymb}</p>
<p><img src="https://pic.shaojiemike.top/img/20220304143629.png"></p>
<p>有理数在英文中称作rational number</p>
<h2 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xxzhangx/article/details/52778539">https://blog.csdn.net/xxzhangx/article/details/52778539</a></p>
<p><img src="https://pic.shaojiemike.top/img/20220304143328.png"></p>
<h2 id="文献引用"><a href="#文献引用" class="headerlink" title="文献引用"></a>文献引用</h2><h3 id="不使用BibTeX"><a href="#不使用BibTeX" class="headerlink" title="不使用BibTeX"></a>不使用BibTeX</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;  </span><br><span class="line"><span class="keyword">\bibitem</span>&#123;ref1&#125;Zheng L, Wang S, Tian L, et al., Query-adaptive late fusion for image search and person re-identification, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2015: 1741-1750.  </span><br><span class="line"><span class="keyword">\bibitem</span>&#123;ref2&#125;Arandjelović R, Zisserman A, Three things everyone should know to improve object retrieval, Computer Vision and Pattern Recognition (CVPR), 2012 IEEE Conference on, IEEE, 2012: 2911-2918.  </span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\cite</span>&#123;ref1&#125;</span><br><span class="line"><span class="keyword">\cite</span>&#123;ref1, ref5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用BibTeX"><a href="#使用BibTeX" class="headerlink" title="使用BibTeX"></a>使用BibTeX</h3><p>BibTeX 文件的后缀名为 <code>.bib</code>, google scholar查找其内容</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@article&#123;name1,</span><br><span class="line">author = &#123;作者, 多个作者用 and 连接&#125;,</span><br><span class="line">title = &#123;标题&#125;,</span><br><span class="line">journal = &#123;期刊名&#125;,</span><br><span class="line">volume = &#123;卷20&#125;,</span><br><span class="line">number = &#123;页码&#125;,</span><br><span class="line">year = &#123;年份&#125;,</span><br><span class="line">abstract = &#123;摘要, 这个主要是引用的时候自己参考的, 这一行不是必须的&#125;</span><br><span class="line">&#125;</span><br><span class="line">@book&#123;name2,</span><br><span class="line">author =&quot;作者&quot;,</span><br><span class="line">year=&quot;年份2008&quot;,</span><br><span class="line">title=&quot;书名&quot;,</span><br><span class="line">publisher =&quot;出版社名称&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="overleaf使用"><a href="#overleaf使用" class="headerlink" title="overleaf使用"></a>overleaf使用</h3><ol>
<li>生成 ref.bib</li>
<li>各种学术网址引用BibTex<img src="https://pic.shaojiemike.top/img/20220621204135.png"></li>
<li><code>\end&#123;document&#125;</code> 之前加入<ol>
<li><code>\bibliographystyle&#123;ieeetr&#125;</code>, <code>ieeetr</code>国际电气电子工程师协会期刊</li>
<li><code>\bibliography&#123;ref&#125;</code> , <code>ref</code>就是之前建立的<code>ref.bib</code>文件的前缀, present the source of reference information</li>
</ol>
</li>
<li><code>\cite&#123;Han&#125;</code>。 在 ref.bib文件中的Han 与<code>\cite&#123;Han&#125;</code> 保持一致</li>
</ol>
<h3 id="pink-and-clickable-URL"><a href="#pink-and-clickable-URL" class="headerlink" title="pink and clickable URL"></a>pink and clickable URL</h3><p><code>\usepackage[colorlinks=true,linkcolor=black,urlcolor=magenta]&#123;hyperref&#125;</code></p>
<h2 id="shorten-reference"><a href="#shorten-reference" class="headerlink" title="shorten reference"></a>shorten reference</h2><p>Requirements:</p>
<ol>
<li>shorten authors (1st author only, others are shorten “et al”)</li>
<li>Bibtex can sort the showed element, but not support sellect the showed elements. So you should delete useless elements in <code>bib</code> file like <code>publisher</code>, <code>pages</code></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://tex.stackexchange.com/questions/195270/shortening-reference">Blog</a> shows that we can select <strong>bibliographystyle</strong> in these <a target="_blank" rel="noopener" href="https://www.cs.stir.ac.uk/~kjt/software/latex/showbst.html">choices</a>, and design your cite in <a target="_blank" rel="noopener" href="https://tex.stackexchange.com/questions/131869/biblatex-how-to-abbreviate-names-in-citations-only-get-say-first-letters-of/131878#131878">this</a></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[style=numeric,backend=biber]&#123;biblatex&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[colorlinks=true,linkcolor=black,urlcolor=magenta]&#123;hyperref&#125;</span><br><span class="line"><span class="keyword">\addbibresource</span>&#123;jobname.bib&#125; <span class="comment">% Replace with the actual name of your .bib file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;etoolbox&#125;</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\biblabelsep</span>&#125;&#123;0.5em&#125; <span class="comment">% Adjust the distance between the label (e.g., [1]) and the main text in the reference section as needed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\DeclareCiteCommand</span>&#123;<span class="keyword">\cite</span>&#125;</span><br><span class="line">  &#123;<span class="keyword">\usebibmacro</span>&#123;prenote&#125;&#125;</span><br><span class="line">  &#123;<span class="keyword">\mkbibbrackets</span>&#123;<span class="keyword">\printfield</span>&#123;labelnumber&#125;&#125;&#125; <span class="comment">% cite number in main body should be surrounded by square brackets</span></span><br><span class="line">  &#123;<span class="keyword">\multicitedelim</span>&#125;</span><br><span class="line">  &#123;<span class="keyword">\usebibmacro</span>&#123;postnote&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\DeclareSortingScheme</span>&#123;custom&#125;&#123;</span><br><span class="line">  <span class="keyword">\sort</span>[direction=ascending]&#123;<span class="keyword">\field</span>&#123;author&#125;&#125; <span class="comment">% showed order</span></span><br><span class="line">  <span class="keyword">\sort</span>[direction=ascending]&#123;<span class="keyword">\field</span>&#123;title&#125;&#125;</span><br><span class="line">  <span class="keyword">\sort</span>[direction=ascending]&#123;<span class="keyword">\field</span>&#123;year&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\DeclareSortingTemplate</span>&#123;custom&#125;&#123;<span class="keyword">\sort</span>[direction=ascending]&#123;<span class="keyword">\field</span>&#123;sortkey&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Define a command to set the font size for the reference section</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\smallerfont</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;9&#125;&#123;11&#125;<span class="keyword">\selectfont</span>&#125; <span class="comment">% Adjust the font size as needed</span></span><br><span class="line"><span class="keyword">\AtBeginBibliography</span>&#123;<span class="keyword">\smallerfont</span>&#125; <span class="comment">% Set the font size for the entire reference section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Redefine the &quot;in:&quot; bibmacro</span></span><br><span class="line"><span class="keyword">\renewbibmacro</span>&#123;in:&#125;&#123;<span class="comment">%</span></span><br><span class="line">  <span class="keyword">\ifentrytype</span>&#123;article&#125;</span><br><span class="line">    &#123;<span class="keyword">\printtext</span>&#123;in abc&#125;&#125; <span class="comment">% if true</span></span><br><span class="line">    &#123;<span class="keyword">\printtext</span>&#123;in xxx <span class="keyword">\addcolon</span>&#125;&#125;<span class="comment">% else </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Redefine the title bibmacro to change the punctuation</span></span><br><span class="line"><span class="keyword">\renewbibmacro</span>*&#123;title&#125;&#123;<span class="comment">% can not get worked in author and journal enries, So weird</span></span><br><span class="line">  <span class="keyword">\printfield</span>&#123;title&#125;<span class="comment">%</span></span><br><span class="line">  <span class="keyword">\printtext</span>&#123;,&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\renewbibmacro</span>*&#123;journal+issuetitle&#125;&#123;<span class="comment">%</span></span><br><span class="line">  <span class="keyword">\usebibmacro</span>&#123;journal&#125;<span class="comment">%</span></span><br><span class="line">  <span class="comment">% \printtext&#123;,&#125;</span></span><br><span class="line">  <span class="comment">% \setunit&#123;\addcomma\space&#125;% Change the separator here</span></span><br><span class="line">  <span class="comment">% \iffieldundef&#123;series&#125;</span></span><br><span class="line">  <span class="comment">%   &#123;&#125;</span></span><br><span class="line">  <span class="comment">%   &#123;\newunit</span></span><br><span class="line">  <span class="comment">%    \printfield&#123;series&#125;%</span></span><br><span class="line">  <span class="comment">%    \setunit&#123;\addspace&#125;&#125;%</span></span><br><span class="line">  <span class="comment">% \usebibmacro&#123;volume+number+eid&#125;%</span></span><br><span class="line">  <span class="comment">% \setunit&#123;\addcolon\space&#125;%</span></span><br><span class="line">  <span class="comment">% \usebibmacro&#123;note+pages&#125;%</span></span><br><span class="line">  <span class="comment">% \newunit</span></span><br><span class="line">  <span class="keyword">\usebibmacro</span>&#123;issue+date&#125;<span class="comment">%</span></span><br><span class="line">  <span class="comment">% \newunit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\renewbibmacro</span>*&#123;booktitle&#125;&#123;<span class="comment">% </span></span><br><span class="line">  <span class="keyword">\printfield</span>&#123;booktitle&#125;<span class="comment">%</span></span><br><span class="line">  <span class="keyword">\printtext</span>&#123;,&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\cite</span>&#123;Smith2020&#125; found that...</span><br><span class="line"><span class="keyword">\cite</span>&#123;A01&#125; found that...</span><br><span class="line"></span><br><span class="line"><span class="keyword">\printbibliography</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>or just not using BibTeX</p>
<h3 id="colorful-the-url"><a href="#colorful-the-url" class="headerlink" title="colorful the url"></a>colorful the url</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[colorlinks=true,linkcolor=black,urlcolor=magenta,citecolor=blue]&#123;hyperref&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\href</span>&#123;<span class="link">https://www.hisilicon.com/en/products/Kunpeng/Huawei-Kunpeng/Huawei-Kunpeng-920</span>&#125;&#123;https://www.hisilicon.com/en/products</span><br><span class="line">/Kunpeng/Huawei-Kunpeng/Huawei-Kunpeng-920&#125;</span><br></pre></td></tr></table></figure>

<h3 id="italic-‘et-al’"><a href="#italic-‘et-al’" class="headerlink" title="italic ‘et al’"></a>italic ‘et al’</h3><p>According to <a target="_blank" rel="noopener" href="https://tex.stackexchange.com/questions/532367/bibtex-style-with-et-al-in-italic">blog</a>, it seems we should change the <code>bst</code> file. But this <a target="_blank" rel="noopener" href="https://github.com/plk/biblatex/issues/899">issure</a> shows a available way:</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span>*&#123;<span class="keyword">\mkbibetal</span>&#125;[1]&#123;<span class="params">#1</span>&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>*&#123;<span class="keyword">\mkbibetal</span>&#125;&#123;<span class="keyword">\mkbibitalic</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\renewbibmacro</span>*&#123;name:andothers&#125;&#123;<span class="comment">%  The * symbol is used to make sure that any previous redefinitions of the same macro are discarded, and the new definition takes precedence.</span></span><br><span class="line">  <span class="keyword">\ifboolexpr</span>&#123;</span><br><span class="line">    test &#123;<span class="keyword">\ifnumequal</span>&#123;<span class="keyword">\value</span>&#123;listcount&#125;&#125;&#123;<span class="keyword">\value</span>&#123;liststop&#125;&#125;&#125;</span><br><span class="line">    and</span><br><span class="line">    test <span class="keyword">\ifmorenames</span></span><br><span class="line">  &#125;</span><br><span class="line">    &#123;<span class="keyword">\ifnumgreater</span>&#123;<span class="keyword">\value</span>&#123;liststop&#125;&#125;&#123;1&#125;</span><br><span class="line">       &#123;<span class="keyword">\finalandcomma</span>&#125;</span><br><span class="line">       &#123;&#125;<span class="comment">%</span></span><br><span class="line">     <span class="keyword">\printdelim</span>&#123;andothersdelim&#125;<span class="keyword">\bibstring</span>[<span class="keyword">\mkbibetal</span>]&#123;andothers&#125;&#125;</span><br><span class="line">    &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>






<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yifdu25/p/8330652.html">https://www.cnblogs.com/yifdu25/p/8330652.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33066729/article/details/88066630">https://blog.csdn.net/qq_33066729/article/details/88066630</a></p>
<p>[^1]: <a target="_blank" rel="noopener" href="https://tex.stackexchange.com/questions/507795/revtex-multiple-authors-with-no-affiliations-how-to-put-equal-contribution-as">texstack: how to put equal contribution as footnote?</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-16T07:19:58.000Z" title="9/16/2023, 7:19:58 AM">2023-09-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-12T08:56:40.027Z" title="1/12/2024, 8:56:40 AM">2024-01-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Tutorials/">Tutorials</a></span><span class="level-item">a minute read (About 195 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/16/OutOfWork/2-selfLearning/AI-tools/LLM-prompt/">LLM Usage 1: prompt engineer</a></p><div class="content"><span id="more"></span>

<h2 id="Free-GPT"><a href="#Free-GPT" class="headerlink" title="Free GPT"></a>Free GPT</h2><ol>
<li><a target="_blank" rel="noopener" href="http://chat.openai.com/">chatgpt</a></li>
<li><a target="_blank" rel="noopener" href="http://chat.openai.com/">Claude 2</a></li>
<li><a target="_blank" rel="noopener" href="https://copilot.microsoft.com/">microsoft copilot</a></li>
<li>google bard 升级</li>
</ol>
<h3 id="GPT4-used-in-Domestic"><a href="#GPT4-used-in-Domestic" class="headerlink" title="GPT4 used in Domestic"></a>GPT4 used in Domestic</h3><p><a target="_blank" rel="noopener" href="https://www.vpsdawanjia.com/8144.html">link1</a> or peiqishop.me</p>
<h2 id="paper-writing"><a href="#paper-writing" class="headerlink" title="paper writing"></a>paper writing</h2><h3 id="Polish-paper-writing"><a href="#Polish-paper-writing" class="headerlink" title="Polish paper writing"></a>Polish paper writing</h3><!-- If you are a computer scientist, please to polish the following word to easy-reading, formal, official pithy and academic **paper-writing** expression , if you can make the words more gorgeous is much better: -->

<ol>
<li><strong>concise</strong> and correct the wrong grammer in the following paragraph in CS <strong>acadamic</strong> paper tone in english:</li>
<li>polish the paragraph using easy-to-read comfact english tech-blog tone.</li>
</ol>
<h2 id="correct-the-grammar"><a href="#correct-the-grammar" class="headerlink" title="correct the grammar"></a>correct the grammar</h2><p>If you are a computer science, please point out and correct the following wrong English writing grammar in the passage of the paper in acadamic paper-writing tone.</p>
<h2 id="需要进一步的研究学习"><a href="#需要进一步的研究学习" class="headerlink" title="需要进一步的研究学习"></a>需要进一步的研究学习</h2><p>暂无</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>暂无</p>
<h2 id="开题缘由、总结、反思、吐槽"><a href="#开题缘由、总结、反思、吐槽" class="headerlink" title="开题缘由、总结、反思、吐槽~~"></a>开题缘由、总结、反思、吐槽~~</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>上面回答部分<strong>来自ChatGPT-3.5</strong>，没有进行正确性的交叉校验。</p>
<div id='refer-anchor'></div>

<p>无</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/12/">Previous</a></div><div class="pagination-next"><a href="/page/14/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/12/">12</a></li><li><a class="pagination-link is-current" href="/page/13/">13</a></li><li><a class="pagination-link" href="/page/14/">14</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/39/">39</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="Shaojie Tan"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shaojie Tan</p><p class="is-size-6 is-block">𝘊𝘰𝘮𝘱𝘶𝘵𝘦𝘳 𝘈𝘳𝘤𝘩𝘪𝘵𝘦𝘤𝘵𝘶𝘳𝘦 &amp; 𝘏𝘗𝘊</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Anhui, Hefei, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">382</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">30</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">487</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Kirrito-k423" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Kirrito-k423"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithms/"><span class="level-start"><span class="level-item">Algorithms</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/Architecture/"><span class="level-start"><span class="level-item">Architecture</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li><li><a class="level is-mobile" href="/categories/Artificial-Intelligence/"><span class="level-start"><span class="level-item">Artificial Intelligence</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Databases/"><span class="level-start"><span class="level-item">Databases</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/HPC/"><span class="level-start"><span class="level-item">HPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/OOW/"><span class="level-start"><span class="level-item">OOW</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Operating-system/"><span class="level-start"><span class="level-item">Operating system</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Overview/"><span class="level-start"><span class="level-item">Overview</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/Software/"><span class="level-start"><span class="level-item">Software</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tips/"><span class="level-start"><span class="level-item">Tips</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Treasure/"><span class="level-start"><span class="level-item">Treasure</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tutorials/"><span class="level-start"><span class="level-item">Tutorials</span></span><span class="level-end"><span class="level-item tag">118</span></span></a></li><li><a class="level is-mobile" href="/categories/Values/"><span class="level-start"><span class="level-item">Values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/architecture/"><span class="level-start"><span class="level-item">architecture</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/diary/"><span class="level-start"><span class="level-item">diary</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/english/"><span class="level-start"><span class="level-item">english</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/hardware/"><span class="level-start"><span class="level-item">hardware</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/math/"><span class="level-start"><span class="level-item">math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/operating-system/"><span class="level-start"><span class="level-item">operating system</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/security/"><span class="level-start"><span class="level-item">security</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/software/"><span class="level-start"><span class="level-item">software</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/thinking/"><span class="level-start"><span class="level-item">thinking</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/thinking/OOW/"><span class="level-start"><span class="level-item">OOW</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/toLearn/"><span class="level-start"><span class="level-item">toLearn</span></span><span class="level-end"><span class="level-item tag">50</span></span></a></li><li><a class="level is-mobile" href="/categories/values/"><span class="level-start"><span class="level-item">values</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://ibug.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ibugs</span></span><span class="level-right"><span class="level-item tag">ibug.io</span></span></a></li><li><a class="level is-mobile" href="https://jia.je/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">jiegec</span></span><span class="level-right"><span class="level-item tag">jia.je</span></span></a></li><li><a class="level is-mobile" href="https://leimao.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">leimao</span></span><span class="level-right"><span class="level-item tag">leimao.github.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-10T12:00:31.000Z">2024-01-10</time></p><p class="title"><a href="/2024/01/10/Work/Programming/2-languageGrammar/OpenCLBasic/">OpenCL Basic</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-10T08:18:51.000Z">2024-01-10</time></p><p class="title"><a href="/2024/01/10/Work/Architecture/GPU/huaweiDaVinci/">Huawei GPU : DaVinci</a></p><p class="categories"><a href="/categories/toLearn/">toLearn</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-09T15:38:04.000Z">2024-01-09</time></p><p class="title"><a href="/2024/01/09/Work/Programming/6-deploy/pipPackage/">Build and release your Pip Package</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-05T07:17:06.000Z">2024-01-05</time></p><p class="title"><a href="/2024/01/05/Work/Programming/2-languageGrammar/cudaExeModel/">The CUDA Execution Model</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-04T02:55:54.000Z">2024-01-04</time></p><p class="title"><a href="/2024/01/04/Work/Architecture/performanceModel/GPUPerformanceModel/">CPU / GPU Performance Model based on Interval Analysis</a></p><p class="categories"><a href="/categories/Architecture/">Architecture</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">235</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">67</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">72</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/5G/"><span class="tag">5G</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/64bits-vs-32bits/"><span class="tag">64bits vs 32bits</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMAT/"><span class="tag">AMAT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AMD/"><span class="tag">AMD</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ASPLOS/"><span class="tag">ASPLOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ATI/"><span class="tag">ATI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AVX/"><span class="tag">AVX</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Alpha/"><span class="tag">Alpha</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Analysis/"><span class="tag">Analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Apt/"><span class="tag">Apt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BFS/"><span class="tag">BFS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BHive/"><span class="tag">BHive</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BT/"><span class="tag">BT</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BTL/"><span class="tag">BTL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Baka-Mitai/"><span class="tag">Baka Mitai</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Big-Endian/"><span class="tag">Big-Endian</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SHAOJIE&#039;S BOOK" height="28"></a><p class="is-size-7"><span>&copy; 2024 Shaojie Tan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Kirrito-k423/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>